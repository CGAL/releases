@B@<Rays@>
@C@<Class CGAL_RayH2<FT,RT>@>

@D@<Representation@>

In this version rays are represented by two points (like segments,
but not like lines). A representation by a point and a direction
seems to be more natural however.

@$@<class CGAL_RayH2_rep<FT,RT>@>==@{@+

template < class FT, class RT >
class CGAL__Ray_repH2 : public CGAL_Rep
{
public:
                        CGAL__Ray_repH2();
                        CGAL__Ray_repH2(const CGAL_PointH2<FT,RT>& fp,
                                        const CGAL_PointH2<FT,RT>& sp);
                        ~CGAL__Ray_repH2(){}

    CGAL_PointH2<FT,RT>  start;
    CGAL_PointH2<FT,RT>  second;
};
@}

@$@<Code for CGAL_RayH2_rep<FT,RT>@>+=@{@+
template < class FT, class RT >
CGAL__Ray_repH2<FT,RT>::CGAL__Ray_repH2()
{
}


template < class FT, class RT >
CGAL__Ray_repH2<FT,RT>::CGAL__Ray_repH2(const CGAL_PointH2<FT,RT>& fp,
                                        const CGAL_PointH2<FT,RT>& sp) :
  start(fp), second(sp)
{
}
@}

@D@<Class CGAL_RayH2<FT,RT>@>

@$@<class CGAL_RayH2<FT,RT>@>==@{@+

template < class FT, class RT >
class CGAL_RayH2 : public CGAL_Handle
{
public:
            CGAL_RayH2();
            CGAL_RayH2( const CGAL_RayH2& r);
            CGAL_RayH2( const CGAL_PointH2<FT,RT>& sp,
                        const CGAL_PointH2<FT,RT>& secondp);
            CGAL_RayH2( const CGAL_PointH2<FT,RT>& sp,
                        const CGAL_DirectionH2<FT,RT>& d);
            ~CGAL_RayH2();

    CGAL_RayH2<FT,RT>&
            operator=(const CGAL_RayH2<FT,RT>& r);

    bool    operator==(const CGAL_RayH2& r) const;
    bool    operator!=(const CGAL_RayH2& r) const;
    bool    identical( const CGAL_RayH2& r) const;
    int     id() const;

    CGAL_PointH2<FT,RT>     start() const;
    CGAL_PointH2<FT,RT>     source() const;
    CGAL_PointH2<FT,RT>     second_point() const;
    CGAL_PointH2<FT,RT>     point(int i) const;
    CGAL_DirectionH2<FT,RT> direction() const;
    CGAL_LineH2<FT,RT>      supporting_line() const;
    CGAL_RayH2              opposite() const;

    bool    is_horizontal() const;
    bool    is_vertical() const;
    bool    has_on(const CGAL_PointH2<FT,RT> p) const;
    bool    collinear_has_on(const CGAL_PointH2<FT,RT> p) const;
    bool    is_degenerate() const;

    CGAL_RayH2<FT,RT>
            transform( const CGAL_Aff_transformationH2<FT,RT> & t) const;
protected:

    CGAL__Ray_repH2<FT,RT>*
            ptr() const;
};
@}

@D@<Constructors and Destructor@>

@$@<Code for CGAL_RayH2<FT,RT>@>+=@{@+

template < class FT, class RT >
CGAL_RayH2<FT,RT>::CGAL_RayH2()
{
#ifdef CGAL_CHECK_PRECONDITIONS
  PTR = NULL;
#else
 PTR = new CGAL__Ray_repH2<FT,RT>;
#endif // CGAL_CHECK_PRECONDITIONS
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>::CGAL_RayH2(const CGAL_RayH2<FT,RT>& r) :
  CGAL_Handle(r)
{
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>::CGAL_RayH2( const CGAL_PointH2<FT,RT>& sp,
                               const CGAL_PointH2<FT,RT>& secondp)
{
 PTR = new CGAL__Ray_repH2<FT,RT>(sp,secondp);
 CGAL_nondegeneracy_assertion;
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>::CGAL_RayH2( const CGAL_PointH2<FT,RT>& sp,
                               const CGAL_DirectionH2<FT,RT>& d)
{
 PTR = new CGAL__Ray_repH2<FT,RT>(sp, sp + d.vector());
 CGAL_nondegeneracy_assertion;
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>::~CGAL_RayH2()
{
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>&
CGAL_RayH2<FT,RT>::operator=(const CGAL_RayH2<FT,RT>& r)
{
 CGAL_Handle::operator=(r);
 return *this;
}
@}

@D@<Access member functions@>

@$@<Code for CGAL_RayH2<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_PointH2<FT,RT>
CGAL_RayH2<FT,RT>::source() const
{
 return ptr()->start;
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>
CGAL_RayH2<FT,RT>::start() const
{
 return ptr()->start;
}


template < class FT, class RT >
CGAL_DirectionH2<FT,RT>
CGAL_RayH2<FT,RT>::direction() const
{
 CGAL_nondegeneracy_precondition( !is_degenerate() );
 return CGAL_DirectionH2<FT,RT>( ptr()->second - ptr()->start );
}
@}

@D@<Further member functions@>
@$@<Code for CGAL_RayH2<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_PointH2<FT,RT>
CGAL_RayH2<FT,RT>::second_point() const
{
 CGAL_nondegeneracy_precondition( !is_degenerate() );
 return ptr()->second;
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>
CGAL_RayH2<FT,RT>::point(int i) const
{
 CGAL_nondegeneracy_precondition( !is_degenerate() );
 CGAL_kernel_precondition( i>= 0 );
 CGAL_VectorH2<FT,RT> v = direction().vector();
 return start() + RT(i) * v;
}

template < class FT, class RT >
CGAL_LineH2<FT,RT>
CGAL_RayH2<FT,RT>::supporting_line() const
{
 CGAL_nondegeneracy_precondition( !is_degenerate() );
 return CGAL_LineH2<FT,RT>(*this);
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>
CGAL_RayH2<FT,RT>::opposite() const
{
 return CGAL_RayH2<FT,RT>( ptr()->start, - direction() );
}

template < class FT, class RT >
CGAL_RayH2<FT,RT>
CGAL_RayH2<FT,RT>::transform(
                       const CGAL_Aff_transformationH2<FT,RT> & t) const
{
 return CGAL_RayH2<FT,RT>(t.transform(ptr()->start),
                          t.transform(ptr()->second) );
}
@}

@D@<Predicates@>

@$@<Code for CGAL_RayH2<FT,RT>@>+=@{@+
template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::is_horizontal() const
{
 return start().hy()*second_point().hw() == second_point().hy()*start().hw();
}

template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::is_vertical() const
{
 return start().hx()*second_point().hw() == second_point().hx()*start().hw();
}

template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::has_on(const CGAL_PointH2<FT,RT> p) const
{
 return ( (  p == start() )
        ||(CGAL_DirectionH2<FT,RT>(p - ptr()->start) == direction() ) );
}

template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::is_degenerate() const
{
 return ( (ptr()->start == ptr()->second) );
}

template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::collinear_has_on(const CGAL_PointH2<FT,RT> p) const
{
 return has_on(p);
}
@}

@D@<Equality and Identity@>

@$@<Code for CGAL_RayH2<FT,RT>@>+=@{@-

template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::operator==(const CGAL_RayH2<FT,RT>& r) const
{
 return ( (start() == r.start() )&&( direction() == r.direction() ) );
}

template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::operator!=( const CGAL_RayH2<FT,RT>& r) const
{
 return !(*this == r);
}


template < class FT, class RT >
bool
CGAL_RayH2<FT,RT>::identical( const CGAL_RayH2<FT,RT>& r) const
{
 return ( PTR == r.PTR );
}

template < class FT, class RT >
int
CGAL_RayH2<FT,RT>::id() const
{
 return (int)PTR;
}
@}

@D@<For internal use only@>

@$@<Code for CGAL_RayH2<FT,RT>@>+=@{@+
template < class FT, class RT >
inline
CGAL__Ray_repH2<FT,RT>*
CGAL_RayH2<FT,RT>::ptr() const
{
 return (CGAL__Ray_repH2<FT,RT>*)PTR;
}
@}

@D@<Header file@>
// Source: RayH2.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

@O@<../include/CGAL/RayH2.h@>==@{@+
@<CGAL notice@>
#ifndef CGAL_RAYH2_H
#define CGAL_RAYH2_H

@<class CGAL_RayH2_rep<FT,RT>@>
@<class CGAL_RayH2<FT,RT>@>
@<Code for CGAL_RayH2_rep<FT,RT>@>
@<Code for CGAL_RayH2<FT,RT>@>

#endif // CGAL_RAYH2_H
@}
