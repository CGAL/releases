@! $RCSfile: predicates_on_points_3.fw,v $
@! $Revision: 1.1 $
@! $Date: 1996/03/13 15:32:23 $

@! Author: Andreas.Fabri@@sophia.inria.fr

@B

@$@<Alignement of 3D Points@>==@{@-
template < class R >
bool CGAL_x_equal(const CGAL_Point_3<R> &p,
                  const CGAL_Point_3<R> &q)
{
  return CGAL_x_equal((const R::Point_3&)p, (const R::Point_3&)q);
}

template < class R >
bool CGAL_y_equal(const CGAL_Point_3<R> &p,
                  const CGAL_Point_3<R> &q)
{
  return CGAL_y_equal((const R::Point_3&)p, (const R::Point_3&)q);
}

template < class R >
bool CGAL_z_equal(const CGAL_Point_3<R> &p,
                  const CGAL_Point_3<R> &q)
{
  return CGAL_z_equal((const R::Point_3&)p, (const R::Point_3&)q);
}
@}

@B

@$@<Lexicograpical Order of 3D Points@>+=@{@-
template < class R >
CGAL_Comparison_result CGAL_compare_lexicographically_xyz(
                                                     const CGAL_Point_3<R> &p,
                                                     const CGAL_Point_3<R> &q)
{
 return CGAL_compare_lexicographically_xyz((const R::Point_3&)p,
                                           (const R::Point_3&)q);
}


template < class R >
bool CGAL_lexicographically_xyz_smaller_or_equal(const CGAL_Point_3<R> &p,
                                                 const CGAL_Point_3<R> &q)
{
  return ( !( CGAL_compare_lexicographically_xyz((const R::Point_3&)p,
                                                 (const R::Point_3&)q)
              == CGAL_LARGER ) );
}

template < class R >
bool CGAL_lexicographically_xyz_smaller(const CGAL_Point_3<R> &p,
                                        const CGAL_Point_3<R> &q)
{
  return ( CGAL_compare_lexicographically_xyz((const R::Point_3&)p,
                                              (const R::Point_3&)q)
           == CGAL_SMALLER );
}
@}


@B@<3D Ordertype Functions@>

There are no specializations. The problems with non-exactness are catched
in the tests. Those are specialized.

@C
@$@<3D Ordertype Interface Functions@>==@{@-
template < class R >
inline bool CGAL_coplanar(const CGAL_Point_3<R> &p,
                          const CGAL_Point_3<R> &q,
                          const CGAL_Point_3<R> &r,
                          const CGAL_Point_3<R> &s)
{
  return ( CGAL_coplanar((const R::Point_3&)p, (const R::Point_3&)q,
                         (const R::Point_3&)r, (const R::Point_3&)s) );
}

template < class R >
bool CGAL_collinear(const CGAL_Point_3<R> &p,
                    const CGAL_Point_3<R> &q,
                    const CGAL_Point_3<R> &r)
{
 return (CGAL_collinear((const R::Point_3&)p,
                        (const R::Point_3&)q,
                        (const R::Point_3&)r));
}

template < class R >
inline bool CGAL_between(const CGAL_Point_3<R> &p,
                         const CGAL_Point_3<R> &q,
                         const CGAL_Point_3<R> &r)
{
 return (CGAL_between((const R::Point_3&)p,
                      (const R::Point_3&)q,
                      (const R::Point_3&)r));
}

template < class R >
inline bool CGAL_collinear_between(const CGAL_Point_3<R> &p,
                                   const CGAL_Point_3<R> &q,
                                   const CGAL_Point_3<R> &r)
{
 return (CGAL_collinear_between((const R::Point_3&)p,
                                (const R::Point_3&)q,
                                (const R::Point_3&)r));
}


template < class R >
inline CGAL_Orientation CGAL_orientation(const CGAL_Point_3<R> &p,
                                         const CGAL_Point_3<R> &q,
                                         const CGAL_Point_3<R> &r,
                                         const CGAL_Point_3<R> &s)
{
  return CGAL_orientation((const R::Point_3&)p, (const R::Point_3&)q,
                          (const R::Point_3&)r, (const R::Point_3&)s);
}

template <class R >
CGAL_Bounded_side CGAL_side_of_bounded_sphere(
                         const CGAL_Point_3<R> &p, const CGAL_Point_3<R> &q,
                         const CGAL_Point_3<R> &r, const CGAL_Point_3<R> &s,
                         const CGAL_Point_3<R> &test)
{
  return CGAL_side_of_bounded_sphere((const R::Point_3&)p,
                                     (const R::Point_3&)q,
                                     (const R::Point_3&)r,
                                     (const R::Point_3&)s,
                                     (const R::Point_3&)test);
}
@}



@D@<Header File@>

@O@<../include/CGAL/predicates_on_points_3.h@>==@{@-
@<CGAL notice@>
// Source: predicates_on_points_3.h
// Author: Andreas.Fabri@@sophia.inria.fr

#ifndef CGAL_PREDICATES_ON_POINTS_3_H
#define CGAL_PREDICATES_ON_POINTS_3_H

#include <CGAL/Point_3.h>

@<Lexicograpical Order of 3D Points@>

@<Alignement of 3D Points@>

@<3D Ordertype Interface Functions@>

#endif // CGAL_PREDICATES_ON_POINTS_3_H
@}

@! $Log: predicates_on_points_3.fw,v $
@! Revision 1.1  1996/03/13 15:32:23  fabri
@! Initial revision
@!
@! Revision 1.3  1995/10/19 18:01:10  fabri
@! *** empty log message ***
@!
@! Revision 1.2  1995/10/05 15:11:48  fabri
@! uses CGAL_zero for tests
@!
@! Revision 1.1  1995/09/18 13:22:38  fabri
@! Initial revision
@!
@! Revision 1.2  1995/08/21 14:29:16  fabri
@! *** empty log message ***
@!
@! Revision 1.1  1995/08/16 11:56:08  fabri
@! Initial revision
@!
