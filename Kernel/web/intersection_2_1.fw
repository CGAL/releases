

@B@<2D Bbox Line intersection@>

@O@<../include/CGAL/Line_2_Bbox_2_intersection.h@>==@{
#include <CGAL/Bbox_2_Line_2_intersection.h>
@}

@O@<../include/CGAL/Bbox_2_Line_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_BBOX_2_LINE_2_INTERSECTION_H
#define CGAL_BBOX_2_LINE_2_INTERSECTION_H

#include <CGAL/Bbox_2.h>
#include <CGAL/Line_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Bbox_2_Line_2_pair {
public:
  //    typedef CGAL_Cartesian<double> Rcart;
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Bbox_2_Line_2_pair() ;
    CGAL_Bbox_2_Line_2_pair(CGAL_Bbox_2 const *bbox,
                            CGAL_Line_2<R> const *line);
    ~CGAL_Bbox_2_Line_2_pair() {}

#ifndef CGAL_WORKAROUND_005
  Intersection_results intersection_type() const;

#else

  Intersection_results intersection_type() const
@<Bbox_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool intersection(CGAL_Point_2< CGAL_Cartesian<double> > &result) const;
    bool intersection(CGAL_Segment_2< CGAL_Cartesian<double> > &result) const;
protected:
    CGAL_Bbox_2 const *      _bbox;
    CGAL_Line_2< CGAL_Cartesian<double> > _line;
    bool                     _known;
    Intersection_results     _result;
    double                   _min, _max;
};

template <class R>
inline bool do_intersect(
    const CGAL_Bbox_2 &box,
    const CGAL_Line_2<R> &line)
{
    typedef CGAL_Bbox_2_Line_2_pair<R> pair_t;
    pair_t pair(&box, &line);
    return pair.intersection_type() == pair_t::NO;
}

@<Bbox_2_Line_2_pair implementation@>

template <class R>
class CGAL_Line_2_Bbox_2_pair: public CGAL_Bbox_2_Line_2_pair<R> {
public:
    CGAL_Line_2_Bbox_2_pair(
            CGAL_Line_2<R> const *line,
            CGAL_Bbox_2 const *bbox) :
                                CGAL_Bbox_2_Line_2_pair<R>(bbox, line) {}
};

template <class R>
inline bool do_intersect(
    const CGAL_Line_2<R> &line,
    const CGAL_Bbox_2 &box)
{
    typedef CGAL_Line_2_Bbox_2_pair<R> pair_t;
    pair_t pair(&line, &box);
    return pair.intersection_type() == pair_t::NO;
}

#endif
@}

@$@<Bbox_2_Line_2_pair implementation@>==@{

template <class R>
CGAL_Bbox_2_Line_2_pair<R>::CGAL_Bbox_2_Line_2_pair()
{
    _bbox = 0;
    _known = false;
}

template <class R>
CGAL_Bbox_2_Line_2_pair<R>::CGAL_Bbox_2_Line_2_pair(
    CGAL_Bbox_2 const *bbox, CGAL_Line_2<R> const *line)
{
    _bbox = bbox;
    _line = CGAL_Line_2< CGAL_Cartesian<double> >(CGAL_to_double(line->a()),
            CGAL_to_double(line->b()), CGAL_to_double(line->c()));
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Bbox_2_Line_2_pair<R>::Intersection_results
CGAL_Bbox_2_Line_2_pair<R>::intersection_type() const
@<Bbox_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Bbox_2_Line_2_pair<R>::intersection(
    CGAL_Segment_2< CGAL_Cartesian<double> > &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    CGAL_Point_2< CGAL_Cartesian<double> > p1(_line.point()
                + _min*_line.direction().vector());
    CGAL_Point_2< CGAL_Cartesian<double> > p2(_line.point()
                + _max*_line.direction().vector());
    seg = CGAL_Segment_2< CGAL_Cartesian<double> >(p1, p2);
    return true;
}

template <class R>
bool
CGAL_Bbox_2_Line_2_pair<R>::intersection(
    CGAL_Point_2< CGAL_Cartesian<double> > &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = (_line.point() + _min*_line.direction().vector());
    return true;
}
@}

The following body of the intersection type member function is used twice.
Once inline (which the g++ compiler wants because of a bug) and once outline.

@$@<Bbox_2_Line_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    // The non const this pointer is used to cast away const.
    CGAL_Bbox_2_Line_2_pair<R> *ncthis = (CGAL_Bbox_2_Line_2_pair<R> *) this;
    ncthis->_known = true;
    const CGAL_Point_2< CGAL_Cartesian<double> > &ref_point = _line.point();
    const CGAL_Vector_2< CGAL_Cartesian<double> > &dir =
                               _line.direction().vector();
    bool to_infinity = true;
// first on x value
    if (dir.x() == 0.0) {
        if (ref_point.x() < _bbox->xmin()) {
            ncthis->_result = NO;
            return _result;
        }
        if (ref_point.x() > _bbox->xmax()) {
            ncthis->_result = NO;
            return _result;
        }
    } else {
        double newmin, newmax;
        if (dir.x() > 0.0) {
            newmin = (_bbox->xmin()-ref_point.x())/dir.x();
            newmax = (_bbox->xmax()-ref_point.x())/dir.x();
        } else {
            newmin = (_bbox->xmax()-ref_point.x())/dir.x();
            newmax = (_bbox->xmin()-ref_point.x())/dir.x();
        }
        if (to_infinity) {
            ncthis->_min = newmin;
            ncthis->_max = newmax;
        } else {
            if (newmin > _min)
                ncthis->_min = newmin;
            if (newmax < _max)
                ncthis->_max = newmax;
            if (_max < _min) {
                ncthis->_result = NO;
                return _result;
            }
        }
        to_infinity = false;
    }
// now on y value
    if (dir.y() == 0.0) {
        if (ref_point.y() < _bbox->ymin()) {
            ncthis->_result = NO;
            return _result;
        }
        if (ref_point.y() > _bbox->ymax()) {
            ncthis->_result = NO;
            return _result;
        }
    } else {
        double newmin, newmax;
        if (dir.y() > 0.0) {
            newmin = (_bbox->ymin()-ref_point.y())/dir.y();
            newmax = (_bbox->ymax()-ref_point.y())/dir.y();
        } else {
            newmin = (_bbox->ymax()-ref_point.y())/dir.y();
            newmax = (_bbox->ymin()-ref_point.y())/dir.y();
        }
        if (to_infinity) {
            ncthis->_min = newmin;
            ncthis->_max = newmax;
        } else {
            if (newmin > _min)
                ncthis->_min = newmin;
            if (newmax < _max)
                ncthis->_max = newmax;
            if (_max < _min) {
                ncthis->_result = NO;
                return _result;
            }
        }
        to_infinity = false;
    }
    CGAL_kernel_assertion(!to_infinity);
    if (_max == _min) {
        ncthis->_result = POINT;
        return _result;
    }
    ncthis->_result = SEGMENT;
    return _result;
}
@}


@$@<Bbox2_2 cartesian double Line_2 intersection@>==@{
CGAL_Bbox_2_Line_2_pair< CGAL_Cartesian<double> >::CGAL_Bbox_2_Line_2_pair(
    CGAL_Bbox_2 const *bbox, CGAL_Line_2< CGAL_Cartesian<double> > const *line)
{
    _bbox = bbox;
    _line = *line;
    _known = false;
}
@}

@B@<2D Ray Bbox intersection@>


@O@<../include/CGAL/Bbox_2_Ray_2_intersection.h@>==@{
#include <CGAL/Ray_2_Bbox_2_intersection.h>
@}


@O@<../include/CGAL/Ray_2_Bbox_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_RAY_2_BBOX_2_INTERSECTION_H
#define CGAL_RAY_2_BBOX_2_INTERSECTION_H

#include <CGAL/Bbox_2.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Ray_2_Bbox_2_pair {
public:
    typedef CGAL_Cartesian<double> CGAL_Cartesian<double>;
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Ray_2_Bbox_2_pair() ;
    CGAL_Ray_2_Bbox_2_pair(CGAL_Ray_2<R> const *ray, CGAL_Bbox_2 const *box) ;

#ifndef CGAL_WORKAROUND_005
  Intersection_results intersection_type() const;

#else
  Intersection_results intersection_type() const
@<Ray_2_Bbox_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool               intersection(
                         CGAL_Point_2< CGAL_Cartesian<double> > &result) const;
    bool               intersection(
                        CGAL_Segment_2< CGAL_Cartesian<double> > &result) const;
protected:
    CGAL_Ray_2< CGAL_Cartesian<double> >        _ray;
    CGAL_Bbox_2 const *        _box;
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2< CGAL_Cartesian<double> >      _ref_point;
    CGAL_Vector_2< CGAL_Cartesian<double> >     _dir;
    double                     _min,
                               _max;
};

template <class R>
inline bool do_intersect(
    const CGAL_Ray_2<R> &ray,
    const CGAL_Bbox_2 &box)
{
    typedef CGAL_Ray_2_Bbox_2_pair<R> pair_t;
    pair_t pair(&ray, &box);
    return pair.intersection_type() == pair_t::NO;
}

@<Ray_2_Bbox_2_pair implementation@>

template <class R>
class CGAL_Bbox_2_Ray_2_pair: public CGAL_Ray_2_Bbox_2_pair<R> {
public:
    CGAL_Bbox_2_Ray_2_pair() {}
    CGAL_Bbox_2_Ray_2_pair(CGAL_Bbox_2 const *box, CGAL_Ray_2<R> const *ray)
                :CGAL_Ray_2_Bbox_2_pair<R> (ray, box){}
};

template <class R>
inline bool do_intersect(
    const CGAL_Bbox_2 &box,
    const CGAL_Ray_2<R> &ray)
{
    typedef CGAL_Bbox_2_Ray_2_pair<R> pair_t;
    pair_t pair(&box, &ray);
    return pair.intersection_type() == pair_t::NO;
}


#endif
@}


@$@<Ray_2_Bbox_2_pair implementation@>==@{

template <class R>
CGAL_Ray_2_Bbox_2_pair<R>::CGAL_Ray_2_Bbox_2_pair()
{
    _known = false;
    _box = 0;
}

template <class R>
CGAL_Ray_2_Bbox_2_pair<R>::
CGAL_Ray_2_Bbox_2_pair(CGAL_Ray_2<R> const *ray, CGAL_Bbox_2 const *box)
{
    _known = false;
    _box = box;
// convert the ray to a ray parametrised by doubles.
    CGAL_Point_2<R> const &start(ray->start());
    CGAL_Vector_2<R> const &dir(ray->direction().vector());
    _ref_point = CGAL_Point_2< CGAL_Cartesian<double> >
                ( CGAL_to_double(start.x()), CGAL_to_double(start.y()));
//    double dx = CGAL_to_double(dir.hx())/CGAL_to_double(dir.hw());
//    double dy = CGAL_to_double(dir.hy())/CGAL_to_double(dir.hw());
    double dx = CGAL_to_double(dir.x());
    double dy = CGAL_to_double(dir.y());
    _dir = CGAL_Vector_2< CGAL_Cartesian<double> > (dx, dy);
    _min = 0;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Ray_2_Bbox_2_pair<R>::Intersection_results
CGAL_Ray_2_Bbox_2_pair<R>::intersection_type() const
@<Ray_2_Bbox_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool CGAL_Ray_2_Bbox_2_pair<R>::
intersection(CGAL_Segment_2< CGAL_Cartesian<double> > &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    CGAL_Point_2< CGAL_Cartesian<double> > p1(_ref_point + _min*_dir);
    CGAL_Point_2< CGAL_Cartesian<double> > p2(_ref_point + _max*_dir);
    seg = CGAL_Segment_2< CGAL_Cartesian<double> >(p1, p2);
    return true;
}

template <class R>
bool CGAL_Ray_2_Bbox_2_pair<R>::
intersection(CGAL_Point_2< CGAL_Cartesian<double> > &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = CGAL_Point_2< CGAL_Cartesian<double> >(_ref_point + _min*_dir);
    return true;
}
@}

@$@<Ray_2_Bbox_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    CGAL_Ray_2_Bbox_2_pair<R> *ncthis = (CGAL_Ray_2_Bbox_2_pair<R> *) this;
    ncthis->_known = true;
    bool to_infinity = true;
// first on x value
    if (_dir.x() == 0.0) {
        if (_ref_point.x() < _box->xmin()) {
            ncthis->_result = NO;
            return _result;
        }
        if (_ref_point.x() > _box->xmax()) {
            ncthis->_result = NO;
            return _result;
        }
    } else {
        double newmin, newmax;
        if (_dir.x() > 0.0) {
            newmin = (_box->xmin()-_ref_point.x())/_dir.x();
            newmax = (_box->xmax()-_ref_point.x())/_dir.x();
        } else {
            newmin = (_box->xmax()-_ref_point.x())/_dir.x();
            newmax = (_box->xmin()-_ref_point.x())/_dir.x();
        }
        if (newmin > _min)
            ncthis->_min = newmin;
        if (to_infinity) {
            ncthis->_max = newmax;
        } else {
            if (newmax < _max)
                ncthis->_max = newmax;
        }
        if (_max < _min){
            ncthis->_result = NO;
            return _result;
        }
        to_infinity = false;
    }
// now on y value
    if (_dir.y() == 0.0) {
        if (_ref_point.y() < _box->ymin()) {
            ncthis->_result = NO;
            return _result;
        }
        if (_ref_point.y() > _box->ymax()) {
            ncthis->_result = NO;
            return _result;
        }
    } else {
        double newmin, newmax;
        if (_dir.y() > 0.0) {
            newmin = (_box->ymin()-_ref_point.y())/_dir.y();
            newmax = (_box->ymax()-_ref_point.y())/_dir.y();
        } else {
            newmin = (_box->ymax()-_ref_point.y())/_dir.y();
            newmax = (_box->ymin()-_ref_point.y())/_dir.y();
        }
        if (newmin > _min)
            ncthis->_min = newmin;
        if (to_infinity) {
            ncthis->_max = newmax;
        } else {
            if (newmax < _max)
                ncthis->_max = newmax;
        }
        if (_max < _min) {
            ncthis->_result = NO;
            return _result;
        }
        to_infinity = false;
    }
    CGAL_kernel_assertion(!to_infinity);
    if (_max == _min) {
        ncthis->_result = POINT;
        return _result;
    }
    ncthis->_result = SEGMENT;
    return _result;
}
@}

@$@<Bbox2_2 cartesian double Ray_2 intersection@>==@{
CGAL_Ray_2_Bbox_2_pair< CGAL_Cartesian<double> >::
CGAL_Ray_2_Bbox_2_pair(
            CGAL_Ray_2< CGAL_Cartesian<double> > const *ray,
            CGAL_Bbox_2 const *box)
{
    _known = false;
    _box = box;
    _ref_point = ray->start();
    _dir = ray->direction().vector();
    _min = 0;
}
@}


@O@<../include/CGAL/Line_2_Line_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_LINE_2_LINE_2_INTERSECTION_H
#define CGAL_LINE_2_LINE_2_INTERSECTION_H

#include <CGAL/Line_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Line_2_Line_2_pair {
public:
    enum Intersection_results {NO, POINT, LINE};
    CGAL_Line_2_Line_2_pair() ;
    CGAL_Line_2_Line_2_pair(CGAL_Line_2<R> const *line1,
                            CGAL_Line_2<R> const *line2);
    ~CGAL_Line_2_Line_2_pair() {}

#ifndef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const;

#else
    Intersection_results intersection_type() const
@<Line_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Line_2<R> &result) const;
protected:
    CGAL_Line_2<R> const*   _line1;
    CGAL_Line_2<R> const *  _line2;
    bool                    _known;
    Intersection_results    _result;
    CGAL_Point_2<R>         _intersection_point;
};

@<do_intersect macro@>@(Line_2@,Line_2@)

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line1, const CGAL_Line_2<R> &line2)
{
    typedef CGAL_Line_2_Line_2_pair<R> is_t;
    is_t linepair(&line1, &line2);
    switch (linepair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        linepair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::LINE:
        return CGAL_Object(new CGAL_Wrapper< CGAL_Line_2<R> >(line1));
    }
}

@<Line_2_Line_2_pair implementation@>

#endif
@}





Momentarily, we use a help function to construct the intersection point and
check whether this point is valid.
Because the template mechanism of the compilers do not yet comply to the
(proposed) standard, we use the following implementation.
Note that @{R::FT@} should actually be @{typename R::FT@}.

@$@<Line_2_Line_2_pair implementation@>+=@{

template <class R, class POINT, class RT>
bool construct_if_finite(POINT &pt, RT x, RT y, RT w, R &)
{
    typedef R::FT FT;
    CGAL_kernel_precondition(CGAL_is_finite(x)
                             && CGAL_is_finite(y)
                             && w != RT(0));

    if (!CGAL_is_finite(FT(x)/FT(w)) || !CGAL_is_finite(FT(y)/FT(w)))
        return false;
    pt = POINT(x, y, w);
    return true;
}
@}

A not working, but conformant implementation is the following.
Note that this function should be called with an explicit template argument
specified: @{construct_if_finite<R>(pt, x, y, w);@}.

@$@<temporarily not used@>@Z+=@{
template <class R>
bool construct_if_finite(CGAL_Point_2<R> &pt,
    typename R::RT x, typename R::RT y, typename R::RT w)
{
    typedef  R::FT FT;
    CGAL_kernel_precondition(CGAL_is_finite(x)
            && CGAL_is_finite(y) && w != (R::RT) 0);
    if (!CGAL_is_finite(FT(x)/FT(w)) || !CGAL_is_finite(FT(y)/FT(w)))
        return false;
    pt = CGAL_Point_2<R>(x, y, w);
    return true;
}
@}

@$@<Line_2_Line_2_pair implementation@>+=@{@-

template <class R>
CGAL_Line_2_Line_2_pair<R>::CGAL_Line_2_Line_2_pair()
{
    _line1 = 0;
    _line2 = 0;
    _known = false;
}

template <class R>
CGAL_Line_2_Line_2_pair<R>::CGAL_Line_2_Line_2_pair(
    CGAL_Line_2<R> const *line1, CGAL_Line_2<R> const *line2)
{
    _line1 = line1;
    _line2 = line2;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Line_2_Line_2_pair<R>::Intersection_results
CGAL_Line_2_Line_2_pair<R>::intersection_type() const
@<Line_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Line_2_Line_2_pair<R>::intersection(CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Line_2_Line_2_pair<R>::intersection(CGAL_Line_2<R> &l) const
{
    if (!_known)
        intersection_type();
    if (_result != LINE)
        return false;
    l = *_line1;
    return true;
}
@}

@$@<Line_2_Line_2_pair intersection_type body@>@M==@{@-
{
    typedef R::RT RT;
    if (_known)
        return _result;
    RT nom1, nom2, denom;
    // The non const this pointer is used to cast away const.
    CGAL_Line_2_Line_2_pair<R> *ncthis = (CGAL_Line_2_Line_2_pair<R> *) this;
    ncthis->_known = true;
    denom = _line1->a()*_line2->b() - _line2->a()*_line1->b();
    if (denom == RT(0)) {
        if (RT(0) == (_line1->a()*_line2->c() - _line2->a()*_line1->c()) &&
            RT(0) == (_line1->b()*_line2->c() - _line2->b()*_line1->c()))
            ncthis->_result = LINE;
        else
            ncthis->_result = NO;
        return _result;
    }
    nom1 = (_line1->b()*_line2->c() - _line2->b()*_line1->c());
    if (!CGAL_is_finite(nom1)) {
        ncthis->_result = NO;
        return _result;
    }
    nom2 = (_line2->a()*_line1->c() - _line1->a()*_line2->c());
    if (!CGAL_is_finite(nom2)) {
        ncthis->_result = NO;
        return _result;
    }
    R dummyR;
    if (!construct_if_finite(ncthis->_intersection_point,
                            nom1, nom2, denom, dummyR)){
        ncthis->_result = NO;
        return _result;
    }
    ncthis->_result = POINT;
    return _result;
}
@}

@B@<2D Segment Line intersection@>

@O@<../include/CGAL/Line_2_Segment_2_intersection.h@>==@{
#include <CGAL/Segment_2_Line_2_intersection.h>
@}

@O@<../include/CGAL/Segment_2_Line_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_SEGMENT_2_LINE_2_INTERSECTION_H
#define CGAL_SEGMENT_2_LINE_2_INTERSECTION_H

#include <CGAL/Line_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Segment_2_Line_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Segment_2_Line_2_pair() ;
    CGAL_Segment_2_Line_2_pair(CGAL_Segment_2<R> const *seg,
                            CGAL_Line_2<R> const *line);
    ~CGAL_Segment_2_Line_2_pair() {}

#ifndef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const;
#else
    Intersection_results intersection_type() const
@<Segment_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Segment_2<R> const*_seg;
    CGAL_Line_2<R> const *  _line;
    bool                    _known;
    Intersection_results     _result;
    CGAL_Point_2<R>         _intersection_point;
};

@<do_intersect macro@>@(Segment_2@,Line_2@)

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Segment_2<R> &seg, const CGAL_Line_2<R> &line)
{
    typedef CGAL_Segment_2_Line_2_pair<R> is_t;
    is_t ispair(&seg, &line);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT:
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(seg));
    }
}

template <class R>
class CGAL_Line_2_Segment_2_pair: public CGAL_Segment_2_Line_2_pair<R> {
public:
    CGAL_Line_2_Segment_2_pair(
            CGAL_Line_2<R> const *line,
            CGAL_Segment_2<R> const *seg) :
                                CGAL_Segment_2_Line_2_pair<R>(seg, line) {}
};

@<do_intersect macro@>@(Line_2@,Segment_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Segment_2<R> &seg)
{
    return CGAL_intersection(seg, line);
}

@<Segment_2_Line_2_pair implementation@>

#endif
@}

@$@<Segment_2_Line_2_pair implementation@>==@{
#include <CGAL/Line_2_Line_2_intersection.h>

template <class R>
CGAL_Segment_2_Line_2_pair<R>::CGAL_Segment_2_Line_2_pair()
{
    _seg = 0;
    _line = 0;
    _known = false;
}

template <class R>
CGAL_Segment_2_Line_2_pair<R>::CGAL_Segment_2_Line_2_pair(
    CGAL_Segment_2<R> const *seg, CGAL_Line_2<R> const *line)
{
    _seg = seg;
    _line = line;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Segment_2_Line_2_pair<R>::Intersection_results
CGAL_Segment_2_Line_2_pair<R>::intersection_type() const
@<Segment_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Segment_2_Line_2_pair<R>::intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Segment_2_Line_2_pair<R>::intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = *_seg;
    return true;
}
@}

@$@<Segment_2_Line_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    // The non const this pointer is used to cast away const.
    CGAL_Segment_2_Line_2_pair<R> *ncthis =
            (CGAL_Segment_2_Line_2_pair<R> *) this;
    ncthis->_known = true;
    const CGAL_Line_2<R> &l1 = _seg->supporting_line();
    CGAL_Line_2_Line_2_pair<R> linepair(&l1, _line);
    switch ( linepair.intersection_type()) {
    case CGAL_Line_2_Line_2_pair<R>::NO:
        ncthis->_result = NO;
        break;
    case CGAL_Line_2_Line_2_pair<R>::POINT:
        linepair.intersection(ncthis->_intersection_point);
        ncthis->_result = (_seg->collinear_has_on(_intersection_point) )
                ? POINT : NO;
        break;
    case CGAL_Line_2_Line_2_pair<R>::LINE:
        ncthis->_result = SEGMENT;
        break;
    }
    return _result;
}
@}

@B@<2D Segment Segment intersection@>

@O@<../include/CGAL/Segment_2_Segment_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_SEGMENT_2_SEGMENT_2_INTERSECTION_H
#define CGAL_SEGMENT_2_SEGMENT_2_INTERSECTION_H

#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Segment_2_Segment_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Segment_2_Segment_2_pair() ;
    CGAL_Segment_2_Segment_2_pair(CGAL_Segment_2<R> const *seg1,
                            CGAL_Segment_2<R> const *seg2);
    ~CGAL_Segment_2_Segment_2_pair() {}

#ifndef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const;
#else
    Intersection_results intersection_type() const
@<Segment_2_Segment_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Segment_2<R> const*   _seg1;
    CGAL_Segment_2<R> const *  _seg2;
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _intersection_point, _other_point;
};

@<do_intersect macro@>@(Segment_2@,Segment_2@)

@<Segment_2_Segment_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Segment_2<R> &seg1, const CGAL_Segment_2<R>&seg2)
{
    typedef CGAL_Segment_2_Segment_2_pair<R> is_t;
    is_t ispair(&seg1, &seg2);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

#endif
@}

@$@<Segment_2_Segment_2_pair implementation@>==@{
#include <CGAL/Line_2.h>
#include <CGAL/Line_2_Line_2_intersection.h>

template <class R>
CGAL_Segment_2_Segment_2_pair<R>::CGAL_Segment_2_Segment_2_pair()
{
    _seg1 = 0;
    _seg2 = 0;
    _known = false;
}

template <class R>
CGAL_Segment_2_Segment_2_pair<R>::CGAL_Segment_2_Segment_2_pair(
    CGAL_Segment_2<R> const *seg1, CGAL_Segment_2<R> const *seg2)
{
    _seg1 = seg1;
    _seg2 = seg2;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Segment_2_Segment_2_pair<R>::Intersection_results
CGAL_Segment_2_Segment_2_pair<R>::intersection_type() const
@<Segment_2_Segment_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Segment_2_Segment_2_pair<R>::intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Segment_2_Segment_2_pair<R>::intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}

@}

@$@<Segment_2_Segment_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    // The non const this pointer is used to cast away const.
    CGAL_Segment_2_Segment_2_pair<R> *ncthis =
                (CGAL_Segment_2_Segment_2_pair<R> *) this;
    ncthis->_known = true;
    if (!CGAL_do_overlap(_seg1->bbox(), _seg2->bbox())) {
        ncthis->_result = NO;
        return _result;
    }
    CGAL_Line_2<R> const &l1 = _seg1->supporting_line();
    CGAL_Line_2<R> const &l2 = _seg2->supporting_line();
    CGAL_Line_2_Line_2_pair<R> linepair(&l1, &l2);
    switch ( linepair.intersection_type()) {
    case CGAL_Line_2_Line_2_pair<R>::NO:
        ncthis->_result = NO;
        break;
    case CGAL_Line_2_Line_2_pair<R>::POINT:
        linepair.intersection(ncthis->_intersection_point);
        ncthis->_result = (_seg1->collinear_has_on(_intersection_point)
            && _seg2->collinear_has_on(_intersection_point)) ? POINT : NO;
        break;
    case CGAL_Line_2_Line_2_pair<R>::LINE:
        @<Segment_2_Segment_2_pair collinear case@>
    }
    return _result;
}
@}

@C@<Collinear Case@>

We decide on a main direction (x or y) in which the segment changes
the fastest.

@$@<Segment_2_Segment_2_pair collinear case@>==@{@-
{
typedef R::RT RT;
CGAL_Point_2<R> const &start1 = _seg1->start();
CGAL_Point_2<R> const &end1   = _seg1->end();
CGAL_Point_2<R> const &start2 = _seg2->start();
CGAL_Point_2<R> const &end2   = _seg2->end();
CGAL_Vector_2<R> diff1 = end1-start1;
CGAL_Point_2<R> const *minpt;
CGAL_Point_2<R> const *maxpt;
if (CGAL_abs(diff1.x()) > CGAL_abs(diff1.y())) {
    @<Segment_2_Segment_2_pair collinear case 2@>@(x@)
} else {
    @<Segment_2_Segment_2_pair collinear case 2@>@(y@)
}
} @-
@}

The first parameter in the following macro should either be x or y.
The macro sorts the four endpoints of the two segments according to this
parameter. Then a check is made to see if there is an overlapping interval.

@$@<Segment_2_Segment_2_pair collinear case 2@>@(@1@)@M==@{@-
if (start1.@1() < end1.@1()) {
    minpt = &start1;
    maxpt = &end1;
} else {
    minpt = &end1;
    maxpt = &start1;
}
if (start2.@1() < end2.@1()) {
    if (start2.@1() > minpt->@1()) {
        minpt = &start2;
    }
    if (end2.@1() < maxpt->@1()) {
        maxpt = &end2;
    }
} else {
    if (end2.@1() > minpt->@1()) {
        minpt = &end2;
    }
    if (start2.@1() < maxpt->@1()) {
        maxpt = &start2;
    }
}
if (maxpt->@1() < minpt->@1()) {
    ncthis->_result = NO;
    return _result;
}
if (maxpt->@1() == minpt->@1()) {
    ncthis->_intersection_point = *minpt;
    ncthis->_result = POINT;
    return _result;
}
ncthis->_intersection_point = *minpt;
ncthis->_other_point = *maxpt;
ncthis->_result = SEGMENT;
return _result; @-
@}

@B@<2D Ray Line intersection@>

@O@<../include/CGAL/Line_2_Ray_2_intersection.h@>==@{
#include <CGAL/Ray_2_Line_2_intersection.h>
@}

@O@<../include/CGAL/Ray_2_Line_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_RAY_2_LINE_2_INTERSECTION_H
#define CGAL_RAY_2_LINE_2_INTERSECTION_H

#include <CGAL/Line_2.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Ray_2_Line_2_pair {
public:
    enum Intersection_results {NO, POINT, RAY};
    CGAL_Ray_2_Line_2_pair() ;
    CGAL_Ray_2_Line_2_pair(CGAL_Ray_2<R> const *ray,
                            CGAL_Line_2<R> const *line);
    ~CGAL_Ray_2_Line_2_pair() {}

#ifndef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const;
#else
    Intersection_results intersection_type() const
@<Ray_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Ray_2<R> &result) const;
protected:
    CGAL_Ray_2<R> const *   _ray;
    CGAL_Line_2<R> const *  _line;
    bool                    _known;
    Intersection_results    _result;
    CGAL_Point_2<R>         _intersection_point;
};

@<do_intersect macro@>@(Ray_2@,Line_2@)

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Ray_2<R> &ray, const CGAL_Line_2<R>&line)
{
    typedef CGAL_Ray_2_Line_2_pair<R> is_t;
    is_t ispair(&ray, &line);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::RAY: {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Ray_2<R> >(ray));
    }
    }
}

template <class R>
class CGAL_Line_2_Ray_2_pair: public CGAL_Ray_2_Line_2_pair<R> {
public:
    CGAL_Line_2_Ray_2_pair(
            CGAL_Line_2<R> const *line,
            CGAL_Ray_2<R> const *ray) :
                                CGAL_Ray_2_Line_2_pair<R>(ray, line) {}
};

@<do_intersect macro@>@(Line_2@,Ray_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Ray_2<R> &ray)
{
    return CGAL_intersection(ray, line);
}

@<Ray_2_Line_2_pair implementation@>

#endif
@}

@$@<Ray_2_Line_2_pair implementation@>==@{
#include <CGAL/Line_2_Line_2_intersection.h>

template <class R>
CGAL_Ray_2_Line_2_pair<R>::CGAL_Ray_2_Line_2_pair()
{
    _ray = 0;
    _line = 0;
    _known = false;
}

template <class R>
CGAL_Ray_2_Line_2_pair<R>::CGAL_Ray_2_Line_2_pair(
    CGAL_Ray_2<R> const *ray, CGAL_Line_2<R> const *line)
{
    _ray = ray;
    _line = line;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Ray_2_Line_2_pair<R>::Intersection_results
CGAL_Ray_2_Line_2_pair<R>::intersection_type() const
@<Ray_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Ray_2_Line_2_pair<R>::intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Ray_2_Line_2_pair<R>::intersection(CGAL_Ray_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != RAY)
        return false;
    result = *_ray;
    return true;
}
@}

@$@<Ray_2_Line_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    // The non const this pointer is used to cast away const.
    CGAL_Ray_2_Line_2_pair<R> *ncthis =
                (CGAL_Ray_2_Line_2_pair<R> *) this;
    ncthis->_known = true;
    const CGAL_Line_2<R> &l1 = _ray->supporting_line();
    CGAL_Line_2_Line_2_pair<R> linepair(&l1, _line);
    switch ( linepair.intersection_type()) {
    case CGAL_Line_2_Line_2_pair<R>::NO:
        ncthis->_result = NO;
        break;
    case CGAL_Line_2_Line_2_pair<R>::POINT:
        linepair.intersection(ncthis->_intersection_point);
        ncthis->_result = (_ray->collinear_has_on(_intersection_point) ) ?
                POINT : NO;
        break;
    case CGAL_Line_2_Line_2_pair<R>::LINE:
        ncthis->_result = RAY;
        break;
    }
    return _result;
}
@}

@B@<2D Ray Segment intersection@>

@O@<../include/CGAL/Segment_2_Ray_2_intersection.h@>==@{
#include <CGAL/Ray_2_Segment_2_intersection.h>
@}

@O@<../include/CGAL/Ray_2_Segment_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_RAY_2_SEGMENT_2_INTERSECTION_H
#define CGAL_RAY_2_SEGMENT_2_INTERSECTION_H

#include <CGAL/Ray_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Ray_2_Segment_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Ray_2_Segment_2_pair() ;
    CGAL_Ray_2_Segment_2_pair(CGAL_Ray_2<R> const *ray,
                            CGAL_Segment_2<R> const *line);
    ~CGAL_Ray_2_Segment_2_pair() {}

#ifndef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const;
#else
    Intersection_results intersection_type() const
@<Ray_2_Segment_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Ray_2<R> const *   _ray;
    CGAL_Segment_2<R> const *  _seg;
    bool                    _known;
    Intersection_results    _result;
    CGAL_Point_2<R>         _intersection_point, _other_point;
};

@<do_intersect macro@>@(Ray_2@,Segment_2@)

@<Ray_2_Segment_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Ray_2<R> &ray, const CGAL_Segment_2<R>&seg)
{
    typedef CGAL_Ray_2_Segment_2_pair<R> is_t;
    is_t ispair(&ray, &seg);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Segment_2_Ray_2_pair: public CGAL_Ray_2_Segment_2_pair<R> {
public:
    CGAL_Segment_2_Ray_2_pair(
            CGAL_Segment_2<R> const *seg,
            CGAL_Ray_2<R> const *ray) :
                                CGAL_Ray_2_Segment_2_pair<R>(ray, seg) {}
};

@<do_intersect macro@>@(Segment_2@,Ray_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Segment_2<R> &seg, const CGAL_Ray_2<R> &ray)
{
    return CGAL_intersection(ray, seg);
}

#endif
@}

@$@<Ray_2_Segment_2_pair implementation@>==@{
#include <CGAL/Line_2.h>
#include <CGAL/Line_2_Line_2_intersection.h>

template <class R>
CGAL_Ray_2_Segment_2_pair<R>::CGAL_Ray_2_Segment_2_pair()
{
    _ray = 0;
    _seg = 0;
    _known = false;
}

template <class R>
CGAL_Ray_2_Segment_2_pair<R>::CGAL_Ray_2_Segment_2_pair(
    CGAL_Ray_2<R> const *ray, CGAL_Segment_2<R> const *seg)
{
    _ray = ray;
    _seg = seg;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Ray_2_Segment_2_pair<R>::Intersection_results
CGAL_Ray_2_Segment_2_pair<R>::intersection_type() const
@<Ray_2_Segment_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Ray_2_Segment_2_pair<R>::intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Ray_2_Segment_2_pair<R>::intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Ray_2_Segment_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    // The non const this pointer is used to cast away const.
    CGAL_Ray_2_Segment_2_pair<R> *ncthis =
                (CGAL_Ray_2_Segment_2_pair<R> *) this;
    ncthis->_known = true;
//    if (!CGAL_do_overlap(_ray->bbox(), _seg->bbox()))
//        return NO;
    const CGAL_Line_2<R> &l1 = _ray->supporting_line();
    const CGAL_Line_2<R> &l2 = _seg->supporting_line();
    CGAL_Line_2_Line_2_pair<R> linepair(&l1, &l2);
    switch ( linepair.intersection_type()) {
    case CGAL_Line_2_Line_2_pair<R>::NO:
        ncthis->_result = NO;
        return _result;
    case CGAL_Line_2_Line_2_pair<R>::POINT:
        linepair.intersection(ncthis->_intersection_point);
        ncthis->_result = (_ray->collinear_has_on(_intersection_point)
                && _seg->collinear_has_on(_intersection_point) )
            ? POINT :  NO;
        return _result;
    case CGAL_Line_2_Line_2_pair<R>::LINE: {
        @<Ray_2_Segment_2_pair collinear case@>
        }
    default:
        CGAL_kernel_assertion(false); // should not be reached:
        return _result;
    }

}
@}

@C@<Collinear Case@>

We decide on a main direction (x or y) in which the segment changes
the fastest.

@$@<Ray_2_Segment_2_pair collinear case@>==@{@-
typedef R::RT RT;
const CGAL_Point_2<R> &start1 = _seg->start();
const CGAL_Point_2<R> &end1 = _seg->end();
const CGAL_Point_2<R> &start2 = _ray->start();
const CGAL_Point_2<R> *minpt,  *maxpt;
CGAL_Vector_2<R> diff1 = end1-start1;
if (CGAL_abs(diff1.x()) > CGAL_abs(diff1.y())) {
    @<Ray_2_Segment_2_pair collinear case 2@>@(x@)
} else {
    @<Ray_2_Segment_2_pair collinear case 2@>@(y@)
} @-
@}

The first parameter in the following macro should either be x or y.
The macro sorts the endpoints of the segment according to this
parameter. Then a check is made to see if there is an overlapping interval.

@$@<Ray_2_Segment_2_pair collinear case 2@>@(@1@)@M==@{@-
if (start1.@1() < end1.@1()) {
    minpt = &start1;
    maxpt = &end1;
} else {
    minpt = &end1;
    maxpt = &start1;
}
if (_ray->direction().vector().@1() > R::FT(0)) {
    if (maxpt->@1() < start2.@1()) {
        ncthis->_result = NO;
        return _result;
    }
    if (maxpt->@1() == start2.@1()) {
        ncthis->_intersection_point = *maxpt;
        ncthis->_result = POINT;
        return _result;
    }
    if (minpt->@1() < start2.@1()) {
        ncthis->_intersection_point = start2;
        ncthis->_other_point = *maxpt;
    } else {
        ncthis->_intersection_point = _seg->start();
        ncthis->_other_point = _seg->end();
    }
    ncthis->_result = SEGMENT;
    return _result;
} else {
    if (minpt->@1() > start2.@1()) {
        ncthis->_result = NO;
        return _result;
    }
    if (minpt->@1() == start2.@1()) {
        ncthis->_intersection_point = *minpt;
        ncthis->_result = POINT;
        return _result;
    }
    if (maxpt->@1() > start2.@1()) {
        ncthis->_intersection_point = start2;
        ncthis->_other_point = *maxpt;
    } else {
        ncthis->_intersection_point = _seg->start();
        ncthis->_other_point = _seg->end();
    }
    ncthis->_result = SEGMENT;
    return _result;
}@-
@}


@B@<2D Ray Ray intersection@>


@O@<../include/CGAL/Ray_2_Ray_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_Ray_2_Ray_2_pair_H
#define CGAL_Ray_2_Ray_2_pair_H

#include <CGAL/Ray_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Ray_2_Ray_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT, RAY};
    CGAL_Ray_2_Ray_2_pair() ;
    CGAL_Ray_2_Ray_2_pair(CGAL_Ray_2<R> const *ray1,
                            CGAL_Ray_2<R> const *ray2);
    ~CGAL_Ray_2_Ray_2_pair() {}

#ifndef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const;
#else
    Intersection_results intersection_type() const
@<Ray_2_Ray_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
    bool                intersection(CGAL_Ray_2<R> &result) const;
protected:
    CGAL_Ray_2<R> const*    _ray1;
    CGAL_Ray_2<R> const *   _ray2;
    bool                    _known;
    Intersection_results    _result;
    CGAL_Point_2<R>         _intersection_point, _other_point;
};

@<do_intersect macro@>@(Ray_2@,Ray_2@)

@<Ray_2_Ray_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Ray_2<R> &ray1, const CGAL_Ray_2<R>&ray2)
{
    typedef CGAL_Ray_2_Ray_2_pair<R> is_t;
    is_t ispair(&ray1, &ray2);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    case is_t::RAY: {
        CGAL_Segment_2<R> iray;
        ispair.intersection(iray);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iray));
    }
    }
}

#endif
@}

@$@<Ray_2_Ray_2_pair implementation@>==@{

#include <CGAL/Line_2.h>
#include <CGAL/Line_2_Line_2_intersection.h>

template <class R>
CGAL_Ray_2_Ray_2_pair<R>::CGAL_Ray_2_Ray_2_pair()
{
    _ray1 = 0;
    _ray2 = 0;
    _known = false;
}

template <class R>
CGAL_Ray_2_Ray_2_pair<R>::CGAL_Ray_2_Ray_2_pair(
    CGAL_Ray_2<R> const *ray1, CGAL_Ray_2<R> const *ray2)
{
    _ray1 = ray1;
    _ray2 = ray2;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Ray_2_Ray_2_pair<R>::Intersection_results
CGAL_Ray_2_Ray_2_pair<R>::intersection_type() const
@<Ray_2_Ray_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Ray_2_Ray_2_pair<R>::intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Ray_2_Ray_2_pair<R>::intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != RAY)
        return false;
    result = CGAL_Segment_2<R>(_ray1->start(), _ray2->start());
    return true;
}

template <class R>
bool
CGAL_Ray_2_Ray_2_pair<R>::intersection(CGAL_Ray_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != RAY)
        return false;
    result = CGAL_Ray_2<R>(_intersection_point, _ray1->direction());
    return true;
}

@}

@$@<Ray_2_Ray_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    // The non const this pointer is used to cast away const.
    CGAL_Ray_2_Ray_2_pair<R> *ncthis =
                (CGAL_Ray_2_Ray_2_pair<R> *) this;
    ncthis->_known = true;
//    if (!CGAL_do_overlap(_ray1->bbox(), _ray2->bbox()))
//        return NO;
    const CGAL_Line_2<R> &l1 = _ray1->supporting_line();
    const CGAL_Line_2<R> &l2 = _ray2->supporting_line();
    CGAL_Line_2_Line_2_pair<R> linepair(&l1, &l2);
    switch ( linepair.intersection_type()) {
    case CGAL_Line_2_Line_2_pair<R>::NO:
        ncthis->_result = NO;
        return _result;
    case CGAL_Line_2_Line_2_pair<R>::POINT:
        linepair.intersection(ncthis->_intersection_point);
        ncthis->_result = (_ray1->collinear_has_on(_intersection_point)
                && _ray2->collinear_has_on(_intersection_point) )
            ? POINT :  NO;
        return _result;
    case CGAL_Line_2_Line_2_pair<R>::LINE:
        @<Ray_2_Ray_2_pair collinear case@>
    default:
        CGAL_kernel_assertion(false); // should not be reached:
        return _result;
    }
}
@}

@C@<Collinear Case@>

We decide on a main direction (x or y) in which the segment changes
the fastest.

@$@<Ray_2_Ray_2_pair collinear case@>==@{@-
{
typedef R::RT RT;
const CGAL_Vector_2<R> &dir1 = _ray1->direction().vector();
const CGAL_Vector_2<R> &dir2 = _ray2->direction().vector();
if (CGAL_abs(dir1.x()) > CGAL_abs(dir1.y())) {
    @<Ray_2_Ray_2_pair collinear case 2@>@(x@)
} else {
    @<Ray_2_Ray_2_pair collinear case 2@>@(y@)
}
} @-
@}

The first parameter in the following macro should either be x or y.
The macro sorts the four endpoints of the two segments according to this
parameter. Then a check is made to see if there is an overlapping interval.

@$@<Ray_2_Ray_2_pair collinear case 2@>@(@1@)@M==@{@-
if (dir1.@1() > 0) {
    if (dir2.@1() > 0) {
        ncthis->_intersection_point =
                (_ray1->start().@1() < _ray2->start().@1())
                ? _ray2->start() : _ray1->start();
        ncthis->_result = RAY;
        return _result;
    } else {
        if (_ray1->start().@1() > _ray2->start().@1()) {
            ncthis->_result = NO;
            return _result;
        }
        if (_ray1->start().@1() == _ray2->start().@1()) {
            ncthis->_intersection_point = _ray1->start();
            ncthis->_result = POINT;
            return _result;
        }
        ncthis->_result = SEGMENT;
        return _result;
    }
} else {
    if (dir2.@1() < 0) {
        ncthis->_intersection_point =
                (_ray1->start().@1() > _ray2->start().@1())
                ? _ray2->start() : _ray1->start();
        ncthis->_result = RAY;
        return _result;
    } else {
        if (_ray1->start().@1() < _ray2->start().@1()) {
            ncthis->_result = NO;
            return _result;
        }
        if (_ray1->start().@1() == _ray2->start().@1()) {
            ncthis->_intersection_point = _ray1->start();
            ncthis->_result = POINT;
            return _result;
        }
        ncthis->_result = SEGMENT;
        return _result;
    }
}
@}

@B@<2D Point Line intersection@>

@O@<../include/CGAL/Line_2_Point_2_intersection.h@>==@{
#include <CGAL/Point_2_Line_2_intersection.h>
@}

@O@<../include/CGAL/Point_2_Line_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_POINT_2_LINE_2_INTERSECTION_H
#define CGAL_POINT_2_LINE_2_INTERSECTION_H

#include <CGAL/Line_2.h>
#include <CGAL/Point_2.h>


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Point_2<R> &pt, const CGAL_Line_2<R> &line)
{
    return line.has_on(pt);
}

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Point_2<R> &pt, const CGAL_Line_2<R> &line)
{
    if (CGAL_do_intersect(pt,line)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Line_2<R> &line, const CGAL_Point_2<R> &pt)
{
    return line.has_on(pt);
}


template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Point_2<R> &pt)
{
    if (CGAL_do_intersect(pt,line)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

#endif
@}

@B@<2D Point Ray intersection@>

@O@<../include/CGAL/Ray_2_Point_2_intersection.h@>==@{
#include <CGAL/Point_2_Ray_2_intersection.h>
@}

@O@<../include/CGAL/Point_2_Ray_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_POINT_2_RAY_2_INTERSECTION_H
#define CGAL_POINT_2_RAY_2_INTERSECTION_H

#include <CGAL/Ray_2.h>
#include <CGAL/Point_2.h>


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Point_2<R> &pt, const CGAL_Ray_2<R> &ray)
{
    return ray.has_on(pt);
}

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Point_2<R> &pt, const CGAL_Ray_2<R> &ray)
{
    if (CGAL_do_intersect(pt,ray)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Ray_2<R> &ray, const CGAL_Point_2<R> &pt)
{
    return ray.has_on(pt);
}


template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Ray_2<R> &ray, const CGAL_Point_2<R> &pt)
{
    if (CGAL_do_intersect(pt,ray)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

#endif
@}

@B@<2D Point Segment intersection@>

@O@<../include/CGAL/Segment_2_Point_2_intersection.h@>==@{
#include <CGAL/Point_2_Segment_2_intersection.h>
@}

@O@<../include/CGAL/Point_2_Segment_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_POINT_2_SEGMENT_2_INTERSECTION_H
#define CGAL_POINT_2_SEGMENT_2_INTERSECTION_H

#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Point_2<R> &pt, const CGAL_Segment_2<R> &seg)
{
    return seg.has_on(pt);
}

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Point_2<R> &pt, const CGAL_Segment_2<R> &seg)
{
    if (CGAL_do_intersect(pt,seg)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Segment_2<R> &seg, const CGAL_Point_2<R> &pt)
{
    return seg.has_on(pt);
}


template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Segment_2<R> &seg, const CGAL_Point_2<R> &pt)
{
    if (CGAL_do_intersect(pt,seg)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

#endif
@}

@B@<2D Point Point intersection@>


@O@<../include/CGAL/Point_2_Point_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_POINT_2_POINT_2_INTERSECTION_H
#define CGAL_POINT_2_POINT_2_INTERSECTION_H

#include <CGAL/Point_2.h>


template <class R>
inline bool
CGAL_do_intersect(const CGAL_Point_2<R> &pt1, const CGAL_Point_2<R> &pt2)
{
    return pt1 == pt2;
}

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Point_2<R> &pt1, const CGAL_Point_2<R> &pt2)
{
    if (pt1 == pt2) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt1));
    }
    return CGAL_Object();
}


#endif
@}


@B@<Packing intersections together@>

@O@<../include/CGAL/intersection_2_1.h@>==@{@-
@<CGAL notice@>
// Author: Geert-Jan Giezeman


#ifndef CGAL_INTERSECTION_2_1_H
#define CGAL_INTERSECTION_2_1_H

    //#include <CGAL/Bbox_2_Line_2_intersection.h>
    //#include <CGAL/Ray_2_Bbox_2_intersection.h>
#include <CGAL/Line_2_Line_2_intersection.h>
#include <CGAL/Segment_2_Line_2_intersection.h>
#include <CGAL/Segment_2_Segment_2_intersection.h>
#include <CGAL/Ray_2_Line_2_intersection.h>
#include <CGAL/Ray_2_Segment_2_intersection.h>
#include <CGAL/Ray_2_Ray_2_intersection.h>
#include <CGAL/Point_2_Line_2_intersection.h>
#include <CGAL/Point_2_Ray_2_intersection.h>
#include <CGAL/Point_2_Segment_2_intersection.h>
#include <CGAL/Point_2_Point_2_intersection.h>

#endif
@}

@O@<../src/Bbox_2_intersections.C@>==@{@-
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#include <CGAL/Cartesian.h>
#include <CGAL/Bbox_2_Line_2_intersection.h>
#include <CGAL/Ray_2_Bbox_2_intersection.h>

@<Bbox2_2 cartesian double Line_2 intersection@>
@<Bbox2_2 cartesian double Ray_2 intersection@>
@}


