@! $RCSfile: testtypes.fw,v $
@! $Revision: 1.1 $
@! $Date: 1996/03/13 15:32:23 $

@! Author: Geert-Jan Giezeman (geert@cs.ruu.nl)

@A@<Test number types@>


@B@<testrepH@>
@$@<homogeneous testrep@>==@{@-


class CGAL_TestrepH {
public:
    CGAL_TestrepH() {}
    CGAL_TestrepH(int d) ;   // only for testrep(0) and testrep(1).
    CGAL_TestrepH(unsigned char, signed char, double d) {_d = d;}
    CGAL_TestrepH operator-() const {return CGAL_TestrepH(-_d);}
    CGAL_TestrepH operator+(CGAL_TestrepH tr) const
                    {return CGAL_TestrepH(_d + tr._d);}
    CGAL_TestrepH operator-(CGAL_TestrepH tr) const
                    {return CGAL_TestrepH(_d - tr._d);}
    CGAL_TestrepH operator*(CGAL_TestrepH tr) const
                    {return CGAL_TestrepH(_d * tr._d);}
//    double to_double() const {return _d;}
    bool operator==(CGAL_TestrepH tr) const {return _d == tr._d;}
    bool operator!=(CGAL_TestrepH tr) const {return _d != tr._d;}
    bool operator<(CGAL_TestrepH tr) const {return _d < tr._d;}
    bool operator>(CGAL_TestrepH tr) const {return _d > tr._d;}
    bool operator<=(CGAL_TestrepH tr) const {return _d <= tr._d;}
    bool operator>=(CGAL_TestrepH tr) const {return _d >= tr._d;}
friend inline double CGAL_to_double(CGAL_TestrepH tf);
protected:
    CGAL_TestrepH(float ) ;  // not implemented
    CGAL_TestrepH(double d) {_d = d;}
    CGAL_TestrepH(int, int, double) ;    // not implemented
    double _d;
};

inline CGAL_TestrepH::CGAL_TestrepH(int d)
{
    switch(d) {
    case 0:
        _d = 0.0;
        break;
    case 1:
        _d = 1.0;
        break;
    default:
        cerr << "Non-standard use of number constructor: RT("<<d<<").\n";
        _d = double(d);
    }
}

inline bool CGAL_is_finite(CGAL_TestrepH tr)
{
    return CGAL_is_finite(CGAL_to_double(tr));
}

inline bool CGAL_is_valid(CGAL_TestrepH tr)
{
    return CGAL_is_valid(CGAL_to_double(tr));
}

inline double CGAL_to_double(CGAL_TestrepH tr)
{
    return tr._d;
}
@}



@B@<testfieldH@>

The number type  appropriate for the homogeneous field type with the minimum
functionality. It has @{CGAL_TestrepH@} as related representation type.

@$@<homogeneous testfield@>==@{@-

class CGAL_TestfieldH {
public:
    CGAL_TestfieldH() {}
    CGAL_TestfieldH(int) ;
    CGAL_TestfieldH(unsigned char, signed char, double d) {_d = d;}
    CGAL_TestfieldH(CGAL_TestrepH tr) {_d = CGAL_to_double(tr);}
    CGAL_TestfieldH operator-() const {return CGAL_TestfieldH(-_d);}
    CGAL_TestfieldH operator+(CGAL_TestfieldH tf) const
                    { return CGAL_TestfieldH(_d + tf._d);}
    CGAL_TestfieldH operator-(CGAL_TestfieldH tf) const
                    { return CGAL_TestfieldH(_d - tf._d);}
    CGAL_TestfieldH operator*(CGAL_TestfieldH tf) const
                    { return CGAL_TestfieldH(_d * tf._d);}
    CGAL_TestfieldH operator/(CGAL_TestfieldH tf) const
                    { return CGAL_TestfieldH(_d / tf._d);}
    bool operator==(CGAL_TestfieldH tf) const {return _d == tf._d;}
    bool operator!=(CGAL_TestfieldH tf) const {return _d != tf._d;}
    bool operator<(CGAL_TestfieldH tf) const {return _d < tf._d;}
    bool operator>(CGAL_TestfieldH tf) const {return _d > tf._d;}
    bool operator<=(CGAL_TestfieldH tf) const {return _d <= tf._d;}
    bool operator>=(CGAL_TestfieldH tf) const {return _d >= tf._d;}
friend inline double CGAL_to_double(CGAL_TestfieldH tf);
protected:
    CGAL_TestfieldH(float) ;    // not implemented
    CGAL_TestfieldH(double d) { _d = d;}
    CGAL_TestfieldH(int, int, double) ;    // not implemented
    double _d;
};

inline CGAL_TestfieldH::CGAL_TestfieldH(int d)
{
    switch(d) {
    case 0:
        _d = 0.0;
        break;
    case 1:
        _d = 1.0;
        break;
    default:
        cerr << "Non-standard use of number constructor: FT("<<d<<").\n";
        _d = double(d);
    }
}

inline double CGAL_to_double(CGAL_TestfieldH tf)
{
    return tf._d;
}

inline bool CGAL_is_finite(CGAL_TestfieldH tf)
{
    return CGAL_is_finite(CGAL_to_double(tf));
}

inline bool CGAL_is_valid(CGAL_TestfieldH tf)
{
    return CGAL_is_valid(CGAL_to_double(tf));
}
@}

@B@<testfieldC@>
@$@<cartesian testfield@>==@{@-


class CGAL_TestfieldC {
public:
    CGAL_TestfieldC() {}
    CGAL_TestfieldC(int) ;
    CGAL_TestfieldC(unsigned char, signed char, double d) {_d = d;}
    CGAL_TestfieldC operator-() const {return CGAL_TestfieldC(-_d);}
    CGAL_TestfieldC operator+(CGAL_TestfieldC tf) const
                    { return CGAL_TestfieldC(_d + tf._d);}
    CGAL_TestfieldC operator-(CGAL_TestfieldC tf) const
                    { return CGAL_TestfieldC(_d - tf._d);}
    CGAL_TestfieldC operator*(CGAL_TestfieldC tf) const
                    { return CGAL_TestfieldC(_d * tf._d);}
    CGAL_TestfieldC operator/(CGAL_TestfieldC tf) const
                    { return CGAL_TestfieldC(_d / tf._d);}
    bool operator==(CGAL_TestfieldC tf) const {return _d == tf._d;}
    bool operator!=(CGAL_TestfieldC tf) const {return _d != tf._d;}
    bool operator<(CGAL_TestfieldC tf) const {return _d < tf._d;}
    bool operator>(CGAL_TestfieldC tf) const {return _d > tf._d;}
    bool operator<=(CGAL_TestfieldC tf) const {return _d <= tf._d;}
    bool operator>=(CGAL_TestfieldC tf) const {return _d >= tf._d;}
friend inline double CGAL_to_double(CGAL_TestfieldC tf);
protected:
    CGAL_TestfieldC(float) ;    // not implemented.
    CGAL_TestfieldC(double d) { _d = d;}
    CGAL_TestfieldC(int, int, double) ;    // not implemented.
    double _d;
};

inline CGAL_TestfieldC::CGAL_TestfieldC(int d)
{
    switch(d) {
    case 0:
        _d = 0.0;
        break;
    case 1:
        _d = 1.0;
        break;
    default:
        cerr << "Non-standard use of number constructor: CGAL_TestfieldC("
            <<d<<").\n";
        _d = double(d);
    }
}

inline double CGAL_to_double(CGAL_TestfieldC tf)
{
    return tf._d;
}

inline bool CGAL_is_finite(CGAL_TestfieldC tf)
{
    return CGAL_is_finite(CGAL_to_double(tf));
}

inline bool CGAL_is_valid(CGAL_TestfieldC tf)
{
    return CGAL_is_valid(CGAL_to_double(tf));
}
@}

@B@<include file@>
@O@<../include/CGAL/test_types.h@>==@{@-

#ifndef CGAL_TEST_TYPES_H
#define CGAL_TEST_TYPES_H


#include <iostream.h>
#include <CGAL/Double.h>

@<cartesian testfield@>
@<homogeneous testrep@>
@<homogeneous testfield@>

#endif
@}

