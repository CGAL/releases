
@! test_kernel_2.fw
@! Author: Stefan Schirra
@A@<Tests for two dimensional CGAL@>
The testfiles generated by this webfile contain checks for
the two-dimensional kernel classes via the representation class.
The file checks methods only that are public and specified.
They can be used to test both homogeneous and Cartesian
implementation.
Additional internal functionality is checked elsewhere, such that
this test can be used for representations others than @{CGAL_Homogeneous@}
and @{CGAL_Cartesian@}.
All class tests are prefixed by @{CGAL__test_cls@},
tests testing global functions are prefixed by @{CGAL__test_fct@}.
Transformations are tested in @{test_cls_aff_transformation(R)@};
besides (in-)equality and assignment operators are tested in
@{CGAL__test_fct@}.

@B@<Vector_2@>
@O@<../test/include/CGAL/_test_cls_vector_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/user_classes.h>
#include <CGAL/Vector_2_rft_wrapper.h>
#include <CGAL/Vector_2.h>

template <class R> bool CGAL__test_cls_vector_2(const R& );
@}

{
@O@<../test/include/CGAL/_test_cls_vector_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_VECTOR_2_CC
#define CGAL__TEST_CLS_VECTOR_2_CC
#include <CGAL/_test_cls_vector_2.h>

template <class R>
bool
CGAL__test_cls_vector_2(const R& )
{
 cout << "Testing class Vector_2" ;

 R::Vector_2       iv;

 CGAL_Vector_2<R>  v1;
 CGAL_Vector_2<R>  v2(iv);
 CGAL_Vector_2<R>  v0(CGAL_NULL_VECTOR);

 R::RT  n1( 12 );
 R::RT  n2( -4 );
 R::RT  n3(  6 );
 R::RT  n4(  2 );

 CGAL_Vector_2<R>  v3(n1, n2 );       // ( 12, -4)
 CGAL_Vector_2<R>  v4(n1, n2, n4);    // (  6, -2)
 CGAL_Vector_2<R>  v5(n1, n2, n4);    // (  6, -2)
 CGAL_Vector_2<R>  v6( v5 );
                   v1 = v4;
 CGAL_Vector_2<R>  v7(-n1, -n2, -n4); // (  6, -2)


 cout << '.';

 assert( v4 == v5 );
 assert( v5 == v6 );
 assert( v4 == v6 );
 assert( v1 == v6 );
 assert( v0 == CGAL_NULL_VECTOR);
 assert( v5 == v7 );

 assert( v3 != v4 );
 assert( v0 != v1 );
 assert( v1 != CGAL_NULL_VECTOR);

 assert( v3.hx() == n1 );   // don't replace v3
 assert( v3.hy() == n2 );

 assert( R::FT( v5.hx()) / R::FT(v5.hw()) == R::FT( n1) / R::FT( n4) );
 assert( R::FT( v5.hy()) / R::FT(v5.hw()) == R::FT( n2) / R::FT( n4) );

 assert( v5.x() == R::FT( n1) / R::FT( n4) );
 assert( v5.y() == R::FT( n2) / R::FT( n4) );

 cout << '.';

 assert( v3.homogeneous(0) == v3.hx() );  // don't replace v3
 assert( v3.homogeneous(1) == v3.hy() );
 assert( v3.homogeneous(2) == v3.hw() );
 assert( v6.cartesian(0) == v6.x() );
 assert( v6.cartesian(1) == v6.y() );

 cout << '.';

 assert( v0.dimension() == 2 );
 assert( v4.homogeneous( v4.dimension() ) == v4.hw() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_VECTOR_2_CC
@}

@O@<../test/include/CGAL/_test_fct_vector_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Vector_2.h>

template <class R> bool CGAL__test_fct_vector_2(const R& );
@}

@O@<../test/include/CGAL/_test_fct_vector_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_VECTOR_2_CC
#define CGAL__TEST_FCT_VECTOR_2_CC
#include <CGAL/_test_fct_vector_2.h>

template <class R>
bool
CGAL__test_fct_vector_2(const R& )
{
 cout << "Testing functions Vector_2" ;

 R::RT  n1( 12 );
 R::RT  n2( -4 );
 R::RT  n3(  6 );
 R::RT  n4(  2 );
 R::RT  n5(  9 );
 R::RT  n6(-18 );
 R::RT  n7( 36 );
 R::RT  n8(  3 );
 R::RT  n9( 15 );
 R::RT n10( -8 );

 CGAL_Vector_2<R>  v0(CGAL_NULL_VECTOR);   // ( 0, 0)
 CGAL_Vector_2<R>  v1(n1, n2, n4);         // ( 6,-2)
 CGAL_Vector_2<R>  v2(n5, n6, n8);         // ( 3,-6)
 CGAL_Vector_2<R>  v3(n5, n10);            // ( 9,-8)
 CGAL_Vector_2<R>  v4(n8, -n2 );           // ( 3, 4)
 CGAL_Vector_2<R> mv4(-n8, n2 );           // (-3,-4)

 R::RT  n15( -5 );
 CGAL_Vector_2<R>  v8( n1,  n3, -n4);      // (-6,-3)
 CGAL_Vector_2<R>  v9( R::RT(0), n15);     // ( 0,-5)

 assert( v1 + v2 == v3 );
 assert( v1 - v2 == v4 );
 assert( v3 - v1 == v2 );
 assert( v3 - v2 == v1 );
 assert( v4 + v2 == v1 );
 assert( v4 + v2 == v3 - v2);
 assert( v9 == v1 + v8 );

 cout << '.';

 assert( (-(- v1)) == v1 );
 assert( -v4 == mv4);
 assert( mv4 == v2 - v1);
 assert( -( v1 - v2) == mv4);
 assert( v1 + v0 == v1 );
 assert( v0 - v4 == mv4 );
 assert( v0 + v4 == v4 );
 assert( v2 - v0 == v2 );

 cout << '.';

#ifdef CGAL_VECTOR_WRAPPER
 assert( R::FT(v1 * v2) == R::FT(30) );
 assert( R::FT(v1 * v0) == R::FT(0) );
 assert( CGAL_Vector_2<R>( n1, n2) == R::RT(2) * v1 );
 assert( (CGAL_Vector_2<R>&)(R::RT(2) * v1) == CGAL_Vector_2<R>( n1, n2) );
 assert( CGAL_Vector_2<R>( n5, n6) == R::RT(3) * v2 );
 assert( v2 / R::RT(3) == CGAL_Vector_2<R>( R::RT(1), -n4) );
 assert( (CGAL_Vector_2<R>&)(R::RT(3) * (v2 / R::RT(3))) == v2 );
 assert( (CGAL_Vector_2<R>&)(R::RT(3) * v2 ) / R::RT(3) == v2 );
 // assert( (R::RT(3) * v2 ) / R::RT(3) == v2 );
 // ->: no match for
 //  `operator ==(class CGAL_Quotient<integer>,
 //               class CGAL_Vector_2<CGAL_Homogeneous<integer> >)'
#else // no multiplication scalar * vector ( only from the right side )
 assert( v1 * v2 == R::FT(30) );
 assert( v1 * v2 == R::FT(30) );
 assert( v1 * v0 == R::FT(0) );
 assert( CGAL_Vector_2<R>( n1, n2) == v1 * R::RT(2));
 assert( CGAL_Vector_2<R>( n5, n6) == v2 * R::RT(3));
 assert( v2 / R::RT(3) == CGAL_Vector_2<R>( R::RT(1), -n4) );
 assert( (v2 * R::RT(3)) / R::RT(3) == v2 );
 assert( (v2 / R::RT(3)) * R::RT(3) == v2 );
#endif // CGAL_VECTOR_WRAPPER

 cout << '.';

 assert( v2.cartesian(0) == v2[0] );
 assert( v2.cartesian(1) == v2[1] );

 CGAL_Point_2<R> p0(CGAL_ORIGIN);
 CGAL_Point_2<R> p1 = CGAL_ORIGIN + v1;
 CGAL_Point_2<R> p2 = CGAL_ORIGIN + v2;
 CGAL_Point_2<R> p3 = CGAL_ORIGIN + v3;

 assert( CGAL_ORIGIN + v2 == CGAL_Point_2<R>( n5, n6, n8) );
 assert( CGAL_ORIGIN - v2 == CGAL_Point_2<R>( -n5, -n6, n8) );
 assert( p1 - p1 == v0 );
 assert( p1 - p0 == p1 - CGAL_ORIGIN);
 assert( p1 - p2 == v4 );
 assert( p2 + v4 == p1 );
 assert( p3 - v1 == p2 );
 assert( p3 - p1 == v2 );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_VECTOR_2_CC
@}

@B@<Point_2@>
The test is very similar to the test for vectors, the numbers are
different.

@O@<../test/include/CGAL/_test_cls_point_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_2.h>

template <class R> bool CGAL__test_cls_point_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_point_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_POINT_2_CC
#define CGAL__TEST_CLS_POINT_2_CC
#include <CGAL/_test_cls_point_2.h>

template <class R>
bool
CGAL__test_cls_point_2(const R& )
{
 cout << "Testing class Point_2" ;

 R::Point_2       ip;

 CGAL_Point_2<R>  p1;
 CGAL_Point_2<R>  p2(ip);
 CGAL_Point_2<R>  p0(CGAL_ORIGIN);

 R::RT  n1(-35 );
 R::RT  n2( 50 );
 R::RT  n3(-20 );
 R::RT  n4(  5 );

 CGAL_Point_2<R>  p3(n1, n2);
 CGAL_Point_2<R>  p4(n1, n2, n4);
 CGAL_Point_2<R>  p5(n1, n2, n4);
 CGAL_Point_2<R>  p6( p5 );
                  p1 = p4;

 cout << '.';

 assert( p4 == p5 );
 assert( p5 == p6 );
 assert( p4 == p6 );
 assert( p1 == p6 );
 assert( p0 == CGAL_ORIGIN);

 assert( p3 != p4 );
 assert( p0 != p1 );
 assert( p1 != CGAL_ORIGIN);

 assert( p3.hx() == n1 );   // don't replace p3
 assert( p3.hy() == n2 );

 assert( R::FT(p5.hx()) / R::FT(p5.hw()) == R::FT( n1) / R::FT( n4) );
 assert( R::FT(p5.hy()) / R::FT(p5.hw()) == R::FT( n2) / R::FT( n4) );

 assert( p5.x() == R::FT( n1) / R::FT( n4 ) );
 assert( p5.y() == R::FT( n2) / R::FT( n4 ) );

 cout << '.';

 assert( p3.homogeneous(0) == p3.hx() );  // don't replace p3
 assert( p3.homogeneous(1) == p3.hy() );
 assert( p3.homogeneous(2) == p3.hw() );
 assert( p6.cartesian(0) == p6.x() );
 assert( p6.cartesian(1) == p6.y() );

 cout << '.';

 assert( p0.dimension() == 2 );
 assert( p4.homogeneous( p4.dimension() ) == p4.hw() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_POINT_2_CC
@}

@O@<../test/include/CGAL/_test_fct_point_vector_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_2.h>
#include <CGAL/Vector_2.h>

template <class R> bool CGAL__test_fct_point_vector_2(const R& );
@}

@O@<../test/include/CGAL/_test_fct_point_vector_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_POINT_VECTOR_2_CC
#define CGAL__TEST_FCT_POINT_VECTOR_2_CC
#include <CGAL/_test_fct_point_vector_2.h>

template <class R>
bool
CGAL__test_fct_point_vector_2(const R& )
{
 cout << "Testing functions Point_2 Vector_2" ;

 R::RT  n1( 12 );
 R::RT  n2( -4 );
 R::RT  n3(  6 );
 R::RT  n4(  2 );
 R::RT  n5(  9 );
 R::RT  n6(-18 );
 R::RT  n7( 36 );
 R::RT  n8(  3 );
 R::RT  n9( 15 );
 R::RT n10( -8 );

 CGAL_Vector_2<R>  v0(CGAL_NULL_VECTOR);
 CGAL_Vector_2<R>  v1(n1, n2, n4);
 CGAL_Vector_2<R>  v2(n5, n6, n8);
 CGAL_Vector_2<R>  v3(n5, n10);
 CGAL_Vector_2<R>  v4(n8, -n2);

 cout << '.';

 CGAL_Point_2<R> p0(CGAL_ORIGIN);
 CGAL_Point_2<R> p1 = CGAL_ORIGIN + v1;
 CGAL_Point_2<R> p2 = CGAL_ORIGIN + v2;
 CGAL_Point_2<R> p3 = CGAL_ORIGIN + v3;

 assert( CGAL_ORIGIN + v2 == CGAL_Point_2<R>( n5, n6, n8) );
 assert( CGAL_ORIGIN - v2 == CGAL_Point_2<R>( -n5, -n6, n8) );
 assert( p1 - p1 == v0 );
 assert( p1 - p0 == p1 - CGAL_ORIGIN);
 assert( p1 - p2 == v4 );
 assert( p2 + v4 == p1 );
 assert( p3 - v1 == p2 );
 assert( p3 - p1 == v2 );

 cout << "..";
 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_POINT_VECTOR_2_CC
@}

The following is based on @{predicates_on_points_2.h@}.
@O@<../test/include/CGAL/_test_fct_point_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_2.h>
#include <CGAL/Vector_2.h>
#include <CGAL/predicates_on_points_2.h>

template <class R> bool CGAL__test_fct_point_2(const R& );
@}

@O@<../test/include/CGAL/_test_fct_point_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_POINT_2_CC
#define CGAL__TEST_FCT_POINT_2_CC
#include <CGAL/_test_fct_point_2.h>

template <class R>
bool
CGAL__test_fct_point_2(const R& )
{
 cout << "Testing functions Point_2" ;

 CGAL_Point_2<R> p1( R::RT(18), R::RT(12), R::RT(3) );  // ( 6, 4)
 CGAL_Point_2<R> p2( R::RT(18), R::RT(15), R::RT(3) );  // ( 6, 5)
 CGAL_Point_2<R> p3( R::RT(18), R::RT( 9), R::RT(3) );  // ( 6, 3)
 CGAL_Point_2<R> p4( R::RT(28), R::RT(40), R::RT(4) );  // ( 7,10)
 CGAL_Point_2<R> p5( R::RT(12), R::RT(-4), R::RT(4) );  // ( 3,-1)
 CGAL_Point_2<R> p6( R::RT(28), R::RT(12), R::RT(4) );  // ( 7, 3)
 CGAL_Point_2<R> p7( R::RT(18), R::RT( 6), R::RT(3) );  // ( 6, 2)

 assert( CGAL_compare_lexicographically_xy(p1,p2) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xy(p3,p2) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xy(p3,p1) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xy(p3,p2) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xy(p2,p1) == CGAL_LARGER );
 assert( CGAL_compare_lexicographically_xy(p2,p3) == CGAL_LARGER );
 assert( CGAL_compare_lexicographically_xy(p4,p3) == CGAL_LARGER );
 assert( CGAL_compare_lexicographically_xy(p4,p4) == CGAL_EQUAL );

 assert( CGAL_lexicographically_xy_smaller_or_equal(p1,p1) );
 assert( CGAL_lexicographically_xy_smaller_or_equal(p3,p1) );
 assert( CGAL_lexicographically_xy_smaller_or_equal(p3,p2) );
 assert( CGAL_lexicographically_xy_smaller_or_equal(p3,p4) );

 assert( !CGAL_lexicographically_xy_smaller(p3,p3) );
 assert(  CGAL_lexicographically_xy_smaller(p3,p2) );
 assert( !CGAL_lexicographically_xy_smaller(p4,p3) );

 assert( CGAL_lexicographically_xy_larger(p2,p1) );
 assert( CGAL_lexicographically_xy_larger(p1,p3) );
 assert( CGAL_lexicographically_xy_larger(p2,p3) );
 assert( CGAL_lexicographically_xy_larger(p4,p3) );

 assert( CGAL_lexicographically_xy_larger_or_equal(p3,p3) );
 assert( CGAL_lexicographically_xy_larger_or_equal(p2,p3) );
 assert( CGAL_lexicographically_xy_larger_or_equal(p4,p3) );

 cout <<'.';

 assert( CGAL_x_equal(p1,p1) );
 assert( CGAL_x_equal(p2,p3) );
 assert( !CGAL_x_equal(p2,p4) );

 assert( CGAL_y_equal(p3,p6) );
 assert( !CGAL_y_equal(p1,p3) );

 assert( CGAL_compare_x( p1, p2 ) == CGAL_EQUAL );
 assert( CGAL_compare_x( p1, p4 ) == CGAL_SMALLER );
 assert( CGAL_compare_x( p4, p1 ) == CGAL_LARGER );
 assert( CGAL_compare_x( p6, p5 ) == CGAL_LARGER );

 assert( CGAL_compare_y( p3, p6 ) == CGAL_EQUAL );
 assert( CGAL_compare_y( p5, p7 ) == CGAL_SMALLER );
 assert( CGAL_compare_y( p3, p4 ) == CGAL_SMALLER );
 assert( CGAL_compare_y( p2, p1 ) == CGAL_LARGER );

 cout <<'.';

 CGAL_Point_2<R> pe0( R::RT(1), R::RT(0) );
 CGAL_Point_2<R> pe1( R::RT(0), R::RT(1) );

 assert( CGAL_orientation( CGAL_Point_2<R>(CGAL_ORIGIN), pe0, pe1 ) \
                           == CGAL_POSITIVE);

 assert( CGAL_orientation( p1, p2, p3) == CGAL_COLLINEAR );
 assert( CGAL_orientation( p1, p2, p4) == CGAL_RIGHTTURN );
 assert( CGAL_orientation( p2, p1, p4) == CGAL_LEFTTURN );
 assert( CGAL_orientation( p5, p4, p3) == CGAL_RIGHTTURN );
 assert( CGAL_orientation( p2, p4, p6) == CGAL_RIGHTTURN );
 assert( CGAL_orientation( p6, p4, p2) == CGAL_LEFTTURN );
 assert( CGAL_orientation( p4, p6, p2) == CGAL_RIGHTTURN );
 assert( CGAL_orientation( p5, p6, p7) == CGAL_COLLINEAR );
 assert( CGAL_orientation( p6, p5, p7) == CGAL_COLLINEAR );

 assert( CGAL_collinear( p1, p2, p3 ) );
 assert( CGAL_collinear( p1, p2, p7 ) );
 assert( CGAL_collinear( p6, p5, p7 ) );
 assert( CGAL_collinear( p1, p2, p3 ) );
 assert( !CGAL_collinear( p1, p2, p4 ) );
 assert( CGAL_collinear( p6, p6, p3 ) );

 assert( CGAL_leftturn( p1, p4, p2 ) );
 assert( CGAL_leftturn( p6, p4, p2 ) );

 assert( CGAL_rightturn( p4, p6, p2 ) );
 assert( CGAL_rightturn( p1, p2, p4 ) );

 cout << '.';

 assert( CGAL_between( p5, p7, p6 ) );   // p7 between p6 and p5
 assert( CGAL_between( p6, p7, p5 ) );
 assert( CGAL_between( p2, p1, p3 ) );
 assert( !CGAL_between( p7, p6, p5 ) );
 assert( !CGAL_between( p7, p5, p6 ) );
 assert( !CGAL_between( p7, p4, p6 ) );
 assert( !CGAL_between( p2, p4, p6 ) );
 assert( CGAL_collinear_between( p5, p7, p6 ) );
 assert( CGAL_collinear_between( p6, p7, p5 ) );
 assert( CGAL_collinear_between( p2, p1, p3 ) );
 assert( !CGAL_collinear_between( p7, p6, p5 ) );

 cout << '.';

 CGAL_Vector_2<R>     v( R::RT(10), R::RT(20), R::RT(-5) );
 CGAL_Direction_2<R>  dir1(R::RT(-11),R::RT( 13)),
                      dir2(R::RT( 14),R::RT(-22)),
                      dir3(R::RT(-12),R::RT( 47)),
                      dir4(R::RT(- 7),R::RT(- 8)),
                      dir5(R::RT( -3), R::RT( 4));

 CGAL_Aff_transformation_2<R> rotate1(CGAL_ROTATION,dir1, R::RT(1), R::RT(100)),
                              rotate2(CGAL_ROTATION,dir2, R::RT(1), R::RT(100)),
                              rotate3(CGAL_ROTATION,dir3, R::RT(1), R::RT(100)),
                              rotate4(CGAL_ROTATION,dir4, R::RT(1), R::RT(100)),
                              rotate5(CGAL_ROTATION,dir5, R::RT(1), R::RT(100));



 CGAL_Point_2<R>   p0 = pe1;
 p1 = p0.transform(rotate1);
 p2 = p0.transform(rotate2);
 p3 = p0.transform(rotate3);
 p4 = p0.transform(rotate4);
 p5 = p0.transform(rotate5);

 // assert( (p5 - CGAL_ORIGIN).direction() == dir5 );

 assert( CGAL_side_of_bounded_circle(p1, p2, p3, CGAL_Point_2<R>(CGAL_ORIGIN))\
                                      == CGAL_ON_BOUNDED_SIDE );
 assert( CGAL_side_of_bounded_circle(p1+v, p2+v, p3+v, CGAL_ORIGIN + v) \
                                      == CGAL_ON_BOUNDED_SIDE );
 assert( CGAL_side_of_bounded_circle(p1+v, p2+v, p3+v, CGAL_ORIGIN - v) \
                                      == CGAL_ON_UNBOUNDED_SIDE );
 assert( CGAL_side_of_bounded_circle(p1, p2, p3, p4) \
                                      == CGAL_ON_BOUNDARY );
 assert( CGAL_side_of_bounded_circle(p1+v, p2+v, p3+v, p4+v) \
                                      == CGAL_ON_BOUNDARY );
 assert( CGAL_side_of_bounded_circle(p1+v, p3+v, p4+v, p2+v) \
                                      == CGAL_ON_BOUNDARY );
 assert( CGAL_side_of_bounded_circle(p2+v, p4+v, p1+v, p3+v) \
                                      == CGAL_ON_BOUNDARY );

 assert( CGAL_orientation( p1, p2, p3 ) == CGAL_POSITIVE );

 assert( CGAL_side_of_oriented_circle(p1,p2,p3,CGAL_Point_2<R>(CGAL_ORIGIN))\
                                      == CGAL_ON_POSITIVE_SIDE );
 assert( CGAL_side_of_oriented_circle(p1+v, p2+v, p3+v, CGAL_ORIGIN + v) \
                                      == CGAL_ON_POSITIVE_SIDE );
 assert( CGAL_side_of_oriented_circle(p1+v, p3+v, p2+v, CGAL_ORIGIN + v) \
                                      == CGAL_ON_NEGATIVE_SIDE );
 assert( CGAL_side_of_oriented_circle(p1+v, p2+v, p3+v, CGAL_ORIGIN - v) \
                                      == CGAL_ON_NEGATIVE_SIDE );
 assert( CGAL_side_of_oriented_circle(p2+v, p1+v, p3+v, CGAL_ORIGIN - v) \
                                      == CGAL_ON_POSITIVE_SIDE );
 assert( CGAL_side_of_oriented_circle(p1, p2, p3, p4) \
                                      == CGAL_ON_ORIENTED_BOUNDARY );
 assert( CGAL_side_of_oriented_circle(p1+v, p2+v, p3+v, p4+v) \
                                      == CGAL_ON_ORIENTED_BOUNDARY );
 assert( CGAL_side_of_oriented_circle(p1+v, p3+v, p4+v, p2+v) \
                                      == CGAL_ON_ORIENTED_BOUNDARY );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_POINT_2_CC
@}

For convenience, we provide a function for testing all of
points, vectors, and directions.
@O@<../test/include/CGAL/_test_pvd_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_PVD_2_CC
#define CGAL__TEST_PVD_2_CC

#include <CGAL/_test_cls_vector_2.cc>
#include <CGAL/_test_fct_vector_2.cc>
#include <CGAL/_test_cls_point_2.cc>
#include <CGAL/_test_fct_point_vector_2.cc>
#include <CGAL/_test_fct_point_2.cc>
#include <CGAL/_test_cls_direction_2.cc>

template <class R>
bool
CGAL__test_pvd_2(const R& r)
{
 return
    CGAL__test_cls_vector_2(r)
 && CGAL__test_fct_vector_2(r)
 && CGAL__test_cls_point_2(r)
 && CGAL__test_fct_point_vector_2(r)
 && CGAL__test_fct_point_2(r)
 && CGAL__test_cls_direction_2(r)
 && CGAL__test_fct_direction_2(r)
 ;
}
#endif // CGAL__TEST_PVD_2_CC
@}

@B@<Direction_2@>
Next the tests for directions.

@O@<../test/include/CGAL/_test_cls_direction_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Vector_2.h>
#include <CGAL/Direction_2.h>

template <class R> bool CGAL__test_cls_direction_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_direction_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_DIRECTION_2_CC
#define CGAL__TEST_CLS_DIRECTION_2_CC
#include <CGAL/_test_cls_direction_2.h>

template <class R>
bool
CGAL__test_cls_direction_2(const R& )
{
 cout << "Testing class Direction_2" ;

 R::Direction_2  id;

 CGAL_Direction_2<R> d0;
 CGAL_Direction_2<R> d1(id);

 cout << '.';
 R::RT  n0 = 10;
 R::RT  n1 = 8;
 R::RT  n2 = 4;
 R::RT  n3 = 2;

 CGAL_Vector_2<R>  v( n1, n2);      // (8,4)
 CGAL_Direction_2<R> d2(v);
 CGAL_Direction_2<R> d3( n0, n1);   // (10,8)
 CGAL_Direction_2<R> d4( d3 );
 CGAL_Direction_2<R> d5 = d3;

 assert( d3 == d3 );
 assert( d3 == d4 );
 assert( d5 == d3 );
 assert( d2 != d3 );
 assert( d3 != d2 );

 cout << '.';
 CGAL_Vector_2<R> vv = d2.vector();
 assert( v == vv );

 d0 = -d3;

 assert( d0 != d3 );
 assert( d3 == -d0);

 cout << '.';
 assert( d3.delta(0) == n0 );
 assert( d3.delta(1) == n1 );
 assert( d3.delta(0) == d3.dx() );
 assert( d3.delta(1) == d3.dy() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_DIRECTION_2_CC
@}

@O@<../test/include/CGAL/_test_fct_direction_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Direction_2.h>

template <class R> bool CGAL__test_fct_direction_2(const R& );
@}

@O@<../test/include/CGAL/_test_fct_direction_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_DIRECTION_2_CC
#define CGAL__TEST_FCT_DIRECTION_2_CC
#include <CGAL/_test_fct_direction_2.h>

template <class R>
bool
CGAL__test_fct_direction_2(const R& )
{
 cout << "Testing functions Direction_2" ;

 R::RT n0 =  0;
 R::RT n1 =  1;
 R::RT n2 =  2;
 R::RT n3 =  3;
 R::RT n4 =  4;
 R::RT n5 =  5;
 R::RT n6 =  6;
 R::RT n8 =  8;

 CGAL_Direction_2<R> d[8];
 d[0] = CGAL_Direction_2<R>( n5, n0 );
 d[1] = CGAL_Direction_2<R>( n8, n3 );
 d[2] = CGAL_Direction_2<R>( n0, n4 );
 d[3] = CGAL_Direction_2<R>(-n4, n3 );
 d[4] = CGAL_Direction_2<R>(-n2, n0 );
 d[5] = CGAL_Direction_2<R>(-n4,-n6 );
 d[6] = CGAL_Direction_2<R>( n0,-n1 );
 d[7] = CGAL_Direction_2<R>( n4,-n5 );

 cout << '.';

 assert( d[0] >= d[0] );
 assert( d[0] <= d[0] );

 cout << '.';

 int i;
 int j;

 for ( i = 1; i <= 7; i++ )
 {
    // cout << endl;
    for ( j = 0; j+i <= 7; j++)
    {
        // cout << '('  << j << ',' << j+i << ')' ;
        assert( d[j] <= d[j+i] );
        assert( d[j] <  d[j+i] );
    }
    // cout << ' ';
    for (      ; j <= 7; j++)
    {
        // cout << '('  << j << ',' << (j+i)%8 << ')' ;
        assert( d[j] >= d[(j+i)%8] );
        assert( d[j] >  d[(j+i)%8] );
    }
    assert( d[i] >= d[i] );
    assert( d[i] <= d[i] );
 }

 cout << '.';

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_DIRECTION_2_CC
@}


@B@<Alignement of (implicit) points@>
@O@<../test/include/CGAL/_test_fct_point_line_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_2.h>
#include <CGAL/Line_2.h>
#include <CGAL/predicates_on_lines_2.h>

template <class R> bool CGAL__test_fct_point_line_2(const R& );
@}

{
@O@<../test/include/CGAL/_test_fct_point_line_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_POINT_2_LINE_2_CC
#define CGAL__TEST_FCT_POINT_2_LINE_2_CC
#include <CGAL/_test_fct_point_line_2.h>

template <class R>
bool
CGAL__test_fct_point_line_2(const R& )
{
 cout << "Testing functions Point_2 Line_2" ;

 R::RT n0 =  0;
 R::RT n1 =  1;
 R::RT n2 =  2;
 R::RT n3 =  3;
 R::RT n4 =  4;
 R::RT n5 =  5;
 R::RT n6 =  6;
 R::RT n7 =  7;
 R::RT n8 =  8;
 R::RT n9 =  9;
 R::RT n10= 10;
 R::RT n12= 12;
 R::RT n20= 20;

 CGAL_Point_2<R>  p1( n2, n8, n2);   // ( 1, 4)
 CGAL_Point_2<R>  p2( n4, n4, n2);   // ( 2, 2)
 CGAL_Point_2<R>  p3(n12,n10, n2);   // ( 6, 5)
 CGAL_Point_2<R>  p4( n7, n3);       // ( 7, 3)
 CGAL_Point_2<R>  p5( n9, n0, n3);   // ( 3, 0)
 CGAL_Point_2<R>  p6(n12,n20, n4);   // ( 3, 5)
 CGAL_Point_2<R>  p7(n12, n3, n3);   // ( 4, 1)
 CGAL_Point_2<R>  p8( n8, n4);       // ( 8, 4)
 CGAL_Point_2<R>  p9(-n4, n8, n4);   // (-1, 2)
 CGAL_Point_2<R>  p10(n10, n4, n2);  // ( 5, 2)

 CGAL_Point_2<R>  p11( n1, -n5,-n1); // (-1, 5)
 CGAL_Point_2<R>  p0( CGAL_ORIGIN ); // ( 0, 0)
 CGAL_Point_2<R>  p13( n8, n8, n4);  // ( 4, 4)
 CGAL_Point_2<R>  p14( n5,-n1);      // ( 5,-1)
 CGAL_Point_2<R>  p16(n12, n9, n3);  // ( 4, 3)
 CGAL_Point_2<R>  p17( n0,n1);       // ( 0, 1)

 CGAL_Line_2<R>   l14( p1, p4 );
 CGAL_Line_2<R>   l23( p2, p3 );
 CGAL_Line_2<R>   l67( p6, p7 );
 CGAL_Line_2<R>   l58( p5, p8 );
 CGAL_Line_2<R>   l1617( p16, p17);
 CGAL_Line_2<R>   l1114( p11, p14);
 CGAL_Line_2<R>   l1716( p17, p16);
 CGAL_Line_2<R>   l1411( p14, p11);
 CGAL_Line_2<R>   l013( p0, p13 );
 CGAL_Line_2<R>   l910( p9, p10 );

 cout << '.';

 assert( CGAL_compare_x( p16, p14 ) == CGAL_SMALLER );

 assert( CGAL_compare_x( p9, l14, l23) == CGAL_SMALLER );
 assert( CGAL_compare_x( p8, l14, l23) == CGAL_LARGER );
 assert( CGAL_compare_x( p2, l1617, l910) == CGAL_EQUAL );
 assert( CGAL_compare_x( p2, l1716, l910) == CGAL_EQUAL );
 assert( CGAL_compare_x( p2, l1114, l013) == CGAL_EQUAL );

 assert( CGAL_compare_y( p6, l14, l23 ) == CGAL_LARGER );
 assert( CGAL_compare_y( p9, l14, l23 ) == CGAL_SMALLER );
 assert( CGAL_compare_x( p2, l1411, l013) == CGAL_EQUAL );
 assert( CGAL_compare_x( p2, l1716, l013) == CGAL_EQUAL );

 cout << '.';

 assert( CGAL_compare_x( l14, l23, l58 ) == CGAL_SMALLER);
 assert( CGAL_compare_x( l14, l58, l23 ) == CGAL_LARGER);
 assert( CGAL_compare_x( l14, l58, l58 ) == CGAL_EQUAL);
 assert( CGAL_compare_x( l1114, l013, l910 ) == CGAL_EQUAL);
 assert( CGAL_compare_x( l1617, l910, l013 ) == CGAL_EQUAL);

 assert( CGAL_compare_y( l14, l58, l23 ) == CGAL_SMALLER);
 assert( CGAL_compare_y( l14, l23, l58 ) == CGAL_LARGER);
 assert( CGAL_compare_y( l14, l58, l58 ) == CGAL_EQUAL);
 assert( CGAL_compare_y( l1114, l013, l910 ) == CGAL_EQUAL);
 assert( CGAL_compare_y( l1617, l910, l013 ) == CGAL_EQUAL);

 assert( CGAL_compare_x( l14, l23, l67, l58 ) == CGAL_SMALLER);
 assert( CGAL_compare_x( l67, l58, l23, l14 ) == CGAL_LARGER);
 assert( CGAL_compare_x( l1114, l1617, l910, l013 ) == CGAL_EQUAL);

 assert( CGAL_compare_y( l14, l23, l67, l58 ) == CGAL_LARGER);
 assert( CGAL_compare_y( l67, l58, l23, l14 ) == CGAL_SMALLER);
 assert( CGAL_compare_y( l1114, l1617, l910, l013 ) == CGAL_EQUAL);

 cout << '.';

 assert( CGAL_compare_y_at_x( p6, l23 ) == CGAL_LARGER );
 assert( CGAL_compare_y_at_x( p6, l23.opposite() ) == CGAL_LARGER );
 assert( CGAL_compare_y_at_x( p10, l23 ) == CGAL_SMALLER );
 assert( CGAL_compare_y_at_x( p9, l23 ) == CGAL_LARGER );
 assert( CGAL_compare_y_at_x( p17, l910 ) == CGAL_SMALLER );
 assert( CGAL_compare_y_at_x( p0, l23 ) == CGAL_SMALLER );
 assert( CGAL_compare_y_at_x( p8, l58 ) == CGAL_EQUAL );
 assert( CGAL_compare_y_at_x( p2, l1617 ) == CGAL_EQUAL );

 assert( CGAL_compare_y_at_x( l14, l23, l58 ) == CGAL_LARGER );
 assert( CGAL_compare_y_at_x( l67, l58, l23 ) == CGAL_SMALLER );
 assert( CGAL_compare_y_at_x( l910, l1716, l1114) == CGAL_EQUAL);

 assert( CGAL_compare_y_at_x( l14, l23, l58, l67 ) == CGAL_SMALLER );
 assert( CGAL_compare_y_at_x( l14, l23, l67, l58 ) == CGAL_LARGER );
 assert( CGAL_compare_y_at_x( l14, l23, l1411, l1114 ) == CGAL_EQUAL );
 assert( CGAL_compare_y_at_x( l1617, l013, l910, l67 ) == CGAL_SMALLER);
 assert( CGAL_compare_y_at_x( l1617, l013, l67, l910 ) == CGAL_LARGER);
 assert( CGAL_compare_y_at_x( l1617, l013, l1114, l910 ) == CGAL_EQUAL);
 assert( CGAL_compare_y_at_x( l1617, l013, l910, l1114 ) == CGAL_EQUAL);

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_POINT_2_LINE_2_CC
@}


@B@<Line_2@>
@O@<../test/include/CGAL/_test_cls_line_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Line_2.h>
#include <CGAL/Aff_transformation_2.h>

template <class R> bool CGAL__test_cls_line_2(const R& );
@}

{
@O@<../test/include/CGAL/_test_cls_line_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_LINE_2_CC
#define CGAL__TEST_CLS_LINE_2_CC
#include <CGAL/_test_cls_line_2.h>

template <class R>
bool
CGAL__test_cls_line_2(const R& )
{
 cout << "Testing class Line_2";

 R::RT n0 =  0;
 R::RT n1 =  1;
 R::RT n2 =  2;
 R::RT n3 =  3;
 R::RT n4 =  4;
 R::RT n5 =  5;
 R::RT n6 =  6;
 R::RT n8 =  8;

 CGAL_Point_2<R> p1( n2, n4, n2 );   // ( 1, 2 )
 CGAL_Point_2<R> p2( n6, n8, n2 );   // ( 3, 4 )
 CGAL_Point_2<R> p3(-n6, n6, n3 );   // (-2, 2 )
 CGAL_Point_2<R> p4( n8, n4, n2 );   // ( 4, 2 )

 R::Line_2 il;
 CGAL_Line_2<R>  l0(il);
 CGAL_Line_2<R>  l12( p1, p2 );
 CGAL_Line_2<R>  l21( p2, p1 );
 CGAL_Line_2<R>  l34( p3, p4 );
 CGAL_Line_2<R>  l43( p4, p3 );
 CGAL_Line_2<R>  lc ( l12 );
 l0 = l12 ;

 CGAL_Segment_2<R> s12( p1, p2);
 CGAL_Line_2<R>  ls12( s12 );
 CGAL_Ray_2<R>  r21( p2, p1 );
 CGAL_Line_2<R>  lr21( r21 );
 CGAL_Direction_2<R> d12 (p2 - p1);
 CGAL_Direction_2<R> d21 (p1 - p2);
 CGAL_Line_2<R>  ld12(p1, d12);
 CGAL_Line_2<R>  ld21(p2, d21);

 cout << '.';

 assert( l12 == l12 );
 assert( l0  == l12 );
 assert( l12 == lc  );
 assert( l21 == lr21 );
 assert( l12 == ls12 );
 assert( l12 == ld12 );
 assert( l12 != l21 );
 assert( l12 != ld21 );
 assert( lr21 != ls12 );
 assert( l34 != l43 );
 assert( l12 != l43 );

 assert( l34.opposite() == l43);
 assert( l43.opposite() == l34);
 assert( l43.opposite().opposite() == l43);
 assert( ld12 == ld21.opposite() );

 CGAL_Line_2<R> labc( n2, n1, n4);
 assert( labc.a() == n2 );
 assert( labc.b() == n1 );
 assert( labc.c() == n4 );

 assert( l12.direction() == d12 );
 assert( l21.direction() == d21 );
 assert( ld21.direction() == d21 );
 assert( ld21.direction() ==  - ld12.direction() );
 assert( labc.direction() == CGAL_Direction_2<R>(labc.b(), - labc.a() ) );

 cout << '.';

 assert( l43.has_on( l43.point(0) ) );
 assert( lr21.has_on( lr21.point(1) ) );
 assert( ld21.has_on( ld21.point(-2) ) );
 assert( lr21.has_on( r21.source() ) );
 assert( labc.has_on( labc.point(0) ) );

 assert( l43.is_horizontal() );
 assert( ! l34.is_vertical() );
 assert( CGAL_Line_2<R>( n1, n0, n3 ).is_vertical() );
 assert( CGAL_Line_2<R>( n0, n2, n3 ).is_horizontal() );
 assert( ! lr21.is_horizontal() );

 assert( ld12.y_at_x( R::FT(3) ) == R::FT( 4) );
 assert( lr21.y_at_x( R::FT(3) ) == R::FT( 4) );
 assert( ld12.y_at_x( R::FT(1) ) == R::FT( 2) );
 assert( l12.y_at_x( R::FT(5) ) == R::FT( 6) );
 assert( l34.y_at_x( R::FT(8) ) == R::FT( 2) );

 assert( l12.x_at_y( R::FT(0) ) == R::FT( -1 ) );
 assert( ls12.x_at_y( R::FT(4) ) == R::FT( 3 ) );
 assert( l21.x_at_y( R::FT(6) ) == R::FT( 5 ) );
 assert( ld21.x_at_y( R::FT(2) ) == R::FT( 1 ) );

 CGAL_Direction_2<R> up( n0, n1 );
 CGAL_Aff_transformation_2<R> rot90(CGAL_ROTATION, up, n1, R::RT(100) );
 CGAL_Line_2<R> l12perp1( l12.perpendicular( p1 ) );
 CGAL_Line_2<R> l21perp1( l21.perpendicular( p1 ) );
 CGAL_Line_2<R> labcperp( labc.perpendicular( labc.point(1) ) );
 assert( l12perp1.opposite() == l21perp1 );
 assert( labcperp.direction() == CGAL_Direction_2<R>( labc.a(), labc.b()) );
 assert( l12perp1.has_on( p1 ) );
 assert( l21perp1.has_on( p1 ) );
 CGAL_Line_2<R> l12perp4( l12.perpendicular( p4 ) );
 assert( l12perp4.has_on( p4 ) );
 assert( l12.direction().transform( rot90 ) == l12perp4.direction() );

 assert( CGAL_Line_2<R>( n0, n0, n6 ).is_degenerate() );
 assert( CGAL_Line_2<R>( p1, p1 ).is_degenerate() );
 assert( ! CGAL_Line_2<R>( p1, p3 ).is_degenerate() );
 assert( ! l34.is_degenerate() );

 cout << '.';

 CGAL_Point_2<R> p5( n5, n6 );
 assert( l12.oriented_side(p3) == CGAL_ON_POSITIVE_SIDE );
 assert( l12.oriented_side(p4) == CGAL_ON_NEGATIVE_SIDE );
 assert( l12.oriented_side(p2) == CGAL_ON_BOUNDARY );
 assert( l12.oriented_side(p5) == CGAL_ON_BOUNDARY );
 assert( l21.oriented_side(p3) == CGAL_ON_NEGATIVE_SIDE );
 assert( l21.oriented_side(p5) == CGAL_ON_BOUNDARY );

 assert( l21.has_on_negative_side( p3 ) );
 assert( l12.has_on_positive_side( p3 ) );
 assert( l34.has_on_positive_side( p2 ) );
 assert( l43.has_on( CGAL_Point_2<R>( n8, n2 )) );
 assert( l43.has_on_boundary( CGAL_Point_2<R>( n8, n2 )) );
 assert( lr21.has_on( CGAL_Point_2<R>( -n1, n0 )) );

 cout << "done" << endl;
 return true;

}
#endif // CGAL__TEST_CLS_LINE_2_CC
@}


@B@<Circle_2@>
@O@<../test/include/CGAL/_test_cls_circle_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Circle_2.h>
#include <CGAL/Aff_transformation_2.h>

template <class R> bool CGAL__test_cls_circle_2(const R&);
@}

{
@O@<../test/include/CGAL/_test_cls_circle_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_CIRCLE_2_CC
#define CGAL__TEST_CLS_CIRCLE_2_CC
#include <CGAL/_test_cls_circle_2.h>

template <class R>
bool
CGAL__test_cls_circle_2(const R&)
{
 cout << "Testing class Circle_2";

 R::Circle_2  ic;
 CGAL_Circle_2<R> c0;

 R::RT n0 =  0;
 R::RT n1 = 16;
 R::RT n2 = -4;
 R::RT n3 =  2;
 R::RT n4 =  5;
 R::RT n5 = 10;
 R::RT n6 =  6;
 R::RT n8 =  9;
 R::RT n9 = 36;
 R::RT n10=  3;
 R::RT n11=-11;
 R::RT n12=200;
 R::RT n13= 13;

 CGAL_Point_2<R> p0( n1, n2, -n2);  // ( 4, -1)
 CGAL_Point_2<R> p1( n6, n8, n10);  // ( 2,  3)
 CGAL_Point_2<R> p2( n2, n0,  n2);  // ( 1,  0)
 CGAL_Point_2<R> p3( n5, n5,  n4);  // ( 2,  2)
 CGAL_Point_2<R> p4( n0, n2,  n2);  // ( 0,  1)

 CGAL_Vector_2<R> vx = p2 - CGAL_ORIGIN;
 CGAL_Vector_2<R> vy = p4 - CGAL_ORIGIN;
 CGAL_Vector_2<R> v1 = p1 - CGAL_ORIGIN;

 CGAL_Circle_2<R> c1( p0, p1, p2);
 CGAL_Circle_2<R> c2( p0, p1, p3);
 CGAL_Circle_2<R> c3( p1, p0, p2);
 CGAL_Circle_2<R> c4( p3, R::FT( n9 ));      // n9 = (n6)^2
 CGAL_Vector_2<R> vx6 = vx * n6;
 CGAL_Vector_2<R> vy6 = vy * n6;
 CGAL_Circle_2<R> c5( p3 - vx6, p3 + vx6, p3 + vy6);
 CGAL_Circle_2<R> c6( c3 );
 CGAL_Circle_2<R> c7( p3, n9, CGAL_POSITIVE);
 CGAL_Circle_2<R> c8( p3, n9, CGAL_NEGATIVE);
 CGAL_Circle_2<R> cc( p3, p3 + vx6);
 CGAL_Circle_2<R> cp( p3, p3 + vx6, CGAL_POSITIVE);
 CGAL_Circle_2<R> cn( p3, p3 + vx6, CGAL_NEGATIVE);
 c0 = c3;

 assert( c1 == c1 );
 assert( c1 != c2 );
 assert( c3 == c0 );
 assert( c0 == c3 );
 assert( c3 == c6 );
 assert( c7 != c8 );
 assert( c4 == c7 );
 assert( cc == cp );
 assert( cn != cp );
 assert( cc == c7 );

 assert( c5.center() == p3 );
 assert( cc.center() == p3 );
 assert( c5.squared_radius() == R::FT( n9 ) );
 assert( c4.squared_radius() == cc.squared_radius() );
 assert( c4 == c5 );
 assert( c4 == c7 );
 assert( c4 != c8 );
 assert( cn == cp.opposite() );
 assert( c7.opposite() == c8 );
 assert( c8.opposite() == c7 );
 assert( c1.opposite() == c3 );
 assert( c3.opposite() == c1 );
 assert( c7.orientation() == CGAL_POSITIVE );
 assert( c8.orientation() == CGAL_NEGATIVE );
 assert( c5.orientation() == CGAL_POSITIVE );
 assert( cc.orientation() == CGAL_POSITIVE );
 assert( cp.orientation() == CGAL_POSITIVE );
 assert( cn.orientation() == CGAL_NEGATIVE );

 cout << '.';

 assert( c4.center() == p3 );
 assert( c5.center() == p3 );
 assert( c4.squared_radius() == R::FT( n9 ) );
 assert( c5.squared_radius() == R::FT( n9 ) );
 assert( c8.squared_radius() == R::FT( n9 ) );

 assert( c7.bounded_side( p3 + vx*n2 ) == CGAL_ON_BOUNDED_SIDE );
 assert( c7.bounded_side( p3 + vy*n11 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( c7.bounded_side( p3 - vy6 ) == CGAL_ON_BOUNDARY );
 assert( c8.bounded_side( p3 + vx*n2 ) == CGAL_ON_BOUNDED_SIDE );
 assert( c8.bounded_side( p3 + vy*n11 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( c8.bounded_side( p3 - vy6 ) == CGAL_ON_BOUNDARY );
 assert( cc.has_on_boundary( p3 + vy6) );
 assert( cc.has_on_boundary( p3 - vx6) );

 cout << '.';

 CGAL_Aff_transformation_2<R>
          rotate1(CGAL_ROTATION,CGAL_Direction_2<R>(n11,n13),-n2,n12),
          rotate2(CGAL_ROTATION,CGAL_Direction_2<R>(-n8, n9),-n2,n12),
          rotate3(CGAL_ROTATION,CGAL_Direction_2<R>( n5,-n1),-n2,n12),
          rotate4(CGAL_ROTATION,CGAL_Direction_2<R>(-n5,-n11),-n2,n12);
 CGAL_Point_2<R> p6 = p2.transform( rotate1 );
 CGAL_Point_2<R> p7 = p2.transform( rotate2 );
 CGAL_Point_2<R> p8 = p2.transform( rotate3 );
 CGAL_Point_2<R> p9 = p2.transform( rotate4 );
 p6 = p6 + v1;  // v1 = ( 2, 3 )
 p7 = p7 + v1;
 p8 = p8 + v1;
 p9 = p9 + v1;


 CGAL_Circle_2<R> c10 (p6, p8, p7);


 assert( c10.orientation() == CGAL_POSITIVE );
 assert( c10.opposite().orientation() == CGAL_NEGATIVE );

 assert( c10.oriented_side(c10.center() ) == CGAL_POSITIVE );
 assert( c10.oriented_side(CGAL_ORIGIN + v1 + vx/n2 ) == CGAL_POSITIVE );
 assert( c10.oriented_side(CGAL_ORIGIN + v1 + vx*n2 ) == CGAL_NEGATIVE );

 assert( c10.oriented_side(p9 ) == CGAL_ON_ORIENTED_BOUNDARY );
 assert( c10.has_on_boundary(p9) );
 assert( c10.has_on_boundary(p4 + v1) );
 CGAL_Point_2<R> p11( n4, n4, n3) ; // (2.5, 2.5)
 CGAL_Point_2<R> p12( n5, n5, n3) ; // ( 5 ,  5 )
 assert( c10.has_on_bounded_side( p11 ) );
 assert( ! c10.has_on_bounded_side( p12 ) );
 assert( c10.has_on_unbounded_side( p12 ) );
 assert( c10.has_on_positive_side( p11 ) );
 assert( c10.has_on_negative_side( p12 ) );
 assert( c10.opposite().has_on_negative_side( p11 ) );
 assert( c10.opposite().has_on_positive_side( p12 ) );
 assert( c10.has_on_boundary( p6 ) );
 assert( c10.has_on_boundary( p8 ) );

 cout << '.';

 CGAL_Circle_2<R> c11( p0, p0, p1) ;
 CGAL_Circle_2<R> c12( p1, p1 + v1, p1 + v1 * R::RT(2)) ;
 assert( c11.orientation() == CGAL_ZERO );
 assert( c12.orientation() == CGAL_ZERO );
 assert( c11.is_degenerate() );
 assert( c12.is_degenerate() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_CIRCLE_2_CC
@}

@B@<Segment_2@>
@O@<../test/include/CGAL/_test_cls_segment_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Segment_2.h>

template <class R> bool CGAL__test_cls_segment_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_segment_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_SEGMENT_2_CC
#define CGAL__TEST_CLS_SEGMENT_2_CC
#include <CGAL/_test_cls_segment_2.h>

template <class R>
bool
CGAL__test_cls_segment_2(const R& )
{
 cout << "Testing class Segment_2";

 R::Segment_2  is;
 CGAL_Segment_2<R> s0;

 R::RT  n0 = 0;
 R::RT  n2 = 2;
 R::RT  n3 = 3;
 R::RT  n4 = 4;
 R::RT  n5 = 5;
 R::RT  n8 = 8;
 R::RT  n9 = 9;
 R::RT n10 =10;

 CGAL_Point_2<R> p1( n2, n8, n2);
 CGAL_Point_2<R> p2( n10, n4, n2);
 CGAL_Point_2<R> p3( n9, n9, n3);
 CGAL_Point_2<R> p4( n10, n8, n2);

 CGAL_Segment_2<R> s1 ( p1, p2 );
 CGAL_Segment_2<R> s2 ( p2, p1 );
 CGAL_Segment_2<R> s3 ( p2, p3 );
 CGAL_Segment_2<R> s4 ( p2, p4 );
 CGAL_Segment_2<R> s5 ( p4, p1 );
 CGAL_Segment_2<R> s6 ( s3 );
 s0 = s2;

 assert( s5 == s5 );
 assert( s6 == s3 );
 assert( s2 == s0 );
 assert( s0 == s2 );
 assert( s1 != s5 );
 assert( s1 != s2 );
 assert( s3 != s2 );

 cout << '.';

 assert( s1.source() == p1 );
 assert( s2.source() == p2 );
 assert( s6.source() == p2 );
 assert( s4.target() == p4 );
 assert( s5.target() == p1 );

 assert( s1.min() == p1 );
 assert( s3.min() == p3 );
 assert( s4.min() == p2 );
 assert( s4.max() == p4 );
 assert( s5.max() == p4 );

 assert( s3.vertex(0) == p2 );
 assert( s3.vertex(1) == p3 );
 assert( s3.vertex(2) == p2 );
 assert( s4.point(8) == s4.vertex(8) );
 assert( s1.point(3) == s1.vertex(3) );
 assert( s5[0] == s5.vertex(0) );
 assert( s6[1] == s6.vertex(1) );

 cout << '.';

 assert( s1.squared_length() == R::FT( 20 ) );
 assert( s5.squared_length() == R::FT( 16 ) );
 assert( s4.direction() == CGAL_Direction_2<R>( p4 - p2 ) );
 assert( s2.opposite() == s1 );
 assert( s1.opposite() == s2 );
 assert( s1.supporting_line() == CGAL_Line_2<R>( p1, p2 ) );
 assert( s3.supporting_line() == CGAL_Line_2<R>( p2, p3 ) );
 assert( ! s1.is_horizontal() );
 assert( ! s1.is_vertical() );
 assert( s5.is_horizontal() );
 assert( s4.is_vertical() );

 cout << '.';

 assert( s1.has_on( p1 ) );
 assert( s1.has_on( p2 ) );
 assert( s1.has_on( p3 ) );
 assert( s2.has_on( p3 ) );
 assert( ! s4.has_on( p3 ) );
 assert( s1.collinear_has_on( p3 ) );
 assert( s2.collinear_has_on( p1 ) );
 assert( ! s3.collinear_has_on( p1 ) );
 assert( s3.collinear_has_on( CGAL_Point_2<R>( n8, n5, n2)) );

 assert( CGAL_Segment_2<R>( p3, p3).is_degenerate() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_SEGMENT_2_CC
@}

@B@<Ray_2@>
@O@<../test/include/CGAL/_test_cls_ray_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Ray_2.h>

template <class R> bool CGAL__test_cls_ray_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_ray_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_RAY_2_CC
#define CGAL__TEST_CLS_RAY_2_CC
#include <CGAL/_test_cls_ray_2.h>

template <class R>
bool
CGAL__test_cls_ray_2(const R& )
{
 cout << "Testing class Ray_2";

 R::Ray_2  ir;
 CGAL_Ray_2<R> r0;

 R::RT  n0 = 0;
 R::RT  n2 = 2;
 R::RT  n3 = 3;
 R::RT  n4 = 4;
 R::RT  n5 = 5;
 R::RT  n8 = 8;
 R::RT  n9 = 9;
 R::RT n10 =10;

 CGAL_Point_2<R> p1( n2, n8, n2);
 CGAL_Point_2<R> p2( n10, n4, n2);
 CGAL_Point_2<R> p3( n9, n9, n3);
 CGAL_Point_2<R> p4( n10, n8, n2);
 CGAL_Direction_2<R> d12( p2 - p1);
 CGAL_Direction_2<R> d24( p4 - p2);

 CGAL_Ray_2<R> r1( p1, p2);
 CGAL_Ray_2<R> r2( p1, d12);
 CGAL_Ray_2<R> r3( p3, p2);
 CGAL_Ray_2<R> r4( p2, d24);
 CGAL_Ray_2<R> r5( p2, p4);
 CGAL_Ray_2<R> r6( p1, p4);
 r0 = r3;

 cout << '.';

 assert( r1 == r1 );
 assert( r2 == r1 );
 assert( r4 == r5 );
 assert( r0 == r3 );
 assert( r6 != r1 );
 assert( r1 != r3 );
 assert( r1 != r5 );

 assert( r2.source() == p1 );
 assert( r0.source() == p3 );
 assert( r4.source() == r4.point(0) );

 assert( r1.direction() == d12 );
 assert( r2.direction() == d12 );
 assert( r3.direction() == r1.direction() );

 assert( r3.supporting_line() == r1.supporting_line() );
 assert( r5.supporting_line() == CGAL_Line_2<R>( p2, p4 ) );

 assert( r4.opposite() == CGAL_Ray_2<R>( p2, -d24 ) );
 assert( r1.opposite() == CGAL_Ray_2<R>( p1, -d12 ) );
 assert( r2.opposite().opposite() == r2 );

 assert( r6.is_horizontal() );
 assert( ! r0.is_horizontal() );
 assert( r5.is_vertical() );
 assert( ! r5.is_horizontal() );

 assert( r1.has_on( p1 ) );
 assert( r1.has_on( p2 ) );
 assert( r1.has_on( p3 ) );
 assert( r3.opposite().has_on( p1 ) );
 assert( ! r1.has_on( p4 ) );
 assert( ! r0.has_on( CGAL_Point_2<R>( n8, n5, n8 )) );
 assert( r4.has_on( r4.point(7)) );
 assert( r3.collinear_has_on( r3.point(7)) );
 assert( r1.collinear_has_on( p3) );
 assert( ! r3.collinear_has_on( p1 ) );

 assert( CGAL_Ray_2<R>( p1, p1).is_degenerate() );
 assert( ! r0.is_degenerate() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_RAY_2_CC
@}

@B@<Triangle_2@>
@O@<../test/include/CGAL/_test_cls_triangle_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Triangle_2.h>

template <class R> bool CGAL__test_cls_triangle_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_triangle_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_TRIANGLE_2_CC
#define CGAL__TEST_CLS_TRIANGLE_2_CC
#include <CGAL/_test_cls_triangle_2.h>

template <class R>
bool
CGAL__test_cls_triangle_2(const R& )
{
 cout << "Testing class Triangle_2";

 R::Triangle_2 it;
 CGAL_Triangle_2<R> t0(it);

 R::RT n0 =  0;
 R::RT n1 =  1;
 R::RT n2 =  2;
 R::RT n3 =  3;
 R::RT n4 =  4;
 R::RT n5 =  5;
 R::RT n6 =  6;
 R::RT n7 =  7;
 R::RT n8 =  8;
 R::RT n9 =  9;
 R::RT n10= 10;
 R::RT n12= 12;
 R::RT n21= 21;

 CGAL_Point_2<R> p1( n6, n6, n6);    // ( 1, 1)
 CGAL_Point_2<R> p2( n6, n9, n3);    // ( 2, 3)
 CGAL_Point_2<R> p3( n6, n10, n2);   // ( 3, 5)
 CGAL_Point_2<R> p4( n5, n4, n1);    // ( 5, 4)
 CGAL_Point_2<R> p5( n21, n9, n3);   // ( 7, 3)
 CGAL_Point_2<R> p6( n8, n4, n2);    // ( 4, 2)
 CGAL_Point_2<R> p7( n4, n0);        // ( 4, 0)
 CGAL_Point_2<R> p8(-n12,-n8,-n2);   // ( 6, 4)
 CGAL_Point_2<R> p9( n9, n9, n3);    // ( 3, 3)

 CGAL_Triangle_2<R> t1( p1, p3, p5);
 CGAL_Triangle_2<R> t2( p3, p1, p5);
 CGAL_Triangle_2<R> t3( p7, p8, p9);
 CGAL_Triangle_2<R> t4( p3, p5, p1);
 CGAL_Triangle_2<R> t5( p5, p1, p3);
 t0 = t3;

 cout << '.';

 assert( t1 == t1 );
 assert( t4 == t1 );
 assert( t1 == t5 );
 assert( t0 == t3 );
 assert( t1 != t2 );
 assert( t3 != t2 );

 assert( t3.vertex(0) == p7 );
 assert( t3.vertex(1) == p8 );
 assert( t3.vertex(2) == p9 );
 assert( t3.vertex(3) == p7 );
 assert( t3.vertex(4) == p8 );
 assert( t3.vertex(5) == p9 );
 assert( t2[5] == t2.vertex(5) );
 assert( t2[6] == t2.vertex(6) );

 assert( t1.orientation() == CGAL_NEGATIVE );
 assert( t2.orientation() == CGAL_POSITIVE );
 assert( t0.orientation() == CGAL_POSITIVE );

 cout << '.';

 assert( t1.oriented_side( p9 ) == CGAL_ON_NEGATIVE_SIDE );
 assert( t1.oriented_side( p7 ) == CGAL_ON_POSITIVE_SIDE );
 assert( t1.oriented_side( p8 ) == CGAL_ON_POSITIVE_SIDE );
 assert( t1.oriented_side( p6 ) == CGAL_ON_ORIENTED_BOUNDARY );
 assert( t2.oriented_side( p8 ) == CGAL_ON_NEGATIVE_SIDE );
 assert( t2.oriented_side( p9 ) == CGAL_ON_POSITIVE_SIDE );
 assert( t2.oriented_side( p6 ) == CGAL_ON_ORIENTED_BOUNDARY );
 assert( t2.oriented_side( p3 ) == CGAL_ON_ORIENTED_BOUNDARY );

 assert( t1.bounded_side( p9 ) == CGAL_ON_BOUNDED_SIDE );
 assert( t1.bounded_side( p7 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( t1.bounded_side( p2 ) == CGAL_ON_BOUNDARY );
 assert( t2.bounded_side( p9 ) == CGAL_ON_BOUNDED_SIDE );
 assert( t2.bounded_side( p7 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( t2.bounded_side( p2 ) == CGAL_ON_BOUNDARY );
 assert( t2.bounded_side( p1 ) == CGAL_ON_BOUNDARY );
 assert( t2.bounded_side( p5 ) == CGAL_ON_BOUNDARY );

 assert( t1.opposite().has_on_positive_side( p9 ) );
 assert( t1.has_on_positive_side( p8 ) );
 assert( t3.has_on_negative_side( p2 ) );
 assert( t2.has_on_boundary( p1 ) );
 assert( t2.has_on_boundary( p2 ) );
 assert( t2.has_on_boundary( p3 ) );
 assert( t2.has_on_boundary( p4 ) );
 assert( t2.has_on_boundary( p5 ) );
 assert( t2.has_on_boundary( p6 ) );
 assert( t1.has_on_bounded_side( CGAL_Point_2<R>( n6, n8, n2)) );
 assert( t1.has_on_unbounded_side( CGAL_Point_2<R>( -n4, n8, n6)) );

 cout << '.';

 assert( t1.opposite() == t2 );
 assert( t3 == t3.opposite().opposite() );

 CGAL_Triangle_2<R> tdeg1( p1, p7, p7);
 CGAL_Triangle_2<R> tdeg2( p6, p6, p6);
 assert( tdeg1.orientation() == CGAL_ZERO );
 assert( tdeg2.orientation() == CGAL_ZERO );
 assert( tdeg1.is_degenerate() );
 assert( tdeg2.is_degenerate() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_TRIANGLE_2_CC
@}

@B@<Iso_rectangle_2@>
@O@<../test/include/CGAL/_test_cls_iso_rectangle_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Iso_rectangle_2.h>

template <class R> bool CGAL__test_cls_iso_rectangle_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_iso_rectangle_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_ISO_RECTANGLE_2_CC
#define CGAL__TEST_CLS_ISO_RECTANGLE_2_CC
#include <CGAL/_test_cls_iso_rectangle_2.h>

template <class R>
bool
CGAL__test_cls_iso_rectangle_2(const R& )
{
 cout << "Testing class Iso_rectangle_2";

 R::Iso_rectangle_2 ir;
 CGAL_Iso_rectangle_2<R>  r0(ir);

 R::RT n0 =  0;
 R::RT n1 =  1;
 R::RT n2 =  2;
 R::RT n3 =  3;
 R::RT n4 =  4;
 R::RT n5 =  5;
 R::RT n6 =  6;
 R::RT n7 =  7;
 R::RT n8 =  8;
 R::RT n9 =  9;
 R::RT n10= 10;
 R::RT n12= 12;

 CGAL_Point_2<R> p1( n5, n5, n5);    // ( 1, 1)
 CGAL_Point_2<R> p2( n2, n8, n2);    // ( 1, 4)
 CGAL_Point_2<R> p3( n12, n12, n3);  // ( 4, 4)
 CGAL_Point_2<R> p4( n5, n4, n1);    // ( 5, 4)
 CGAL_Point_2<R> p5( n4, n1);        // ( 4, 1)
 CGAL_Point_2<R> p6( n8, n4, n2);    // ( 4, 2)
 CGAL_Point_2<R> p7( n6, n3, n2);    // ( 3, 1.5)
 CGAL_Point_2<R> p8( n4, n6, n2);    // ( 2, 3)
 CGAL_Point_2<R> p9(-n3, n7);        // (-3, 7)

 CGAL_Iso_rectangle_2<R> r1( p1, p3);
 CGAL_Iso_rectangle_2<R> r2( p3, p1);
 CGAL_Iso_rectangle_2<R> r3( p2, p5);
 CGAL_Iso_rectangle_2<R> r4( p5, p2);
 CGAL_Iso_rectangle_2<R> r5( p9, p2);
 CGAL_Iso_rectangle_2<R> r6( r2 );
 r0 = r1;

 assert( r1 == r1 );
 assert( r0 == r1 );
 assert( r1 == r2 );
 assert( r1 == r3 );
 assert( r1 == r4 );
 assert( r2 == r6 );
 assert( r2 != r5 );

 cout << '.';

 assert( r1.vertex(0) == p1 );
 assert( r1.vertex(1) == p5 );
 assert( r1.vertex(2) == p3 );
 assert( r1.vertex(3) == p2 );
 assert( r1.vertex(4) == p1 );
 assert( r3.vertex(0) == p1 );
 assert( r3.vertex(1) == p5 );
 assert( r3.vertex(2) == p3 );
 assert( r3.vertex(3) == p2 );
 assert( r3.vertex(4) == p1 );
 assert( r2[0] == r2.vertex(0) );
 assert( r2[1] == r2.vertex(1) );
 assert( r2[3] == r2.vertex(3) );
 assert( r2[4] == r2.vertex(0) );

 cout << '.';

 assert( r4.min() == p1 );
 assert( r1.min() == p1 );
 assert( r5.min() != p9 );
 assert( r2.max() == p3 );

 assert( r1.bounded_side( p8 ) == CGAL_ON_BOUNDED_SIDE );
 assert( r2.bounded_side( p7 ) == CGAL_ON_BOUNDED_SIDE );
 assert( r3.bounded_side( p9 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( r1.bounded_side( p4 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( r4.bounded_side( p6 ) == CGAL_ON_BOUNDARY );
 assert( r4.bounded_side( p1 ) == CGAL_ON_BOUNDARY );

 assert( r5.has_on_boundary( p2 ) );
 assert( r4.has_on_boundary( p2 ) );
 assert( r2.has_on_bounded_side( p7 ) );
 assert( r4.has_on_unbounded_side( p9 ) );

 cout << '.';

 assert( CGAL_Iso_rectangle_2<R>( p1, p1 ).is_degenerate() );
 assert( CGAL_Iso_rectangle_2<R>( p1, p2 ).is_degenerate() );
 assert( CGAL_Iso_rectangle_2<R>( p3, p4 ).is_degenerate() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_ISO_RECTANGLE_2_CC
@}

@B@<Aff_transformation_2@>
@O@<../test/include/CGAL/_test_cls_aff_transformation_2.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_2.h>
#include <CGAL/Vector_2.h>
#include <CGAL/Direction_2.h>
#include <CGAL/Line_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Triangle_2.h>
#include <CGAL/Circle_2.h>
#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/Aff_transformation_2.h>

template <class R> bool CGAL__test_cls_aff_transformation_2(const R& );
@}

@O@<../test/include/CGAL/_test_cls_aff_transformation_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_AFF_TRANSFORMATION_2_CC
#define CGAL__TEST_CLS_AFF_TRANSFORMATION_2_CC
#include <CGAL/_test_cls_aff_transformation_2.h>

template <class R>
bool
CGAL__test_cls_aff_transformation_2(const R& )
{
 cout << "Testing class Aff_transformation_2" ;

 R::Aff_transformation_2 ia;
 CGAL_Aff_transformation_2<R> a1(ia);

 R::RT n0 =  0;
 R::RT n1 =-15;
 R::RT n2 = 44;
 R::RT n3 =  4;
 R::RT n4 =  5;
 R::RT n5 = 25;
 R::RT n6 = -2;
 R::RT n7 =  8;
 R::RT n8 = 18;
 R::RT n9 =  9;
 R::RT n10=  3;
 R::RT n11=-12;
 R::RT n12= 20;
 R::RT n13=  1;
 R::RT n14= 35;
 R::RT n100 = 100;

 CGAL_Vector_2<R> vec( n3, n8,  n6 );      // (-2,-9)
 CGAL_Vector_2<R> tvec;
 CGAL_Point_2<R>  pnt( n8, n1, n10 );      // ( 6,-5)
 CGAL_Point_2<R>  tpnt;
 CGAL_Point_2<R>  pvec = CGAL_ORIGIN + vec;
 CGAL_Vector_2<R> vpnt = pnt - CGAL_ORIGIN;

 CGAL_Point_2<R>  p1(-n3, n7, n3 );        // (-1, 2)
 CGAL_Point_2<R>  p2( n5, n4, n4 );        // ( 5, 1)
 CGAL_Point_2<R>  p3( n1, n0, n4 );        // (-3, 0)
 CGAL_Point_2<R>  p4( n7, n2,-n6 );        // ( 4,11)

 CGAL_Direction_2<R> d0(n13, n0);
 CGAL_Direction_2<R> d1(n0, n13);
 CGAL_Direction_2<R> dir = (p2 - p4).direction();
 CGAL_Direction_2<R> tdir;

 CGAL_Point_2<R>   tp1;
 CGAL_Point_2<R>   tp2;
 CGAL_Point_2<R>   tp3;
 CGAL_Point_2<R>   tp4;
 CGAL_Segment_2<R> seg(p1,p2);
 CGAL_Segment_2<R> tseg;
 CGAL_Ray_2<R>     ray(p3,p2);
 CGAL_Ray_2<R>     tray;
 CGAL_Line_2<R>    lin(p2,p4);
 CGAL_Line_2<R>    tlin;
 CGAL_Triangle_2<R>     tri( p2,p3,p4);
 CGAL_Triangle_2<R>     ttri;

 CGAL_Circle_2<R>         circ(p2, p3, p4);
 CGAL_Circle_2<R>         tcirc;
 CGAL_Iso_rectangle_2<R>  isor(p3, p4);
 CGAL_Iso_rectangle_2<R>  tisor;

 CGAL_Aff_transformation_2<R> ident(n8,  n0,  n0,
                                    n0,  n8,  n0,
                                              n8 );

 CGAL_Aff_transformation_2<R> gat1( n7,  n9,  n2,
                                    n5, n11,  n4,
                                              n3 );

 CGAL_Aff_transformation_2<R> gat2( n7,  n9,  n2,
                                    n5, n11,  n4,
                                              n13 );

 CGAL_Aff_transformation_2<R> gat3( n4,  n6,  n0,
                                   n12,  n8,  n0,
                                              n13 );

 CGAL_Aff_transformation_2<R> scale11( CGAL_SCALING, n2, n3 );

 CGAL_Aff_transformation_2<R> gscale(n2,  n0, n0,
                                     n0,  n2, n0,
                                              n3 );

 CGAL_Aff_transformation_2<R> gtrans(n10, n0, n8,
                                     n0, n10, n1,
                                              n10 );

 CGAL_Aff_transformation_2<R> translate( CGAL_TRANSLATION, vpnt );

 CGAL_Aff_transformation_2<R> xrefl(-n4,  n0, n0,
                                     n0,  n4, n0,
                                              n4 );

 CGAL_Aff_transformation_2<R> gat4( gat3);

 CGAL_Aff_transformation_2<R> gat5( n7,  n9,
                                    n5, n11,
                                              n13 );

 CGAL_Aff_transformation_2<R> gat6( n4,  n6,
                                   n12,  n8,
                                              n13 );

 CGAL_Aff_transformation_2<R> rot90( CGAL_ROTATION, d1, n13, n100 );

 CGAL_Aff_transformation_2<R> rot2( CGAL_ROTATION, dir, n13, n100 );

 CGAL_Aff_transformation_2<R> rot3( CGAL_ROTATION, R::RT(3),R::RT(4),R::RT(5));



 CGAL_Aff_transformation_2<R> a[14];

 cout << '.';

 a[0] = ident;
 a[1] = gat1;
 a[2] = gat2;
 a[3] = gat3;
 a[4] = scale11;
 a[5] = gscale;
 a[6] = gtrans;
 a[7] = translate;
 a[8] = xrefl;
 a[9] = gat5;
 a[10]= gat6;
 a[11]= rot90;
 a[12]= rot2;
 a[13]= rot3;

 CGAL_Aff_transformation_2<R> inv;

 for (int i = 0; i< 14; i++)
 {
    tp1 = p1.transform( a[i] );
    tp2 = p2.transform( a[i] );
    tp3 = p3.transform( a[i] );
    tp4 = p4.transform( a[i] );
    tseg = seg.transform( a[i] );
    tray = ray.transform( a[i] );
    tlin = lin.transform( a[i] );
    ttri = tri.transform( a[i] );
    tisor= isor.transform( a[i]);
    assert( tseg == CGAL_Segment_2<R>(tp1, tp2) );
    assert( tray == CGAL_Ray_2<R>(tp3, tp2) );
    assert( tlin == CGAL_Line_2<R>(tp2, tp4) );
    assert( ttri == CGAL_Triangle_2<R>(tp2, tp3, tp4) );
    assert( tisor== CGAL_Iso_rectangle_2<R>( tp3, tp4 ) );

    inv = a[i].inverse();
    tp4  = tp4.transform(  inv );
    tseg = tseg.transform( inv );
    tray = tray.transform( inv );
    tlin = tlin.transform( inv );
    ttri = ttri.transform( inv );
    assert( tp4  == p4 );
    assert( tseg == seg );
    assert( tray == ray );
    assert( tlin == lin );
    assert( ttri == tri );
 };

 cout << '.';

 // ident
 assert( vec.transform(ident) == vec );
 assert( dir.transform(ident) == dir );
 assert( pnt.transform(ident) == pnt );
 assert( lin.transform(ident) == lin );

 // scale11 and gscale
 tpnt = pnt.transform(scale11);
 tvec = vec.transform(scale11);
 tdir = dir.transform(scale11);
 tseg = seg.transform(scale11);
 assert( tseg.squared_length() == R::FT(11)* R::FT(11)* seg.squared_length() );
 assert( R::FT(11)* R::FT(11)* R::FT( vec*vec ) == R::FT( tvec*tvec ) );
 assert( vec.direction() == tvec.direction() );
 assert( dir == tdir );
 tdir = d0.transform(scale11);
 assert( d0 == tdir);
 tpnt = pnt.transform(gscale);
 tvec = vec.transform(gscale);
 tdir = dir.transform(gscale);
 tseg = seg.transform(gscale);
 assert( tseg.squared_length() == R::FT(11)* R::FT(11)* seg.squared_length() );
 assert( R::FT(11)* R::FT(11)* R::FT( vec*vec ) == R::FT( tvec*tvec ) );
 assert( seg.transform(scale11) == seg.transform(gscale) );
 assert( vec.transform(scale11) == vec.transform(gscale) );
 assert( dir.transform(scale11) == dir.transform(gscale) );
 assert( pnt.transform(scale11) == pnt.transform(gscale) );
 assert( lin.transform(scale11) == lin.transform(gscale) );

 // translate and gtrans
 tvec = vec.transform(translate);
 tdir = dir.transform(translate);
 tp2 = p2.transform(translate);
 tp3 = p3.transform(translate);
 assert( vec == tvec );
 assert( dir == tdir );
 assert( tp2  == p2 + vpnt );
 assert( tp3  == p3 + vpnt );
 tvec = vec.transform(gtrans);
 tdir = dir.transform(gtrans);
 tp2 = p2.transform(gtrans);
 tp3 = p3.transform(gtrans);
 assert( vec == tvec );
 assert( dir == tdir );
 assert( tp2  == p2 + vpnt );
 assert( tp3  == p3 + vpnt );
 assert( vec.transform(translate) == vec.transform(gtrans) );
 assert( dir.transform(translate) == dir.transform(gtrans) );
 assert( pnt.transform(translate) == pnt.transform(gtrans) );
 assert( lin.transform(translate) == lin.transform(gtrans) );

 // xrefl
 tdir = d0.transform(xrefl);
 assert( tdir == -d0 );
 tdir = d1.transform(xrefl);
 assert( tdir == d1 );

 cout << '.';

 // composition
 assert( pnt.transform(xrefl).transform(xrefl) == pnt );
 assert( dir.transform(xrefl).transform(xrefl) == dir );
 assert( vec.transform(xrefl).transform(xrefl) == vec );
 assert( lin.transform(xrefl).transform(xrefl) == lin );
 CGAL_Aff_transformation_2<R> co1 = xrefl * xrefl;
 assert( pnt.transform(xrefl).transform(xrefl) == pnt.transform(co1) );
 assert( dir.transform(xrefl).transform(xrefl) == dir.transform(co1) );
 assert( vec.transform(xrefl).transform(xrefl) == vec.transform(co1) );
 assert( lin.transform(xrefl).transform(xrefl) == lin.transform(co1) );
 co1 = gat2 * gat3;
 assert( pnt.transform(gat3).transform(gat2) == pnt.transform(co1) );
 assert( dir.transform(gat3).transform(gat2) == dir.transform(co1) );
 assert( vec.transform(gat3).transform(gat2) == vec.transform(co1) );
 assert( lin.transform(gat3).transform(gat2) == lin.transform(co1) );
 co1 = ident * gat1;
 assert( vec.transform(gat1) == vec.transform(co1) );
 assert( dir.transform(gat1) == dir.transform(co1) );
 assert( pnt.transform(gat1) == pnt.transform(co1) );
 assert( lin.transform(gat1) == lin.transform(co1) );
 co1 = gat1 * ident;
 assert( vec.transform(gat1) == vec.transform(co1) );
 assert( dir.transform(gat1) == dir.transform(co1) );
 assert( pnt.transform(gat1) == pnt.transform(co1) );
 assert( lin.transform(gat1) == lin.transform(co1) );
 co1 = gat1 * gat1.inverse() ;
 assert( vec == vec.transform(co1) );
 assert( pnt == pnt.transform(co1) );
 assert( dir == dir.transform(co1) );
 assert( lin == lin.transform(co1) );

 // even
 assert( translate.is_even() );
 assert( gtrans.is_even() );
 assert( gscale.is_even() );
 assert( scale11.is_even() );
 assert( ident.is_even() );
 assert( rot90.is_even() );
 assert( rot2.is_even() );
 assert( rot3.is_even() );
 assert( xrefl.is_odd() );

 // rotation
 assert( d0.transform( rot90 ) == d1 );
 assert( d1.transform( rot90.inverse() ) == d0 );
 assert( d0.transform( rot3 ) == CGAL_Direction_2<R>( R::RT(4), R::RT(3)) );
 co1 = rot3 * rot90;
 assert( d1.transform( rot3) == d0.transform( co1 ) );
 co1 = rot2 * rot90;
 assert( d1.transform( rot2) == d0.transform( co1 ) );
 co1 = rot90 * rot2;
 assert( d1.transform( rot2) == d0.transform( co1 ) );
 co1 = rot90 * rot90 * rot90 * rot90;
 assert( vec == vec.transform(co1) );
 assert( dir == dir.transform(co1) );
 assert( pnt == pnt.transform(co1) );
 assert( lin == lin.transform(co1) );
 co1 = rot3 * rot3 * rot3.inverse();
 assert( vec.transform(rot3) == vec.transform(co1) );
 assert( dir.transform(rot3) == dir.transform(co1) );
 assert( pnt.transform(rot3) == pnt.transform(co1) );
 assert( lin.transform(rot3) == lin.transform(co1) );

 //circle
 tp2 = p2.transform( translate );
 tp3 = p3.transform( translate );
 tp4 = p4.transform( translate );
 tcirc = circ.orthogonal_transform( translate );
 assert( tcirc == CGAL_Circle_2<R>( tp2, tp3, tp4 ) );
 tp2 = p2.transform( xrefl );
 tp3 = p3.transform( xrefl );
 tp4 = p4.transform( xrefl );
 tcirc = circ.orthogonal_transform( xrefl );
 assert( tcirc == CGAL_Circle_2<R>( tp2, tp3, tp4 ) );
 tp2 = p2.transform( rot3 );
 tp3 = p3.transform( rot3 );
 tp4 = p4.transform( rot3 );
 tcirc = circ.orthogonal_transform( rot3 );
 assert( tcirc == CGAL_Circle_2<R>( tp2, tp3, tp4 ) );


 // copy
 assert( vec.transform( gat5 ) == vec.transform( gat2 ) );
 assert( dir.transform( gat5 ) == dir.transform( gat2 ) );

 assert( pnt.transform( gat6 ) == pnt.transform( gat3 ) );
 assert( vec.transform( gat6 ) == vec.transform( gat3 ) );
 assert( dir.transform( gat6 ) == dir.transform( gat3 ) );
 assert( lin.transform( gat6 ) == lin.transform( gat3 ) );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_AFF_TRANSFORMATION_2_CC
@}

For convenience, a full test function.
@O@<../test/include/CGAL/_test_2.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_2_CC
#define CGAL__TEST_2_CC

#include <CGAL/_test_cls_vector_2.cc>
#include <CGAL/_test_fct_vector_2.cc>
#include <CGAL/_test_cls_point_2.cc>
#include <CGAL/_test_fct_point_vector_2.cc>
#include <CGAL/_test_fct_point_3.cc>
#include <CGAL/_test_cls_direction_2.cc>
#include <CGAL/_test_fct_direction_2.cc>
#include <CGAL/_test_fct_point_line_2.cc>
#include <CGAL/_test_cls_line_2.cc>
#include <CGAL/_test_cls_segment_2.cc>
#include <CGAL/_test_cls_ray_2.cc>
#include <CGAL/_test_cls_triangle_2.cc>
#include <CGAL/_test_cls_circle_2.cc>
#include <CGAL/_test_cls_iso_rectangle_2.cc>
#include <CGAL/_test_cls_aff_transformation_2.cc>

template <class R>
bool
CGAL__test_3(const R& r)
{
 return
    CGAL__test_cls_vector_2(r)
 && CGAL__test_fct_vector_2(r)
 && CGAL__test_cls_point_2(r)
 && CGAL__test_fct_point_vector_2(r)
 && CGAL__test_fct_point_2(r)
 && CGAL__test_fct_direction_2( r )
 && CGAL__test_fct_direction_2(r)
 && CGAL__test_fct_point_line_2( r )
 && CGAL__test_cls_line_2( r )
 && CGAL__test_cls_segment_2( r )
 && CGAL__test_cls_ray_2( r )
 && CGAL__test_cls_triangle_2( r )
 && CGAL__test_cls_circle_2( r )
 && CGAL__test_cls_iso_rectangle_2( r )
 && CGAL__test_cls_aff_transformation_2( r )
 ;
}
#endif // CGAL_TEST_2_CC
@}

