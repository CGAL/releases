
@! $RCSfile: Polygon_2.fw,v $
@! $Revision: 1.4 $
@! $Date: 1996/03/13 15:32:23 $

@C@<Class CGAL_Polygon_2<R>@>
@$@<class CGAL_Polygon_2<R>@>==@{@-


template < class R >
class CGAL_Polygon_2 : public CGAL_Handle
{
public:
  // constructors, destructor, assignment
  CGAL_Polygon_2();
  CGAL_Polygon_2(const CGAL_Polygon_2<R> &p);

  CGAL_Polygon_2(const CGAL_Triangle_2<R> &t);
  CGAL_Polygon_2(const CGAL_Iso_rectangle_2<R> &r);
  CGAL_Polygon_2(const list<CGAL_Point_2<R> > &l);
  ~CGAL_Polygon_2();

  CGAL_Polygon_2<R> &operator=(const CGAL_Polygon_2<R> &p);

  bool operator==(const CGAL_Polygon_2<R> &p) const;
  bool operator!=(const CGAL_Polygon_2<R> &p) const;
  int id() const;

  // access
  list< CGAL_Segment_2<R> >    edges() const;
  list< CGAL_Point_2<R> >      vertices() const;
  CGAL_Segment_2<R>            edge(int i) const;
  CGAL_Point_2<R>              vertex(int i) const;
  CGAL_Point_2<R>              operator[] (int i) const;
  int                           leftmost_vertex() const;
  R::RT                         area() const
  {
    const int s = size();
    R::FT a = R::FT(0);
    for(int i=1; i<s; i++) {
      a += CGAL_area2(R::Point_2(vertex(0)),
                      R::Point_2(vertex(i)),
                      R::Point_2(vertex(i+1)));
    }
    if (a < R::FT(0)) {
      a = -a;
    }
    return a/R::FT(2.0);
  }

  int                           size() const{
  return vertex_array().high() + 1;
}

  // predicates and ordertype
  bool                          is_convex() const
  {
  const int s = size();
  if (ptr()->convex == 0)
    {
      CGAL_Orientation ord = CGAL_orientation(vertex(0), vertex(1), vertex(2));

      for(int i=1; i<s; i++) {
        if (CGAL_orientation(vertex(i), vertex(i+1), vertex(i+2)) != ord) {
          ptr()->convex == -1;
          return false;
        }
      }
      // when we arrive here all vertices have the same orientation
      ptr()->convex == 1;
    }
  return true;
}
  CGAL_Orientation                orientation() const
{
  if (ptr()->orientation == CGAL_COLLINEAR) {
    int i = leftmost_vertex();
    CGAL_Orientation ord;

    while( (ord = CGAL_orientation(vertex(i - 1),
                                 vertex(i),
                                 vertex(i + 1)))
           == CGAL_COLLINEAR ) {
      i++;
    }
    ptr()->orientation = ord;
    }
  return ptr()->orientation;
}

  CGAL_Bounded_side       bounded_side(const CGAL_Point_2<R>  &p) const;
  bool                    has_on_bounded_side(const CGAL_Point_2<R>  &p) const;
  bool                    has_on_unbounded_side(const CGAL_Point_2<R>  &p) const;
  bool                    has_on_boundary(const CGAL_Point_2<R>  &p) const;

  CGAL_Bbox_2                   bbox() const;

  CGAL_Polygon_2<R>            transform(
                                  const CGAL_Aff_transformation_2<R> &t) const;

  bool                          is_degenerate() const;

private:
  typedef list<CGAL_Point_2<R> > List;
  array<CGAL_Point_2<R> > &vertex_array() const
  {
  return ptr()->v_array ;
}

  CGAL__Polygon<CGAL_Point_2<R> >             *ptr() const{
  return (CGAL__Polygon<CGAL_Point_2<R> >*)PTR;
};

};
@}


@D@<Constructors and Destructors@>

@$@<code templates of CGAL_Polygon_2<R>@>+=@{@-

template < class R >
CGAL_Polygon_2<R>::CGAL_Polygon_2()
{
  PTR = new CGAL__Polygon<CGAL_Point_2<R> >;
}

template < class R >
CGAL_Polygon_2<R>::CGAL_Polygon_2(const CGAL_Polygon_2<R> &p):
  CGAL_Handle(p)
{}

template < class R >
CGAL_Polygon_2<R>::CGAL_Polygon_2(const list< CGAL_Point_2<R> > &l)
{
  array<CGAL_Point_2<R> > ar(l.length());
  CGAL_Point_2<R> p;
  int i=0;
  forall(p, l) {
    ar[i] = p;
    i++;
  }
  PTR = new CGAL__Polygon<CGAL_Point_2<R> >(ar);

}

template < class R >
CGAL_Polygon_2<R>::CGAL_Polygon_2(const CGAL_Triangle_2<R> &t)
{
  array<CGAL_Point_2<R> >  ar(3);
  for(int i=0; i<3; i++) {
    ar[i] = t[i];
  }
  PTR = new CGAL__Polygon<CGAL_Point_2<R> >(ar);
}

template < class R >
CGAL_Polygon_2<R>::CGAL_Polygon_2(const CGAL_Iso_rectangle_2<R> &r)
{
  array<CGAL_Point_2<R> >  ar(4);
  for(int i=0; i<4; i++) {
    ar[i] = r[i];
  }
  PTR = new CGAL__Polygon<CGAL_Point_2<R> >(ar);
}


template < class R >
CGAL_Polygon_2<R> &CGAL_Polygon_2<R>::operator=(const CGAL_Polygon_2<R> &p)
{
  CGAL_Handle::operator=(p);
  return *this;
}

template < class R >
CGAL_Polygon_2<R>::~CGAL_Polygon_2()
{}
@}

@D@<Equalness and Identity@>

@$@<code templates of CGAL_Polygon_2<R>@>+=@{@-
template < class R >
bool CGAL_Polygon_2<R>::operator==(const CGAL_Polygon_2<R>& p) const
{
  const int s = size();
  if(s == p.size())
    {
      CGAL_Point_2<R> point = vertex(0);
      for(int i=0; i<s; i++) {
        if(point == p.vertex(i)) {
          // we have found a common point
          // because polygons are simple we only have to check the remaining
          for(int j = 1; j<s; j++) {
            if(vertex(j) != p.vertex((i+j)%s)) {
              return false;   // different in one point => not equal
            }
          }
          return true;  // because all points are equal
        }
      }
    }
  return false; // because already the # of vertices is different
}

template < class R >
inline bool CGAL_Polygon_2<R>::operator!=(const CGAL_Polygon_2<R>& p) const
{
  return !(*this == p) ;
}

template < class R >
int CGAL_Polygon_2<R>::id() const
{

  return (int) PTR ;
}
@}


@D@<Access Functions@>

We have chosen the array as underlying datastructure because
it is unmodifiable and we want to have access to the i'th vertex.
Using a list this would be an O(n) time operation.

On the other hand we pay a lot for making lists to arrays and
vice versa, when we switch between polygons and (modifiable)
polylines. What about having arrays representing lists.

polyline -> polygon:  order the array and throw the 'pointer' array
(on the next element) away.

polygon -> polyline: create an array with entries: 1 2 3 ... n-1 0

Anyway this needs a careful design. Maybe we don't want indexed
access.

@$@<code templates of CGAL_Polygon_2<R>@>+=@{@-
template < class R >
list< CGAL_Point_2<R> > CGAL_Polygon_2<R>::vertices() const
{
  list< CGAL_Point_2<R> > l;
  for(int i= vertex_array().low(); i<= vertex_array().high(); i++) {
    l.push(vertex(i));
  }
  return l;
}

template < class R >
list< CGAL_Segment_2<R> > CGAL_Polygon_2<R>::edges() const
{
  list< CGAL_Segment_2<R> > l;

  for(int i= vertex_array().low(); i< vertex_array().high(); i++) {
    l.push(CGAL_Segment_2<R>(vertex(i), vertex(i+1)));
  }
  l.push(CGAL_Segment_2<R>(vertex(vertex_array().high()), vertex(0)));

  return l;
}


/*
template < class R >
int CGAL_Polygon_2<R>::size() const
{
  return vertex_array().high() + 1;
}
*/
@}


{\bf Q:} Do we really want to perform the modulo operation all
the time, or should this be in the responsibility of the user
or should that be controllable with a compiler flag?

@$@<code templates of CGAL_Polygon_2<R>@>+=@{@-
template < class R >
CGAL_Point_2<R> CGAL_Polygon_2<R>::vertex(int i) const
{ const int s = size();

  if (i>=s || i < 0){
    i = i %s;   // division is expensive
    if(i<0) {
      i += s;   // for negative wraparound
    }
  }
  return vertex_array().operator[](i);
}

template < class R >
CGAL_Point_2<R> CGAL_Polygon_2<R>::operator[](int i) const
{
  return vertex(i);
}

template < class R >
int CGAL_Polygon_2<R>::leftmost_vertex() const
{
  const int s = size();
  int lm_i = 0;
  for(int i=1; i<s; i++) {
    if (compare(vertex(i), vertex(lm_i)) == CGAL_SMALLER) {
      lm_i = i;
    }
  }
  return lm_i;
}
@}

@D@<Predicates@>

We do not recompute them each time, but store the result, as the polygon
is not modifiable.

@$@<code templates of CGAL_Polygon_2<R>@>+=@{@-
/*
template < class R >
bool CGAL_Polygon_2<R>::is_convex() const
{
  const int s = size();
  if (ptr()->convex == 0)
    {
      CGAL_Orientation ord = CGAL_orientation(vertex(0), vertex(1), vertex(2));

      for(int i=1; i<s; i++) {
        if (CGAL_orientation(vertex(i), vertex(i+1), vertex(i+2)) != ord) {
          ptr()->convex == -1;
          return false;
        }
      }
      // when we arrive here all vertices have the same orientation
      ptr()->convex == 1;
    }
  return true;
}
*/
/*
template < class R >
CGAL_Orientation CGAL_Polygon_2<R>::orientation() const
{
  if (ptr()->orientation == CGAL_COLLINEAR) {
    int i = leftmost_vertex();
    CGAL_Orientation ord;

    while( (ord = CGAL_orientation(vertex(i - 1),
                                 vertex(i),
                                 vertex(i + 1)))
           == CGAL_COLLINEAR ) {
      i++;
    }
    ptr()->orientation = ord;
    }
  return ptr()->orientation;
}
*/
template < class R >
CGAL_Side CGAL_Polygon_2<R>::bounded_side(const CGAL_Point_2<R> &p) const
{

}

template < class R >
bool CGAL_Polygon_2<R>::has_on_bounded_side(const CGAL_Point_2<R>  &p) const
{
  return bounded_side(p) == CGAL_ON_BOUNDED_SIDE;
}

template < class R >
bool CGAL_Polygon_2<R>::has_on_unbounded_side(const CGAL_Point_2<R>  &p) const
{
  return bounded_side(p) == CGAL_ON_UNBOUNDED_SIDE;
}

template < class R >
bool CGAL_Polygon_2<R>::has_on_boundary(const CGAL_Point_2<R>  &p) const
{
  return bounded_side(p) == CGAL_ON_BOUNDARY;
}
@}

@D@<Miscellaneous Functions@>

@$@<code templates of CGAL_Polygon_2<R>@>+=@{@-

template < class R >
CGAL_Bbox_2 CGAL_Polygon_2<R>::bbox() const
{
  CGAL_Bbox_2 b = vertex(0).bbox();

  for(int i= 1; i<= size(); i++) {
    b = b + vertex(i).bbox();
  }
  return b;
}

template < class R >
CGAL_Polygon_2<R> CGAL_Polygon_2<R>::transform(
                                 const CGAL_Aff_transformation_2<R> &t) const
{
  List vertexlist;
  for(int i= 1; i<= size(); i++) {
    vertexlist.append(t(vertex(i)));
  }
  return CGAL_Polygon_2<R>(vertexlist);
}

template < class R >
bool CGAL_Polygon_2<R>::is_degenerate() const
{
  cerr << "CGAL_Polygon_2<R>::is_degenerate() -- not yet implemented" << endl;
  exit(-1);
}
@}


@$@<inline code of CGAL_Polygon_2<R>@>+=@{@-
/*
template < class R >
inline CGAL__Polygon<CGAL_Point_2<R> >* CGAL_Polygon_2<R>::ptr() const
{
  return (CGAL__Polygon<CGAL_Point_2<R> >*)PTR;
}

template < class R >
array<CGAL_Point_2<R> > &CGAL_Polygon_2<R>::vertex_array() const
{
  return ptr()->v_array ;
}
*/
@}

@$@<simple IO for CGAL_Polygon_2<R>@>+=@{@-

#ifdef CGAL_IO

template < class R >
ostream &operator<<(ostream &os, CGAL_Polygon_2<R> &p)
{
  int s = p.size() - 1;
  os << "Polygon_2(" ;
  for(int i = 0; i<= s; i++) {
    os << p.vertex(i) << ", ";
  }
  os  << p.vertex(s+1) << ")";
  return os;
}

#endif  // CGAL_IO
@}

@D@<Representative Class@>

@$@<Representative of CGAL_Polygon_2<R>@>+=@{@-
template < class T >
class CGAL__Polygon : public CGAL_Rep
{
public:
  array< T >  v_array;
  int convex;  // flag :  false(-1), undefined(0), true(1)
  int simple;  // flag
  CGAL_Orientation orientation;

  CGAL__Polygon()
    : convex(0), simple(0), orientation(CGAL_COLLINEAR)
  {}

  CGAL__Polygon(const  array<T> &a)
    : v_array(a), convex(0), simple(0), orientation(CGAL_COLLINEAR)
  {}

  ~CGAL__Polygon()
  {}
};
@}

@D@<Header File@>

@O@<../include/CGAL/Polygon_2.h@>==@{@-
@<CGAL notice@>

// Source: Polygon_2.h
// Author: Andreas.Fabri@@sophia.inria.fr

#ifndef CGAL_POLYGON_2_H
#define CGAL_POLYGON_2_H

#include <LEDA/list.h>
#include <LEDA/array.h>

#include <CGAL/Segment_2.h>

@<Representative of CGAL_Polygon_2<R>@>

@<class CGAL_Polygon_2<R>@>

@<inline code of CGAL_Polygon_2<R>@>

@<code templates of CGAL_Polygon_2<R>@>

@<simple IO for CGAL_Polygon_2<R>@>

#endif  // CGAL_POLYGON_2_H
@}

@! $Log: Polygon_2.fw,v $
@! Revision 1.4  1996/03/13 15:32:23  fabri
@! *** empty log message ***
@!
@! Revision 1.3  1995/11/06 17:39:50  fabri
@! compiles with GNU g++
@!
@! Revision 1.2  1995/10/19 18:01:10  fabri
@! *** empty log message ***
@!
