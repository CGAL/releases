@A@<Numbertypes@>

Since we use LEDA we have besides the elementary numbertypes
@{int@} (in different lengths), @{float@}, and @{double@}
the LEDA numbertypes @{integer@} (arbitrary precision integer),
@{rational@} (nominator and denominator are @{integer@}), and
@{real@} (exact computation with numbers generated by the standard
operations $+,-,*,/$ and squareroot from integer or double).
Unfortunately we cannot define a @{CGAL_PointH2<double,integer>@}.
@{double(integer)@} is not a legal expression, since there
is no conversion operator to @{double@} in the class @{integer@}.
LEDA did not add it, since it creates problems in matching
function arguments for some compilers.
Instead of a conversion operator they introduced a conversion (member)
function @{todouble()@}.
In the template code this cannot be used. There I have to write
@{FT(RT)@} and cannot write @{toFT(RT)@} since only type parameters
and not names containing a substring with the name of a type parameter
are replaced in instantiation.
Therefore I defined @{CGAL_Integer@}, derived from LEDA's @{integer@},
where the conversion operator to @{double@} exists.
Note that you can define a @{CGAL_PointH2<rational,integer>@}, since
@{rational@} has a constructor with @{integer@} argument.

@B@<Class CGAL_Integer@>

Copy-constructor and destructor are not defined. Those generated
automatically should do the right job and call the appropriate base
class functions.

@$@<class CGAL_Integer@>==@{@+

class CGAL_Integer : public integer
{

public:
          CGAL_Integer(){}
          CGAL_Integer(int n) : integer(n) {}
          CGAL_Integer(unsigned int ui) : integer(ui) {}
          CGAL_Integer(long l) : integer(l) {}
          CGAL_Integer(unsigned long ul) : integer(ul) {}
          CGAL_Integer(double d) : integer(d) {}
          CGAL_Integer(float f) : integer( double(f) ) {}
          CGAL_Integer(integer i) : integer(i) {}

          operator double() const { return todouble(); }
};
@}

@O@<../include/CGAL/Integer.h@>==@{@-
// Source: Integer.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_CGAL_INTEGER_H
#define CGAL_CGAL_INTEGER_H

@<class CGAL_Integer@>

inline
bool
CGAL_is_finite(const CGAL_Integer &)
{
  return true;
}

inline
bool
CGAL_is_valid(const CGAL_Integer &)
{
  return true;
}

#endif // CGAL_CGAL_INTEGER_H
@}

@B@<Conversion to double@>

@$@<inline conversion to double for some numbertypes@>==@{@-
inline
double
CGAL_to_double(const integer & i)
{
 return i.todouble();
}


inline
double
CGAL_to_double(const real & r)
{
 return r.todouble();
}
@}

@B@<Header file for Numbertypes@>

Including @{<LEDA/real.h>@} includes @{<LEDA/rational.h>@}
and @{<LEDA/integer.h>@} as well.

@O@<../include/CGAL/numbertypes.h@>==@{@-
// Source: numbertypes.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_NUMBERTYPES_H
#define CGAL_NUMBERTYPES_H

#include <LEDA/real.h>
#include <CGAL/number_utils.h>
#include <CGAL/doublefield.h>
#include <CGAL/Rational.h>

@<inline conversion to double for some numbertypes@>

#endif // CGAL_NUMBERTYPES_H
@}
