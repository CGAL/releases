@! $RCSfile: Parabola_arcC2.fw,v $
@! $Revision: 1.2 $
@! $Date: 1996/03/13 15:32:23 $

@C@<Class CGAL_Parabola_arcC2<FT>@>


@$@<class CGAL_Parabola_arcC2<FT>@>==@{@-
template < class FT >
class CGAL_Parabola_arcC2 : public CGAL_Handle
{
public:
                       CGAL_Parabola_arcC2();
                       CGAL_Parabola_arcC2(const CGAL_Parabola_arcC2<FT>  &p);

//                     CGAL_Parabola_arcC2(const CGAL_ParabolaC2<FT> &par,
//                                           const CGAL_PointC2<FT> &p,
//                                           const CGAL_PointC2<FT> &q);
//
                       CGAL_Parabola_arcC2(const CGAL_ParabolaC2<FT> &par,
                                           const FT &lambda1,
                                           const FT &lambda2);

                       ~CGAL_Parabola_arcC2();

  CGAL_Parabola_arcC2<FT>  &operator=(const CGAL_Parabola_arcC2<FT> &l);

  bool                 operator==(const CGAL_Parabola_arcC2<FT> &l) const;
  bool                 operator!=(const CGAL_Parabola_arcC2<FT> &l) const;
  int                  id() const;

  CGAL_ParabolaC2<FT>  supporting_parabola() const;

  FT                   lambda_source() const;
  FT                   lambda_target() const;
  FT                   lambda(int i) const;

  CGAL_PointC2<FT>     source() const;
  CGAL_PointC2<FT>     target() const;
  CGAL_PointC2<FT>     vertex(int i) const;
  CGAL_PointC2<FT>     operator[](int i) const;

  bool                 is_on(const CGAL_PointC2<FT> &p) const;
  bool                 is_degenerate() const;

  CGAL_Parabola_arcC2<FT> opposite() const;
  CGAL_Bbox_2          bbox() const;

  CGAL_Parabola_arcC2<FT> transform(
                              const CGAL_Aff_transformationC2<FT> &t) const;

private:
  CGAL__Parabola_arcC2<FT>* ptr() const;
};
@}


@D@<Constructors and Destructors@>

@$@<code templates of CGAL_Parabola_arcC2<FT>@>+=@{@-
template < class FT >
CGAL_Parabola_arcC2<FT>::CGAL_Parabola_arcC2()
{
  PTR = new CGAL__Parabola_arcC2<FT>;
}

template < class FT >
CGAL_Parabola_arcC2<FT>::CGAL_Parabola_arcC2(const CGAL_Parabola_arcC2<FT>  &l)
  : CGAL_Handle((CGAL_Handle&)l)
{}

template < class FT >
CGAL_Parabola_arcC2<FT>::CGAL_Parabola_arcC2(const CGAL_ParabolaC2<FT>  &par,
                                             const FT &lambda1,
                                             const FT &lambda2)
{
  PTR = new CGAL__Parabola_arcC2<FT> (par, lambda1, lambda2);
  CGAL_nondegeneracy_assertion;
}

template < class FT >
CGAL_Parabola_arcC2<FT>::~CGAL_Parabola_arcC2()
{}


template < class FT >
CGAL_Parabola_arcC2<FT> &CGAL_Parabola_arcC2<FT>::operator=(
                                              const CGAL_Parabola_arcC2<FT> &l)
{

  CGAL_Handle::operator=(l);
  return *this;
}
@}

@D@<Equalness and Identity@>

@$@<code templates of CGAL_Parabola_arcC2<FT>@>+=@{@-
template < class FT >
bool CGAL_Parabola_arcC2<FT>::operator==(const CGAL_Parabola_arcC2<FT> &l) const
{
  return (supporting_parabola() == l.supporting_parabola()) &&
         (lambda_source() == l.lambda_source()) &&
         (lambda_target() == l.lambda_target());

}

template < class FT >
bool CGAL_Parabola_arcC2<FT>::operator!=(const CGAL_Parabola_arcC2<FT> &l) const
{
  return !(*this == l);
}

template < class FT >
int CGAL_Parabola_arcC2<FT>::id() const
{
  return (int) PTR ;
}
@}


@D@<Access Functions@>

@$@<code templates of CGAL_Parabola_arcC2<FT>@>+=@{@-
template < class FT >
CGAL_ParabolaC2<FT> CGAL_Parabola_arcC2<FT>::supporting_parabola() const
{

  return ptr()->_par;
}

template < class FT >
FT CGAL_Parabola_arcC2<FT>::lambda_source() const
{

  return ptr()->_lambda_source;
}

template < class FT >
FT CGAL_Parabola_arcC2<FT>::lambda_target() const
{

  return ptr()->_lambda_target;
}

template < class FT >
FT CGAL_Parabola_arcC2<FT>::lambda(int i)  const
{

 switch (i%2) {
  case 0: return lambda_source();
  case 1: return lambda_target();
  }
  return lambda_source();  // otherwise the SGI compiler complains
}


template < class FT >
CGAL_PointC2<FT> CGAL_Parabola_arcC2<FT>::source() const
{

  return supporting_parabola()(lambda_source());
}

template < class FT >
CGAL_PointC2<FT> CGAL_Parabola_arcC2<FT>::target() const
{

  return supporting_parabola()(lambda_target());
}


template < class FT >
CGAL_PointC2<FT> CGAL_Parabola_arcC2<FT>::vertex(int i) const
{

  switch (i%2) {
  case 0: return source();
  case 1: return target();
  }
  return source();  // otherwise the SGI compiler complains
}

template < class FT >
CGAL_PointC2<FT> CGAL_Parabola_arcC2<FT>::operator[](int i) const
{

  return vertex(i);
}
@}


@D@<Miscellaneous@>
@$@<code templates of CGAL_Parabola_arcC2<FT>@>+=@{@-

template < class FT >
bool CGAL_Parabola_arcC2<FT>::is_on(const CGAL_PointC2<FT> &p) const
{
  CGAL_ParabolaC2<FT> par = supporting_parabola();
  FT lambda1, lambda2;
  switch (par.lambdas_at_x(p.x(), lambda1, lambda2)) {
  case 2:
    return (par.y_at_lambda(lambda1)==p.y()) ||
           (par.y_at_lambda(lambda2)==p.y());
    break;
  case 1:
    return (par.y_at_lambda(lambda1)==p.y());
  }
  return false;
}


template < class FT >
bool CGAL_Parabola_arcC2<FT>::is_degenerate() const
{

  return (supporting_parabola().curvature() == FT(0)) ;
}

template < class FT >
CGAL_Parabola_arcC2<FT> CGAL_Parabola_arcC2<FT>::opposite() const
{
  return CGAL_Parabola_arcC2<FT>(supporting_parabola().opposite(),
                                 -lambda_target(),
                                 -lambda_source());
}

template < class FT >
CGAL_Bbox_2  CGAL_Parabola_arcC2<FT>::bbox() const
{

  return supporting_parabola().base().bbox() +
         source().bbox() + target().bbox();
}


template < class FT >
CGAL_Parabola_arcC2<FT> CGAL_Parabola_arcC2<FT>::transform(
                                  const CGAL_Aff_transformationC2<FT> &t) const
{
  CGAL_ParabolaC2<FT> par = supporting_parabola().transform(t);
  return CGAL_Parabola_arcC2<FT>(par,
                                 lambda_source(),
                                 lambda_target());
}

@}

@$@<inline code of CGAL_Parabola_arcC2<FT>@>+=@{@-

template < class FT >
inline CGAL__Parabola_arcC2<FT>* CGAL_Parabola_arcC2<FT>::ptr() const
{
  return (CGAL__Parabola_arcC2<FT>*)PTR;
}

@}

@$@<Representative of CGAL_Parabola_arcC2<FT>@>==@{@-
template <class FT>
class CGAL__Parabola_arcC2 : public CGAL_Rep
{
public:
  CGAL_ParabolaC2<FT>  _par;
  FT  _lambda_source;
  FT  _lambda_target;

  CGAL__Parabola_arcC2()
    {}

  CGAL__Parabola_arcC2(const CGAL_ParabolaC2<FT> &par,
                       const FT &lambda_source,
                       const FT &lambda_target)
    : _par(par), _lambda_source(lambda_source), _lambda_target(lambda_target)
    {}

  ~CGAL__Parabola_arcC2()
    {}
};
@}

@D@<Header File@>

@O@<../include/CGAL/Parabola_arcC2.h@>==@{@-
@<CGAL notice@>
// Source: Parabola_arcC2.h
// Author: Andreas.Fabri@@sophia.inria.fr

#ifndef CGAL_PARABOLA_ARCC2_H
#define CGAL_PARABOLA_ARCC2_H

#include <CGAL/ParabolaC2.h>

@<Representative of CGAL_Parabola_arcC2<FT>@>

@<class CGAL_Parabola_arcC2<FT>@>

@<inline code of CGAL_Parabola_arcC2<FT>@>


@<code templates of CGAL_Parabola_arcC2<FT>@>


#endif // CGAL_PARABOLA_ARCC2_H
@}

@! $Log: Parabola_arcC2.fw,v $
@! Revision 1.2  1996/03/13 15:32:23  fabri
@! *** empty log message ***
@!
@! Revision 1.1  1996/02/22 14:10:57  fabri
@! Initial revision
@!
@!
