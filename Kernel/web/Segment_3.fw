@! $RCSfile: Segment_3.fw,v $
@! $Revision: 1.5 $
@! $Date: 1996/10/08 07:14:35 $


@C@<Class CGAL_Segment_3<R>@>



All functions returning a bool are inherited.  The same holds for the
access functions and for functions returning points vectors and
directions.  The only member functions we have to overload are the
constructors and those which return an object of the new interface classes.


The member function @{opposite@} is an example for factoring out common
implemetation of the underlying implementation classes.

@$@<class CGAL_Segment_3<R>@>==@{@-
template<class R>
class CGAL_Segment_3 : public R::Segment_3
{
public:
  CGAL_Segment_3()     // doesn't the default constructor the same ???
    : R::Segment_3()   // does the handle stuff
  {}

  CGAL_Segment_3(const CGAL_Segment_3<R>  &s)
    : R::Segment_3(s)  // does the handle stuff
  {}

  CGAL_Segment_3(const CGAL_Point_3<R> &sp, const CGAL_Point_3<R> &ep)
    :  R::Segment_3(sp,ep)
  {}

  // conversion from implementation class object to interface class object
  CGAL_Segment_3(const R::Segment_3  &s)
    : R::Segment_3(s)  // does the handle stuff
  {}

  CGAL_Segment_3<R>   &operator=(const CGAL_Segment_3<R> &s)
  {
    R::Segment_3::operator=(s);
    return *this;
  }

  bool                 has_on(const CGAL_Point_3<R> &p) const
  {
    return R::Segment_3::has_on(p);
  }

  bool                 operator==(const CGAL_Segment_3<R> &s) const
  {
    return R::Segment_3::operator==(s);
  }

  bool                 operator!=(const CGAL_Segment_3<R> &s) const
  {
    return !(*this == s);
  }

  int                  id() const
  {
    return (int) PTR ;
  }


  CGAL_Point_3<R>     start() const
  {
    return R::Segment_3::start();
  }

  CGAL_Point_3<R>     end() const
  {
    return R::Segment_3::end();
  }

  CGAL_Point_3<R>     source() const
  {
    return R::Segment_3::source();
  }

  CGAL_Point_3<R>     target() const
  {
    return R::Segment_3::target();
  }

  CGAL_Point_3<R>     min() const
  {
    return R::Segment_3::min();
  }

  CGAL_Point_3<R>     max() const
  {
    return R::Segment_3::max();
  }

  CGAL_Point_3<R>     vertex(int i) const
  {
    return R::Segment_3::vertex(i);
  }

  CGAL_Point_3<R>     operator[](int i) const
  {
    return vertex(i);
  }


  R::FT                 squared_length() const
  {
    return R::Segment_3::squared_length();
  }


  CGAL_Direction_3<R> direction() const
  {
    return R::Segment_3::direction();
  }

  CGAL_Segment_3<R>  opposite() const
  {
    return CGAL_Segment_3<R>(target(),source());
  }

  // this makes use of the constructor of the interface class
  // taking an object of the implemetation class as argument.


  CGAL_Segment_3<R>      transform(const CGAL_Aff_transformation_3<R> &t) const
  {
    return  R::Segment_3::transform(t);
  }


  CGAL_Line_3<R>      supporting_line() const
  {
    return R::Segment_3::supporting_line();
  }

  bool                 is_degenerate() const
  {
    return R::Segment_3::is_degenerate();
  }

  CGAL_Bbox_3            bbox() const
  {
    return source().bbox() + target().bbox();
  }
};

@}

@D@<Header File@>

@O@<../include/CGAL/Segment_3.h@>==@{@-
@<CGAL notice@>
// Source: Segment_3.h
// Author: Andreas.Fabri@@sophia.inria.fr

#ifndef CGAL_SEGMENT_3_H
#define CGAL_SEGMENT_3_H

#ifdef CGAL_HOMOGENEOUS_H
#include <CGAL/SegmentH3.h>
#endif // CGAL_HOMOGENEOUS_H

#ifdef CGAL_CARTESIAN_H
#include <CGAL/SegmentC3.h>
#endif // CGAL_CARTESIAN_H

#include <CGAL/Line_3.h>

@<class CGAL_Segment_3<R>@>

#endif // CGAL_SEGMENT_3_H
@}

@! $Log: Segment_3.fw,v $
@! Revision 1.5  1996/10/08 07:14:35  fabri
@! Before removal of cast in supporting_line()
@!
@! Revision 1.4  1996/06/07 15:56:39  fabri
@! *** empty log message ***
@!
@! Revision 1.3  1996/03/13 15:32:23  fabri
@! *** empty log message ***
@!
@! Revision 1.2  1995/10/19 18:01:10  fabri
@! *** empty log message ***
@!
@! Revision 1.1  1995/09/18 13:22:38  fabri
@! Initial revision
@!
