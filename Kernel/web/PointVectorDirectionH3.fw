@B@<Points, Vectors, and Directions in 3D@>
The outline of this document is analogous to the corresponding 2D document,
see that document for more information.
The classes are parametrized by only one numbertype @{NT@}, which is mapped
to numbertype @{R::RT@} by the representation classes based on homogeneous
representation.
The numbertype @{R::FT@} of the representation class is generated automatically
as @{Quotient<NT>@}.

Point, vector, and direction have a common representant.

@C@<Class CGAL__RepH3<NT>@>
@$@<class CGAL__RepH3<NT>@>+=@{@-
template <class NT>
class CGAL__RepH3 : public CGAL_Rep
{
public:

  NT  e0;
  NT  e1;
  NT  e2;
  NT  e3;

  CGAL__RepH3()
    {
    }
  CGAL__RepH3(const NT & a0, const NT & a1, const NT & a2, const NT & a3)
    : e0(a0), e1(a1), e2(a2), e3(a3)
    {
    }
  ~CGAL__RepH3()
    {
    }

  NT    hx()
         {
           return e0;
         }
  NT    hy()
         {
           return e1;
         }
  NT    hz()
         {
           return e2;
         }
  NT    hw()
         {
           return e3;  // homogenizing component
         }

};
@}

@O@<../include/CGAL/RepH3.h@>==@{
@<CGAL notice@>
// Source: RepH3.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_REPH3_H
#define CGAL_REPH3_H

@<class CGAL__RepH3<NT>@>

#endif // CGAL_REPH3_H
@}

@C@<Class CGAL_PointH3<FT,RT>@>
The numbertype @{NT@} is used to represent the homgenous cartesians
of a point. No divison operator is needed for this numbertype.
The numbertype @{FT@} is used whenever division might be required,
e.g., for returning Cartesian cartesians.
The constructors ensure that the homogenizing cartesian is always
non-negative. This is a crucial assumption for the correctness of
many predicates on points.

@$@<class CGAL_PointH3<FT,RT>@>==@{@+

template < class FT, class RT >
class CGAL_PointH3 : public CGAL_Handle
{

public:

          CGAL_PointH3();
          CGAL_PointH3(const CGAL_PointH3<FT,RT> & tbc);
          CGAL_PointH3(const CGAL_Origin &);
          CGAL_PointH3(const CGAL_VectorH3<FT,RT>& v);
          CGAL_PointH3(const RT& x, const RT& y, const RT& z);
          CGAL_PointH3(const RT& x, const RT& y, const RT& z, const RT& w);
          ~CGAL_PointH3();

    CGAL_PointH3<FT,RT> &
          operator=( const CGAL_PointH3<FT,RT> & p);

    FT    x()  const;
    FT    y()  const;
    FT    z()  const;
    RT    hx() const;
    RT    hy() const;
    RT    hz() const;
    RT    hw() const;
    FT    cartesian(int i) const;
    RT    homogeneous(int i) const;
    FT    operator[](int i) const;

    int   dimension() const;

    CGAL_DirectionH3<FT,RT>
          direction() const;
    CGAL_PointH3<FT,RT>
          transform( const CGAL_Aff_transformationH3<FT,RT> & t) const;
    CGAL_Bbox_3
          bbox() const;

    bool  operator==( const CGAL_PointH3<FT,RT>& p) const;
    bool  operator!=( const CGAL_PointH3<FT,RT>& p) const;
    bool  identical(  const CGAL_PointH3<FT,RT>& p) const;

 friend CGAL_PointH3<FT,RT> operator+(const CGAL_Origin &,
                                      const CGAL_VectorH3<FT,RT> & v);
 friend CGAL_PointH3<FT,RT> operator-(const CGAL_Origin &,
                                      const CGAL_VectorH3<FT,RT> & v);

protected:

    CGAL__RepH3<RT>*         ptr() const;

};
@}

@D@<Constructors and destructor@>

@$@<code templates for CGAL_PointH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_PointH3<FT,RT>::CGAL_PointH3()
{
 PTR = new CGAL__RepH3<RT>();
}

template < class FT, class RT >
CGAL_PointH3<FT,RT>::CGAL_PointH3(const CGAL_Origin&)
{
 const RT RT0(0);
 const RT RT1(1);
 PTR = new CGAL__RepH3<RT>( RT0, RT0, RT0, RT1 );
}

template < class FT, class RT >
CGAL_PointH3<FT,RT>::CGAL_PointH3(const CGAL_PointH3<FT,RT>& tbc)
 : CGAL_Handle(tbc)
{
}

template < class FT, class RT >
CGAL_PointH3<FT,RT>::CGAL_PointH3(const CGAL_VectorH3<FT,RT>& v)
 : CGAL_Handle(v)
{
}

template < class FT, class RT >
CGAL_PointH3<FT,RT>::CGAL_PointH3(const RT& x, const RT& y, const RT& z)
{
 PTR = new CGAL__RepH3<RT>(x,y,z, RT(1));
}

template < class FT, class RT >
CGAL_PointH3<FT,RT>::CGAL_PointH3(const RT& x, const RT& y,
                                  const RT& z, const RT& w)
{
 if ( w >= RT(0.0) )
 {
    PTR = new CGAL__RepH3<RT>(x,y,z,w);
 }
 else
 {
    PTR = new CGAL__RepH3<RT>(-x,-y,-z,-w);
 }
}

template < class FT, class RT >
CGAL_PointH3<FT,RT>::~CGAL_PointH3()
{
}

// template < class FT, class RT >
// CGAL_PointH3<FT,RT>::CGAL_PointH3(const CGAL_VectorH3<FT,RT>& v)
//  : CGAL_Handle( (CGAL_Handle&) v)
// {
// }

template < class FT, class RT >
CGAL_PointH3<FT,RT>&
CGAL_PointH3<FT,RT>::operator=(const CGAL_PointH3<FT,RT>& p)
{
 CGAL_Handle::operator=(p);
 return *this;
}

@}

@D@<Access member functions@>
Note that this code works for @{Quotient<RT>@} as well.
A direct constructor call, e.g.\ @{FT( ptr()->hx(), ptr()->hw() )@},
would be more efficient however.

@$@<code templates for CGAL_PointH3<FT,RT>@>+=@{@-
template < class FT, class RT >
FT
CGAL_PointH3<FT,RT>::x()  const
{
 return ( FT(ptr()->hx() ) / FT(ptr()->hw() ));
}


template < class FT, class RT >
FT
CGAL_PointH3<FT,RT>::y()  const
{
 return ( FT(ptr()->hy() ) / FT(ptr()->hw() ));
}

template < class FT, class RT >
FT
CGAL_PointH3<FT,RT>::z()  const
{
 return ( FT(ptr()->hz() ) / FT(ptr()->hw() ));
}

template < class FT, class RT >
RT
CGAL_PointH3<FT,RT>::hx() const
{
 return  ptr()->hx() ;
}

template < class FT, class RT >
RT
CGAL_PointH3<FT,RT>::hy() const
{
 return  ptr()->hy() ;
}

template < class FT, class RT >
RT
CGAL_PointH3<FT,RT>::hz() const
{
 return  ptr()->hz() ;
}

template < class FT, class RT >
RT
CGAL_PointH3<FT,RT>::hw() const
{
 return  ptr()->hw();
}

template < class FT, class RT >
int
CGAL_PointH3<FT,RT>::dimension() const
{
 return 3;
}

template < class FT, class RT >
FT
CGAL_PointH3<FT,RT>::cartesian(int i) const
{
 switch (i)
 {
    case 0:  return x();
    case 1:  return y();
    case 2:  return z();
    default: return cartesian( i%3 );
 }
 return FT( RT() );
}

template < class FT, class RT >
RT
CGAL_PointH3<FT,RT>::homogeneous(int i) const
{
 switch (i)
 {
    case 0:   return hx();
    case 1:   return hy();
    case 2:   return hz();
    case 3:   return hw();
    default:  assert(0);
 }
 return RT();
}

template < class FT, class RT >
FT
CGAL_PointH3<FT,RT>::operator[](int i) const
{
 return cartesian(i);
}
@}

@D@<Further member functions@>

@$@<code templates for CGAL_PointH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_DirectionH3<FT,RT>
CGAL_PointH3<FT,RT>::direction() const
{
 return CGAL_DirectionH3<FT,RT>(*this);
}
@}

@$@<further code templates for CGAL_PointH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_PointH3<FT,RT>
CGAL_PointH3<FT,RT>::transform(const CGAL_Aff_transformationH3<FT,RT>& t) const
{
 return t.transform(*this);
}

template < class FT, class RT >
CGAL_Bbox_3
CGAL_PointH3<FT,RT>::bbox() const
{
// double bx = CGAL_to_double(x());
// double by = CGAL_to_double(y());
// double bz = CGAL_to_double(z());
// return CGAL_Bbox_3(bx, by, bz, bx, by, bz);

 double eps  = double(1.0) /(double(1<<26) * double(1<<26));
 double hxd  = CGAL_to_double( hx() );
 double hyd  = CGAL_to_double( hy() );
 double hzd  = CGAL_to_double( hz() );
 double hwd  = CGAL_to_double( hw() );
 double xmin = ( hxd - eps*hxd ) / ( hwd + eps*hwd );
 double xmax = ( hxd + eps*hxd ) / ( hwd - eps*hwd );
 double ymin = ( hyd - eps*hyd ) / ( hwd + eps*hwd );
 double ymax = ( hyd + eps*hyd ) / ( hwd - eps*hwd );
 double zmin = ( hzd - eps*hzd ) / ( hwd + eps*hwd );
 double zmax = ( hzd + eps*hzd ) / ( hwd - eps*hwd );
 if ( hx() < RT(0)   )
 {
    CGAL_swap(xmin, xmax);
 }
 if ( hy() < RT(0)   )
 {
    CGAL_swap(ymin, ymax);
 }
 if ( hz() < RT(0)   )
 {
    CGAL_swap(zmin, zmax);
 }
 return CGAL_Bbox_3(xmin, ymin, zmin, xmax, ymax, zmax);
}
@}

@D@<Equality and Identity@>

@$@<code templates for CGAL_PointH3<FT,RT>@>+=@{@-
template < class FT, class RT >
bool
CGAL_PointH3<FT,RT>::operator==( const CGAL_PointH3<FT,RT> & p) const
{
 return ( (hx() * p.hw() == p.hx() * hw() )
        &&(hy() * p.hw() == p.hy() * hw() )
        &&(hz() * p.hw() == p.hz() * hw() ) );
}

template < class FT, class RT >
bool
CGAL_PointH3<FT,RT>::operator!=( const CGAL_PointH3<FT,RT> & p) const
{
 return !(*this == p);
}

template < class FT, class RT >
bool
CGAL_PointH3<FT,RT>::identical( const CGAL_PointH3<FT,RT>& p) const
{
 return ::identical(*this,p);
}
@}

@$@<inline code for CGAL_PointH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL__RepH3<RT>*
CGAL_PointH3<FT,RT>::ptr() const
{
 return (CGAL__RepH3<RT>*)PTR;
}
@}

@C@<Class CGAL_VectorH3<FT,RT>@>
@$@<class CGAL_VectorH3<FT,RT>@>==@{@-
template < class FT, class RT >
class CGAL_VectorH3 : public CGAL_Handle
{
public:
          CGAL_VectorH3();
          CGAL_VectorH3(const CGAL_VectorH3<FT,RT> & tbc);
          CGAL_VectorH3(const CGAL_Null_vector&);
          CGAL_VectorH3(const RT& x, const RT& y, const RT& z);
          CGAL_VectorH3(const RT& w, const RT& x, const RT& y, const RT& z);
          ~CGAL_VectorH3();

    CGAL_VectorH3<FT,RT>&
          operator=( const CGAL_VectorH3<FT,RT>& v);

    FT    x()  const;
    FT    y()  const;
    FT    z()  const;
    RT    hx() const;
    RT    hy() const;
    RT    hz() const;
    RT    hw() const;
    FT    cartesian(int i) const;
    RT    homogeneous(int i) const;
    FT    operator[](int i) const;

    int   dimension() const;

    CGAL_DirectionH3<FT,RT>
          direction() const;
    CGAL_VectorH3<FT,RT>
          transform(const CGAL_Aff_transformationH3<FT,RT>& t ) const;

    CGAL_VectorH3<FT,RT>
          operator-() const;

    bool  operator==( const CGAL_VectorH3<FT,RT>& v) const;
    bool  operator!=( const CGAL_VectorH3<FT,RT>& v) const;
    bool  identical ( const CGAL_VectorH3<FT,RT>& v) const;

// undocumented:

          CGAL_VectorH3(const CGAL_PointH3<FT,RT> & p);
          CGAL_VectorH3(const CGAL_DirectionH3<FT,RT> & dir);

// friends:

friend CGAL_VectorH3<FT,RT> operator-( const CGAL_PointH3<FT,RT> &,
                                       const CGAL_Origin & );
friend CGAL_VectorH3<FT,RT> operator-( const CGAL_Origin &,
                                       const CGAL_PointH3<FT,RT> & );
friend CGAL_PointH3<FT,RT>  operator+( const CGAL_Origin &,
                                       const CGAL_VectorH3<FT,RT> & );
friend CGAL_PointH3<FT,RT>  operator-( const CGAL_Origin &,
                                       const CGAL_VectorH3<FT,RT> & );
friend CGAL_VectorH3<FT,RT> operator+( const CGAL_VectorH3<FT,RT> &,
                                       const CGAL_VectorH3<FT,RT> & );
friend CGAL_VectorH3<FT,RT> operator-( const CGAL_VectorH3<FT,RT> &,
                                       const CGAL_VectorH3<FT,RT> & );
friend FT                   operator*( const CGAL_VectorH3<FT,RT> &,
                                       const CGAL_VectorH3<FT,RT> & );
friend CGAL_VectorH3<FT,RT> operator*( const CGAL_VectorH3<FT,RT> &,
                                       const RT & );
friend CGAL_VectorH3<FT,RT> operator*( const RT &,
                                       const CGAL_VectorH3<FT,RT> & );
friend CGAL_VectorH3<FT,RT> operator/( const CGAL_VectorH3<FT,RT> &,
                                       const RT & );
friend CGAL_VectorH3<FT,RT> CGAL_cross_product(const CGAL_VectorH3<FT,RT>& a,
                                               const CGAL_VectorH3<FT,RT>& b);

protected:

    CGAL__RepH3<RT>*    ptr() const;

};
@}

@D@<Constructors and destructor@>

@$@<code templates for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3()
{
 PTR = new CGAL__RepH3<RT>();
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3(const CGAL_VectorH3 & tbc)
 : CGAL_Handle((CGAL_Handle&) tbc)
{
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3(const CGAL_Null_vector&)
{
 PTR = new CGAL__RepH3<RT>( RT(0), RT(0), RT(0), RT(1) );
}


template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3(const CGAL_PointH3<FT,RT> & p)
 : CGAL_Handle( (CGAL_Handle&) p )
{
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3(const CGAL_DirectionH3<FT,RT> & d)
 : CGAL_Handle( (CGAL_Handle&) d )
{
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3(const RT& x, const RT& y,
                                    const RT& z, const RT& w)
{
 if ( w >= RT(0) )
 {
    PTR = new CGAL__RepH3<RT>(x, y, z, w);
 }
 else
 {
    PTR = new CGAL__RepH3<RT>(-x,-y,-z,-w);
 }
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>::CGAL_VectorH3(const RT& x, const RT& y, const RT& z)
{
 PTR = new CGAL__RepH3<RT>(x, y, z, RT(1) );
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>::~CGAL_VectorH3()
{
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT> &
CGAL_VectorH3<FT,RT>::operator=(const CGAL_VectorH3 & v)
{
 CGAL_Handle::operator=(v);
 return *this;
}
@}

@D@<Access member functions@>

@$@<code templates for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
FT
CGAL_VectorH3<FT,RT>::x()  const
{
 return FT(ptr()->hx() )/FT(ptr()->hw() ) ;
}

template < class FT, class RT >
FT
CGAL_VectorH3<FT,RT>::y()  const
{
 return FT(ptr()->hy() )/FT(ptr()->hw() ) ;
}

template < class FT, class RT >
FT
CGAL_VectorH3<FT,RT>::z()  const
{
 return FT(ptr()->hz() )/FT(ptr()->hw() ) ;
}

template < class FT, class RT >
RT
CGAL_VectorH3<FT,RT>::hx() const
{
 return  ptr()->hx() ;
}

template < class FT, class RT >
RT
CGAL_VectorH3<FT,RT>::hy() const
{
 return  ptr()->hy() ;
}

template < class FT, class RT >
RT
CGAL_VectorH3<FT,RT>::hz() const
{
 return  ptr()->hz() ;
}

template < class FT, class RT >
RT
CGAL_VectorH3<FT,RT>::hw() const
{
 return  ptr()->hw() ;
}

template < class FT, class RT >
int
CGAL_VectorH3<FT,RT>::dimension() const
{
 return 3;
}

template < class FT, class RT >
FT
CGAL_VectorH3<FT,RT>::cartesian(int i) const
{
switch (i)
 {
    case 0:   return x();
    case 1:   return y();
    case 2:   return z();
    default: cartesian( i%3 );
 }
 return FT( RT() );
}

template < class FT, class RT >
RT
CGAL_VectorH3<FT,RT>::homogeneous(int i) const
{
 switch (i)
 {
    case 0:   return hx();
    case 1:   return hy();
    case 2:   return hz();
    case 3:   return hw();
    default: assert(0);
 }
 return RT() ;
}
@}

@D@<Further member functions@>
@$@<code templates for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_DirectionH3<FT,RT>
CGAL_VectorH3<FT,RT>::direction() const
{
 return CGAL_DirectionH3<FT,RT>(*this);
}
@}

@$@<further code templates for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_VectorH3<FT,RT>
CGAL_VectorH3<FT,RT>::transform(const CGAL_Aff_transformationH3<FT,RT>&t ) const
{
 return t.transform(*this);
}
@}

@D@<Equality and Identity@>

@$@<code templates for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
bool
CGAL_VectorH3<FT,RT>::operator==( const CGAL_VectorH3& v) const
{
 return ( (hx() * v.hw() == v.hx() * hw() )
        &&(hy() * v.hw() == v.hy() * hw() )
        &&(hz() * v.hw() == v.hz() * hw() ) );
}

template < class FT, class RT >
bool
CGAL_VectorH3<FT,RT>::operator!=( const CGAL_VectorH3& v) const
{
 return !(*this == v);
}

template < class FT, class RT >
bool
CGAL_VectorH3<FT,RT>::identical( const CGAL_VectorH3& v) const
{
 return ( PTR == v.PTR );
}
@}

@D@<Operators@>

@$@<code templates for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
FT
CGAL_VectorH3<FT,RT>::operator[](int i) const
{
 return cartesian(i);
}

template < class FT, class RT >
CGAL_VectorH3<FT,RT>
CGAL_VectorH3<FT,RT>::operator-() const
{
 return CGAL_VectorH3<FT,RT>( - hx(), - hy(), -hz(), hw() );
}
@}


@D@<For internal use only@>

@$@<inline code for CGAL_VectorH3<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL__RepH3<RT>*
CGAL_VectorH3<FT,RT>::ptr() const
{
 return (CGAL__RepH3<RT>*)PTR;
}
@}

@D@<Operations on vectors@>

@$@<vectoroperationsH3@>+=@{@-
template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator+(const CGAL_VectorH3<FT,RT>& u, const CGAL_VectorH3<FT,RT>& v)
{
 return CGAL_VectorH3<FT,RT>(u.hx()*v.hw() + v.hx()*u.hw(),
                             u.hy()*v.hw() + v.hy()*u.hw(),
                             u.hz()*v.hw() + v.hz()*u.hw(),
                             u.hw()*v.hw() );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator-(const CGAL_VectorH3<FT,RT>& u, const CGAL_VectorH3<FT,RT>& v)
{
 return CGAL_VectorH3<FT,RT>(u.hx()*v.hw() - v.hx()*u.hw(),
                             u.hy()*v.hw() - v.hy()*u.hw(),
                             u.hz()*v.hw() - v.hz()*u.hw(),
                             u.hw()*v.hw() );
}

template <class FT, class RT>
FT
operator*(const CGAL_VectorH3<FT,RT>& u, const CGAL_VectorH3<FT,RT>& v)
{
 assert( u.hw() != RT(0) );
 assert( v.hw() != RT(0) );
 return ( FT( u.hx()*v.hx() + u.hy()*v.hy() + u.hz()*v.hz() ) /
          FT( u.hw()*v.hw() ) );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator/(const CGAL_VectorH3<FT,RT>& v, const RT& f)
{
 return CGAL_VectorH3<FT,RT>( v.hx(), v.hy(), v.hz(), v.hw()*f );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator*(const CGAL_VectorH3<FT,RT>& v, const RT& f)
{
 return CGAL_VectorH3<FT,RT>( v.hx()*f, v.hy()*f, v.hz()*f, v.hw() );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator*(const RT& f, const CGAL_VectorH3<FT,RT>& v)
{
 return CGAL_VectorH3<FT,RT>( v.hx()*f, v.hy()*f, v.hz()*f, v.hw() );
}
@}

For threedimensional vectors the cross product is an important
operation.

@$@<vectoroperationsH3@>+=@{@+
template <class FT, class RT>
CGAL_VectorH3<FT,RT>
CGAL_cross_product(const CGAL_VectorH3<FT,RT>& a, const CGAL_VectorH3<FT,RT>& b)
{
 return CGAL_VectorH3<FT,RT>(a.hy()*b.hz() - a.hz()*b.hy(),
                             a.hz()*b.hx() - a.hx()*b.hz(),
                             a.hx()*b.hy() - a.hy()*b.hx(),
                             a.hw()*b.hw() );
}
@}

@D@<Points and Vectors@>

@$@<point and vector interactionH3@>+=@{@-
template <class FT, class RT>
CGAL_PointH3<FT,RT>
operator+(const CGAL_Origin& , const CGAL_VectorH3<FT,RT>& v)
{
 return CGAL_PointH3<FT,RT>( v );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator-(const CGAL_PointH3<FT,RT>& p, const CGAL_Origin& )
{
 return CGAL_VectorH3<FT,RT>( p );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator-(const CGAL_Origin& , const CGAL_PointH3<FT,RT>& p)
{
 return  - CGAL_VectorH3<FT,RT>( p );
}
@}

@$@<addition of points and vectorsH3@>+=@{@-
template <class FT, class RT>
CGAL_PointH3<FT,RT>
operator+(const CGAL_PointH3<FT,RT>& p, const CGAL_VectorH3<FT,RT>& v)
{
 return CGAL_PointH3<FT,RT>(p.hx()*v.hw() + v.hx()*p.hw(),
                            p.hy()*v.hw() + v.hy()*p.hw(),
                            p.hz()*v.hw() + v.hz()*p.hw(),
                            p.hw()*v.hw() );
}

template <class FT, class RT>
CGAL_PointH3<FT,RT>
operator-(const CGAL_PointH3<FT,RT>& p, const CGAL_VectorH3<FT,RT>& v)
{
 return CGAL_PointH3<FT,RT>( p.hx()*v.hw() - v.hx()*p.hw(),
                             p.hy()*v.hw() - v.hy()*p.hw(),
                             p.hz()*v.hw() - v.hz()*p.hw(),
                             p.hw()*v.hw() );
}

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator-(const CGAL_PointH3<FT,RT>& p, const CGAL_PointH3<FT,RT>& q)
{
 return CGAL_PointH3<FT,RT>( p.hx()*q.hw() - q.hx()*p.hw(),
                             p.hy()*q.hw() - q.hy()*p.hw(),
                             p.hz()*q.hw() - q.hz()*p.hw(),
                             p.hw()*q.hw() );
}
@}


@C@<Class CGAL_DirectionH3<FT,RT>@>

@$@<class CGAL_DirectionH3<FT,RT>@>==@{@+

template < class FT, class RT >
class CGAL_DirectionH3 : public CGAL_Handle
{

public:
                 CGAL_DirectionH3();
                 CGAL_DirectionH3(const CGAL_DirectionH3 & tbc );
                 CGAL_DirectionH3(const CGAL_PointH3<FT,RT> & p );
                 CGAL_DirectionH3(const CGAL_VectorH3<FT,RT> & v );
                 CGAL_DirectionH3(const RT& x, const RT& y,
                                  const RT& z, const RT& w = RT(1) );

                 ~CGAL_DirectionH3();

    CGAL_DirectionH3 &
                 operator=(const CGAL_DirectionH3 & d);

    CGAL_DirectionH3
          transform(const CGAL_Aff_transformationH3<FT,RT> &) const ;
    CGAL_DirectionH3
          operator-() const;

    bool  is_degenerate() const;

    bool  operator==( const CGAL_DirectionH3& d) const;
    bool  operator!=( const CGAL_DirectionH3& d) const;
    bool  identical ( const CGAL_DirectionH3& d) const;

    CGAL_VectorH3<FT,RT>    vector() const;

    RT    dx() const;
    RT    dy() const;
    RT    dz() const;
    RT    x()  const;
    RT    y()  const;
    RT    z()  const;
    RT    hx() const;
    RT    hy() const;
    RT    hz() const;

    RT    delta(int i) const;

 friend CGAL_DirectionH3<FT,RT>
          CGAL_cross_product( const CGAL_DirectionH3<FT,RT>& d1,
                              const CGAL_DirectionH3<FT,RT>& d2);

protected:

    CGAL__RepH3<RT>*    ptr()    const;
};
@}

@D@<Constructors and destructor@>

@$@<code templates for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_DirectionH3<FT,RT>::CGAL_DirectionH3()
{
 PTR = new CGAL__RepH3<RT>();
}

template <class FT, class RT >
CGAL_DirectionH3<FT,RT>::CGAL_DirectionH3(const CGAL_DirectionH3 & tbc )
 : CGAL_Handle(tbc)
{
}

template <class FT, class RT >
CGAL_DirectionH3<FT,RT>::CGAL_DirectionH3(const CGAL_PointH3<FT,RT> & p )
 : CGAL_Handle( (CGAL_Handle&) p )
{
}

template <class FT, class RT >
CGAL_DirectionH3<FT,RT>::CGAL_DirectionH3(const CGAL_VectorH3<FT,RT> & v )
 : CGAL_Handle( (CGAL_Handle&) v )
{
}

template <class FT, class RT >
CGAL_DirectionH3<FT,RT>::CGAL_DirectionH3(const RT& x, const RT& y,
                                          const RT& z, const RT& w)
{
 if ( w >= 0 )
 {
    PTR = new CGAL__RepH3<RT>(x,y,z,w);
 }
 else
 {
    PTR = new CGAL__RepH3<RT>(-x,-y,-z,-w);
 }
}

template <class FT, class RT >
CGAL_DirectionH3<FT,RT>::~CGAL_DirectionH3()
{
}

template < class FT, class RT >
CGAL_DirectionH3<FT,RT> &
CGAL_DirectionH3<FT,RT>::operator=(const CGAL_DirectionH3<FT,RT> &d)
{
 CGAL_Handle::operator=(d);
 return *this;
}

@}

@D@<Access member functions@>
@$@<code templates for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::delta(int i) const
{
 switch (i)
 {
    case 0:  return x();
    case 1:  return y();
    case 2:  return z();
    default: return delta( i%3 );
 }
 return  RT() ;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::dx() const
{
 return ptr()->e0;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::x() const
{
 return ptr()->e0;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::hx() const
{
 return ptr()->e0;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::dy() const
{
 return ptr()->e1;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::y() const
{
 return ptr()->e1;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::hy() const
{
 return ptr()->e1;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::dz() const
{
 return ptr()->e2;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::z() const
{
 return ptr()->e2;
}

template <class FT, class RT >
RT
CGAL_DirectionH3<FT,RT>::hz() const
{
 return ptr()->e2;
}
@}

@D@<Further member functions@>
@$@<further code templates for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_DirectionH3<FT,RT>
CGAL_DirectionH3<FT,RT>::transform(const CGAL_Aff_transformationH3<FT,RT>& t)
                                                                          const
{
 return t.transform(*this);
}
@}

@D@<Equality and Identity@>

@$@<code templates for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
bool
CGAL_DirectionH3<FT,RT>::operator==( const CGAL_DirectionH3& d) const
{
 return ( ( ptr()->hx()*d.ptr()->hy() == ptr()->hy()*d.ptr()->hx() )
        &&( ptr()->hx()*d.ptr()->hz() == ptr()->hz()*d.ptr()->hx() )
        &&( ptr()->hy()*d.ptr()->hz() == ptr()->hz()*d.ptr()->hy() )
        &&( CGAL_sign( ptr()->hx() ) == CGAL_sign( d.ptr()->hx() ) )
        &&( CGAL_sign( ptr()->hy() ) == CGAL_sign( d.ptr()->hy() ) )
        &&( CGAL_sign( ptr()->hz() ) == CGAL_sign( d.ptr()->hz() ) ) );
}

template <class FT, class RT >
bool
CGAL_DirectionH3<FT,RT>::operator!=( const CGAL_DirectionH3& d) const
{
 return !operator==(d);
}

template <class FT, class RT >
bool
CGAL_DirectionH3<FT,RT>::is_degenerate() const
{
 return ((hx() == RT(0)) && (hy() == RT(0)) && (hz() == RT(0)));
}

template <class FT, class RT >
bool
CGAL_DirectionH3<FT,RT>::identical( const CGAL_DirectionH3& d) const
{
 return ( PTR == d.PTR );
}
@}

@D@<Operators@>
@$@<code templates for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_DirectionH3<FT,RT>
CGAL_DirectionH3<FT,RT>::operator-() const
{
 return CGAL_DirectionH3( - ptr()->hx(), - ptr()->hy(), - ptr()->hz() );
}
@}

@D@<For internal use@>
@$@<inline code for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
inline
CGAL__RepH3<RT>*
CGAL_DirectionH3<FT,RT>::ptr() const
{
 return (CGAL__RepH3<RT>*)PTR;
}
@}

@$@<code templates for CGAL_DirectionH3<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_VectorH3<FT,RT>
CGAL_DirectionH3<FT,RT>::vector() const
{
 return CGAL_VectorH3<FT,RT>(*this);
}
@}

@E@<Cross product@>
@$@<cross product for directionsH3@>==@{@+
template <class FT, class RT>
CGAL_DirectionH3<FT,RT>
CGAL_cross_product( const CGAL_DirectionH3<FT,RT>& d1,
                    const CGAL_DirectionH3<FT,RT>& d2)
{
 return CGAL_cross_product(d1.vector(),d2.vector()).direction();
}
@}

@D@<Header file@>
@O@<../include/CGAL/PVDH3.h@>==@{
@<CGAL notice@>
// Source: PVDH3.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_PVDH3_H
#define CGAL_PVDH3_H
#define CGAL_POINTH3_H
#define CGAL_VECTORH3_H
#define CGAL_DIRECTIONH3_H

#include <CGAL/homogeneous_classes.h>
#include <CGAL/Origin.h>

#include <CGAL/RepH3.h>

@<class CGAL_PointH3<FT,RT>@>
@<class CGAL_VectorH3<FT,RT>@>
@<class CGAL_DirectionH3<FT,RT>@>

@<inline code for CGAL_PointH3<FT,RT>@>
@<inline code for CGAL_VectorH3<FT,RT>@>
@<inline code for CGAL_DirectionH3<FT,RT>@>

@<code templates for CGAL_PointH3<FT,RT>@>
@<code templates for CGAL_VectorH3<FT,RT>@>
@<code templates for CGAL_DirectionH3<FT,RT>@>

@<vectoroperationsH3@>
@<point and vector interactionH3@>
@<addition of points and vectorsH3@>

@<cross product for directionsH3@>

#include <CGAL/Aff_transformationH3.h>

#include <CGAL/Bbox_3.h>
#include <CGAL/misc.h>

@<further code templates for CGAL_PointH3<FT,RT>@>
@<further code templates for CGAL_VectorH3<FT,RT>@>
@<further code templates for CGAL_DirectionH3<FT,RT>@>

template <class FT, class RT>
CGAL_VectorH3<FT,RT>
operator/(const CGAL_VectorH3<FT,RT>& v, const RT& f);

#endif // CGAL_PVDH3_H
@}

@O@<../include/CGAL/PointH3.h@>==@{@-
@<CGAL notice@>
#include <CGAL/PVDH3.h>
@}

@O@<../include/CGAL/VectorH3.h@>==@{@-
@<CGAL notice@>
#include <CGAL/PVDH3.h>
@}

@O@<../include/CGAL/DirectionH3.h@>==@{@-
@<CGAL notice@>
#include <CGAL/PVDH3.h>
@}
