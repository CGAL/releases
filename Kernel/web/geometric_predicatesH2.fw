@A@<(Homogeneous) Geometric Predicates@>
@B@<Geometric predicates on points@>

There are some geometric primitives like orientation or incircle
test that operate on points only.
I added functions that can be used to compare points lexicographically.
Furthermore I added a function computing the sidedness of a point
with respect to the L-wedge (region right of and above) of another point.

@C@<Lexicograpical Order@>

@$@<primitives on homogeneous points@>+=@{@-
template < class FT, class RT>
CGAL_Comparison_result
CGAL_compare_lexicographically_xy(const CGAL_PointH2<FT,RT>& p,
                                  const CGAL_PointH2<FT,RT>& q)
{
 RT pV = p.hx()*q.hw();
 RT qV = q.hx()*p.hw();
 if ( pV == qV )
 {
    pV = p.hy()*q.hw();
    qV = q.hy()*p.hw();
 }
 if ( pV < qV )
 {
    return CGAL_SMALLER;
 }
 else
 {
    return (pV > qV) ? CGAL_LARGER : CGAL_EQUAL;
 }
}


template < class FT, class RT>
bool
CGAL_lexicographically_xy_smaller_or_equal(const CGAL_PointH2<FT,RT>& p,
                                           const CGAL_PointH2<FT,RT>& q)
{
 RT phx = p.hx();
 RT phw = p.hw();
 RT qhx = q.hx();
 RT qhw = q.hw();

 RT pV = phx * qhw;
 RT qV = qhx * phw;
 if ( pV > qV )
 {
    return false;
 }
 else if ( pV < qV )
 {
    return true;
 }
 RT phy = p.hy();
 RT qhy = q.hy();

 pV = phy * qhw;
 qV = qhy * phw;
 return ( pV <= qV );
}


template < class FT, class RT>
bool
CGAL_lexicographically_xy_smaller(const CGAL_PointH2<FT,RT>& p,
                                  const CGAL_PointH2<FT,RT>& q)
{
 RT phx = p.hx();
 RT phw = p.hw();
 RT qhx = q.hx();
 RT qhw = q.hw();

 RT pV = phx * qhw;
 RT qV = qhx * phw;
 if ( pV > qV )
 {
    return false;
 }
 else if ( pV < qV )
 {
    return true;
 }
 RT phy = p.hy();
 RT qhy = q.hy();

 pV = phy * qhw;
 qV = qhy * phw;
 return ( pV < qV );
}

template < class FT, class RT>
CGAL_Comparison_result
CGAL_compare_x(const CGAL_PointH2<FT,RT>& p,
               const CGAL_PointH2<FT,RT>& q)
{
 RT phx = p.hx();
 RT phw = p.hw();
 RT qhx = q.hx();
 RT qhw = q.hw();
 RT com = phx * qhw - qhx * phw;
 if ( com < RT(0) )
 {
    return CGAL_SMALLER;
 }
 else if ( com > RT(0) )
 {
    return CGAL_LARGER;
 }
 return CGAL_EQUAL;
}


template < class FT, class RT>
CGAL_Comparison_result
CGAL_compare_y(const CGAL_PointH2<FT,RT>& p,
               const CGAL_PointH2<FT,RT>& q)
{
 RT phy = p.hy();
 RT phw = p.hw();
 RT qhy = q.hy();
 RT qhw = q.hw();
 RT com = phy * qhw - qhy * phw;
 if ( com < RT(0) )
 {
    return CGAL_SMALLER;
 }
 else if ( com > RT(0) )
 {
    return CGAL_LARGER;
 }
 return CGAL_EQUAL;
}

@}

@C@<Orientation@>

@$@<primitives on homogeneous points@>+=@{@-

template < class FT, class RT>
CGAL_Orientation
CGAL_orientation( const CGAL_PointH2<FT,RT>& p,
                const CGAL_PointH2<FT,RT>& q,
                const CGAL_PointH2<FT,RT>& r)
{
 RT det =    p.hx() * (q.hy()*r.hw() - q.hw()*r.hy() )
           + p.hy() * (q.hw()*r.hx() - q.hx()*r.hw() )
           + p.hw() * (q.hx()*r.hy() - q.hy()*r.hx() );
 if (det == RT(0)  )
 {
 return CGAL_COLLINEAR;
 }
 else
 {
 return det < RT(0)   ? CGAL_CLOCKWISE : CGAL_COUNTERCLOCKWISE;
 }
}


template < class FT, class RT>
bool
CGAL_leftturn( const CGAL_PointH2<FT,RT>& p,
               const CGAL_PointH2<FT,RT>& q,
               const CGAL_PointH2<FT,RT>& r)
{
 return (CGAL_orientation(p,q,r) == CGAL_COUNTERCLOCKWISE);
}


template < class FT, class RT>
bool
CGAL_rightturn( const CGAL_PointH2<FT,RT>& p,
                const CGAL_PointH2<FT,RT>& q,
                const CGAL_PointH2<FT,RT>& r)
{
 return (CGAL_orientation(p,q,r) == CGAL_CLOCKWISE);
}


template < class FT, class RT>
bool
CGAL_collinear( const CGAL_PointH2<FT,RT>& p,
                const CGAL_PointH2<FT,RT>& q,
                const CGAL_PointH2<FT,RT>& r)
{
 return (CGAL_orientation(p,q,r) == CGAL_COLLINEAR);
}
@}

@C@<Incircle Test@>

For more information on the incircle predicate see
Guibas/Stolfi, @/General Subdivisons and Voronoi diagrams@/
(short title) ACM Transactions on Graphics 2(4):74-123, page 107
orientation on paraboloid;
Since we have points with homogeneous representation we have to
multiply every line by (homogenizing coordinate)$^2$

@$@<Determinant computation in in_(oriented)_circle@>@M==@{@-
 CGAL_nondegeneracy_precondition( ! CGAL_collinear(q,r,s) );

 // compute sign of      |qx  qy  qx^2+qy^2  1 |   | a b c d |
 //                      |      --  r  --      | = | e f g h |
 //     determinant      |      --  s  --      | = | i j k l |
 //                      |      --  t  --      |   | m n o p |
 //           where

 RT a = q.hx()*q.hw();
 RT b = q.hy()*q.hw();
 RT c = q.hx()*q.hx() + q.hy()*q.hy();
 RT d = q.hw()*q.hw();

 RT e = r.hx()*r.hw();
 RT f = r.hy()*r.hw();
 RT g = r.hx()*r.hx() + r.hy()*r.hy();
 RT h = r.hw()*r.hw();

 RT i = s.hx()*s.hw();
 RT j = s.hy()*s.hw();
 RT k = s.hx()*s.hx() + s.hy()*s.hy();
 RT l = s.hw()*s.hw();

 RT m = t.hx()*t.hw();
 RT n = t.hy()*t.hw();
 RT o = t.hx()*t.hx() + t.hy()*t.hy();
 RT p = t.hw()*t.hw();

 RT det =   a * ( f*(k*p - l*o) + j*(h*o - g*p) + n*(g*l - h*k) )
          - e * ( b*(k*p - l*o) + j*(d*o - c*p) + n*(c*l - d*k) )
          + i * ( b*(g*p - h*o) + f*(d*o - c*p) + n*(c*h - d*g) )
          - m * ( b*(g*l - h*k) + f*(d*k - c*l) + j*(c*h - d*g) );

 // CGAL_kernel_check( det == CGAL_det4x4_by_formula( a, b, c, d,
 //                                                   e, f, g, h,
 //                                                   i, j, k, l,
 //                                                   m, n, o, p ) );
@}

@$@<primitives on homogeneous points@>+=@{@-
template <class FT, class RT>
CGAL_Bounded_side
CGAL_side_of_bounded_circle( const CGAL_PointH2<FT,RT>& q,
                             const CGAL_PointH2<FT,RT>& r,
                             const CGAL_PointH2<FT,RT>& s,
                             const CGAL_PointH2<FT,RT>& t)
{
@<Determinant computation in in_(oriented)_circle@>

 if ( det == RT(0)   )
 {
    return CGAL_ON_BOUNDARY;
 }
 else
 {
    if (CGAL_orientation(q,r,s) == CGAL_CLOCKWISE)
    {
        det = -det;
    }
    return (det > RT(0)   ) ? CGAL_ON_BOUNDED_SIDE : CGAL_ON_UNBOUNDED_SIDE;
 }
}

template <class FT, class RT>
CGAL_Oriented_side
CGAL_side_of_oriented_circle( const CGAL_PointH2<FT,RT>& q,
                              const CGAL_PointH2<FT,RT>& r,
                              const CGAL_PointH2<FT,RT>& s,
                              const CGAL_PointH2<FT,RT>& t)
{
@<Determinant computation in in_(oriented)_circle@>

 if ( det == RT(0)   )
 {
    return CGAL_ON_ORIENTED_BOUNDARY;
 }
 else
 {
    return (det > RT(0)   ) ? CGAL_ON_POSITIVE_SIDE : CGAL_ON_NEGATIVE_SIDE;
 }
}
@}

@C@<Betweenness@>

These test have three point arguments @{p,q,r@}.
They check whether the middle argument point @{q@} is on the segment
between @{p@} and @{q@}. One version assumes collinearity of the three
points.

@$@<primitives on homogeneous points@>+=@{@-
template <class FT, class RT>
bool
CGAL_collinear_between( const CGAL_PointH2<FT,RT>& p,
                        const CGAL_PointH2<FT,RT>& q,
                        const CGAL_PointH2<FT,RT>& r )
{
 RT phx = p.hx();
 RT phw = p.hw();
 RT qhx = q.hx();
 RT qhw = q.hw();
 RT rhx = r.hx();
 RT rhw = r.hw();

 if ( phx * rhw != rhx * phw )
 {
    return (   ( phx * qhw < qhx * phw)
            &&( qhx * rhw < rhx * qhw))
         ||(   ( phx * qhw > qhx * phw)
            &&( qhx * rhw > rhx * qhw));
 }
 else
 {
    RT phy = p.hy();
    RT qhy = q.hy();
    RT rhy = r.hy();
    return (   ( phy * qhw < qhy * phw)
            &&( qhy * rhw < rhy * qhw))
         ||(   ( phy * qhw > qhy * phw)
            &&( qhy * rhw > rhy * qhw));
 }
}


template <class FT, class RT>
bool
CGAL_between( const CGAL_PointH2<FT,RT>& p,
              const CGAL_PointH2<FT,RT>& q,
              const CGAL_PointH2<FT,RT>& r )
{
 if ( CGAL_collinear(p,q,r) )
 {
    return CGAL_collinear_between(p,q,r);
 }
 else
 {
    return false;
 }
}
@}

@C@<Alignment along axes@>

@$@<primitives on homogeneous points@>+=@{@-
template <class FT, class RT>
bool
CGAL_x_equal( const CGAL_PointH2<FT,RT>& p,
              const CGAL_PointH2<FT,RT>& q )
{
 return ( p.hx()*q.hw() == q.hx()*p.hw() );
}

template <class FT, class RT>
bool
CGAL_y_equal( const CGAL_PointH2<FT,RT>& p,
              const CGAL_PointH2<FT,RT>& q )
{
 return ( p.hy()*q.hw() == q.hy()*p.hw() );
}
@}

@C@<Dominance@>

The basic function for computing dominance of points is called
@{CGAL__where_wrt_L_wedge(p,q)@}.
It returns @{CGAL_ON_POSITIVE_SIDE@} if @{q@} is strictly right of
and above @{p@}. It returns @{CGAL_ON_ORIENTED_BOUNDARY@} if
@{q@} is on the vertical upward ray starting
at @{p@} or on the horizontal ray towards infinity starting at @{p@}, i.e., the
boundary of the L-wedge, and it returns @{CGAL_ON_NEGATIVE_SIDE@} otherwise.

@$@<primitives on homogeneous points@>+=@{@-
template <class FT, class RT>
CGAL_Oriented_side
CGAL__where_wrt_L_wedge( const CGAL_PointH2<FT,RT>& p,
                         const CGAL_PointH2<FT,RT>& q )
{
 int xs = CGAL_sign( q.hx()*p.hw() - p.hx()*q.hw() );  // sign( qx - px )
 int ys = CGAL_sign( q.hy()*p.hw() - p.hy()*q.hw() );  // sign( qy - py )

 if (( xs == -1 ) || ( ys == -1 ))
 {
    return CGAL_ON_NEGATIVE_SIDE;
 }
 if (( xs ==  1 ) && ( ys ==  1 ))
 {
    return CGAL_ON_POSITIVE_SIDE;
 }
 return CGAL_ON_ORIENTED_BOUNDARY;
}
@}

@O@<../include/CGAL/predicates_on_pointsH2.h@>==@{
@<CGAL notice@>

// Source: predicates_on_pointsH2.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_PREDICATES_ON_POINTSH2_H
#define CGAL_PREDICATES_ON_POINTSH2_H

#include <CGAL/PVDH2.h>

@<primitives on homogeneous points@>

#endif // CGAL_PREDICATES_ON_POINTSH2_H
@}

@B@<Predicates on directions@>

@C@<Linear order on directions@>
The function @{CGAL_compare_angles_with_x_axis@} assumes some correspondence
between enumeration types which is checked as a percondition.
If this should not be valid anymore at some time, a switch has to be added
to do the appropriate translation between the enums.

@$@<comparison of homogeneous directions@>==@{@-
template <class FT, class RT>
CGAL_Comparison_result
CGAL_compare_angles_with_x_axis(const CGAL_DirectionH2<FT,RT>& d1,
                                const CGAL_DirectionH2<FT,RT>& d2)
{
 CGAL_kernel_precondition( (
        (CGAL_Comparison_result)CGAL_COUNTERCLOCKWISE == CGAL_LARGER
      &&(CGAL_Comparison_result)CGAL_COLLINEAR        == CGAL_EQUAL
      &&(CGAL_Comparison_result)CGAL_CLOCKWISE        == CGAL_SMALLER ) );

 CGAL_PointH2<FT,RT>   p1 = CGAL_ORIGIN + d1.vector();
 CGAL_PointH2<FT,RT>   p2 = CGAL_ORIGIN + d2.vector();

 CGAL_kernel_precondition( p1.hw() >  RT(0)   );
 CGAL_kernel_precondition( p2.hw() >  RT(0)   );

 int       x_sign1 = CGAL_sign( p1.hx() );
 int       x_sign2 = CGAL_sign( p2.hx() );
 int       y_sign1 = CGAL_sign( p1.hy() );
 int       y_sign2 = CGAL_sign( p2.hy() );

 if ( y_sign1 * y_sign2 < 0)
 {
    return (y_sign1 > 0) ? CGAL_SMALLER : CGAL_LARGER;
 }

 CGAL_PointH2<FT,RT>   origin( RT(0)  , RT(0)   );

 if ( y_sign1 * y_sign2 > 0)
 {
    return ( (CGAL_Comparison_result) CGAL_orientation(origin, p2, p1) );

      // Precondition on the enums:
      // CGAL_COUNTERCLOCKWISE == CGAL_LARGER   ( ==  1 )
      // CGAL_COLLINEAR        == CGAL_EQUAL    ( ==  0 )
      // CGAL_CLOCKWISE        == CGAL_SMALLER  ( == -1 )
 }

 // ( y_sign1 * y_sign2 == 0 )

 bool b1 = (y_sign1 == 0) && (x_sign1 >= 0);
 bool b2 = (y_sign2 == 0) && (x_sign2 >= 0);

 if ( b1 )
 {
    return  b2 ? CGAL_EQUAL : CGAL_SMALLER;
 }
 if ( b2 )
 {
    return  b1 ? CGAL_EQUAL : CGAL_LARGER;
 }
 if ( y_sign1 == y_sign2 )  // == 0
 {
    return CGAL_EQUAL;
 }
 else
 {
    return (CGAL_orientation(origin, p1, p2) == CGAL_COUNTERCLOCKWISE) ?
                                 (CGAL_Comparison_result) CGAL_SMALLER :
                                 (CGAL_Comparison_result) CGAL_LARGER;
 }

}
@}

@O@<../include/CGAL/predicates_on_directionsH2.h@>==@{
@<CGAL notice@>

// Source: predicates_on_directionH2.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_PREDICATES_ON_DIRECTIONSH2_H
#define CGAL_PREDICATES_ON_DIRECTIONSH2_H

#include <CGAL/PVDH2.h>
#include <CGAL/predicates_on_pointsH2.h>

@<comparison of homogeneous directions@>

#endif // CGAL_PREDICATES_ON_DIRECTIONSH2_H
@}
