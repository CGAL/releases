
@! $RCSfile: Aff_transformation_2.fw,v $
@! $Revision: 1.3.1.2 $
@! $Date: 1995/10/18 15:55:21 $

@! Author: Andreas.Fabri@@sophia.inria.fr




@C@<Class CGAL_Aff_transformation_2<R>@>

Here comes the only class visible to the outside. It has a pointer to a
representation, which is chosen appropriately by the constructors.

@$@<class CGAL_Aff_transformation_2<R>@>==@{@-
template < class R >
class CGAL_Aff_transformation_2 : public R::Aff_transformation_2
{
public:
  // default constructor
  CGAL_Aff_transformation_2()
    : R::Aff_transformation_2()
  {}

  // copy constructor
  CGAL_Aff_transformation_2(const CGAL_Aff_transformation_2<R> &t)
    : R::Aff_transformation_2(t)
  {}

  // up cast constructor
  CGAL_Aff_transformation_2(const R::Aff_transformation_2 &t)
    : R::Aff_transformation_2(t)
  {}

  // Translation:
  CGAL_Aff_transformation_2(const CGAL_Translation tag,
                            const CGAL_Vector_2<R> &v)
    : R::Aff_transformation_2(tag, v)
  {}

  // Rational Rotation:
  CGAL_Aff_transformation_2(const CGAL_Rotation tag,
                            const CGAL_Direction_2<R> &d,
                            const R::RT &num,
                            const R::RT &den = R::RT(1))
    : R::Aff_transformation_2(tag, R::Direction_2(d), num, den)
  {}

  CGAL_Aff_transformation_2(const CGAL_Rotation tag,
                            const R::RT &sin,
                            const R::RT &cos,
                            const R::RT &den = R::RT(1))
    : R::Aff_transformation_2(tag, sin, cos, den)
  {}

  // Scaling:
  CGAL_Aff_transformation_2(const CGAL_Scaling tag,
                            const R::RT &s,
                            const R::RT &w= R::RT(1))
    : R::Aff_transformation_2(tag, s, w)
  {}

  // The general case:
  CGAL_Aff_transformation_2(const R::RT & m11,
                            const R::RT & m12,
                            const R::RT & m13,

                            const R::RT & m21,
                            const R::RT & m22,
                            const R::RT & m23,

                            const R::RT &w= R::RT(1))
    : R::Aff_transformation_2(m11, m12, m13,
                              m21, m22, m23,
                              w)
  {}

  CGAL_Aff_transformation_2(const R::RT & m11, const R::RT & m12,
                            const R::RT & m21, const R::RT & m22,
                            const R::RT &w = R::RT(1))
    : R::Aff_transformation_2(m11, m12,
                              m21, m22,
                              w)
  {}

  ~CGAL_Aff_transformation_2()
  {}

  CGAL_Aff_transformation_2<R>& operator=(const CGAL_Aff_transformation_2<R>& t)
  {
    R::Aff_transformation_2::operator=(t);
    return *this;
  }


  CGAL_Point_2<R>     transform(const CGAL_Point_2<R> &p) const
  {
    return R::Aff_transformation_2::transform(p);
  }

  CGAL_Point_2<R>     operator()(const CGAL_Point_2<R> &p) const
  {
    return transform(p);
  }

  CGAL_Vector_2<R>    transform(const CGAL_Vector_2<R> &v) const
  {
    return R::Aff_transformation_2::transform(v);
  }

  CGAL_Vector_2<R>    operator()(const CGAL_Vector_2<R> &v) const
  {
    return transform(v);
  }

  CGAL_Direction_2<R> transform(const CGAL_Direction_2<R> &d) const
  {
    return R::Aff_transformation_2::transform(d);
  }

  CGAL_Direction_2<R> operator()(const CGAL_Direction_2<R> &d) const
  {
    return transform(d);
  }


  CGAL_Line_2<R> transform(const CGAL_Line_2<R> &l) const
  {
#ifndef CGAL_NO_LINE_TRANSFORM_IN_AT
    return R::Aff_transformation_2::transform(l);
#else
    return
      ((const R::Line_2&)l).transform((const R::Aff_transformation_2&)(*this));
#endif // CGAL_NO_LINE_TRANSFORM_IN_AT
  }

  CGAL_Line_2<R> operator()(const CGAL_Line_2<R> &l) const
  {
    return transform(l);
  }



  CGAL_Aff_transformation_2<R>  inverse() const
  {
    return R::Aff_transformation_2::inverse();
  }

  bool                 is_even() const
  {
    return R::Aff_transformation_2::is_even();
  }

  bool                 is_odd() const
  {
    return !is_even();
  }

  CGAL_Aff_transformation_2<R> operator*(
                              const CGAL_Aff_transformation_2<R> &t) const
  {
    return R::Aff_transformation_2::operator*(t);
  }
};
@}


@D@<Header File@>

@O@<../include/CGAL/Aff_transformation_2.h@>==@{@-
@<CGAL notice@>
// Source: Aff_transformation_2.h
// Author: Andreas.Fabri@@sophia.inria.fr

#ifndef CGAL_AFF_TRANSFORMATION_2_H
#define CGAL_AFF_TRANSFORMATION_2_H

#ifdef CGAL_WORKAROUND_015
#define CGAL_NO_LINE_TRANSFORM_IN_AT
#endif // CGAL_WORKAROUND_015

#include <CGAL/Line_2.h>

#ifdef CGAL_HOMOGENEOUS_H
#include <CGAL/Aff_transformationH2.h>
#endif // CGAL_HOMOGENEOUS_H

#ifdef CGAL_CARTESIAN_H
#include <CGAL/Aff_transformationC2.h>
#endif // CGAL_CARTESIAN_H



@<class CGAL_Aff_transformation_2<R>@>


#endif // CGAL_AFF_TRANSFORMATION_2_H
@}

@! $Log: Aff_transformation_2.fw,v $
@! Revision 1.3.1.2  1995/10/18 15:55:21  fabri
@! We removed the functions transpose() and general_form()
@!
@! Revision 1.3.1.1  1995/10/18 15:38:00  fabri
@! We abandonned the idea of multiple classes. This implementation
@! has one single interface class.
@!
@! Revision 1.3  1995/10/09 14:48:34  fabri
@! in this version we have only one class and the called
@! >> constructor leads to different internal representations.
@!
@! Revision 1.2  1995/10/03 09:47:16  fabri
@! now the rotation gets a direction as argument
@!
@! Revision 1.1  1995/10/03 09:45:06  fabri
@! Initial revision
@!
