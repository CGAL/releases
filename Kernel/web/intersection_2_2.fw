
@B@<Intersection of two triangles@>

This is provisional code. The main reason is that there is not yet a polygon
type. The intersection of two triangles can lead to a (convex) polygon of (at
most) six sides. The only way to get this polygon is to ask for all vertices
consecutively.

@O@<../include/CGAL/Triangle_2_Triangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_TRIANGLE_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_TRIANGLE_2_TRIANGLE_2_INTERSECTION_H

#include <CGAL/Segment_2.h>
#include <CGAL/Triangle_2.h>

template <class R>
struct CGAL__Pointlist_2_rec {
    CGAL__Pointlist_2_rec *next;
    CGAL_Point_2<R> point;
    CGAL_Oriented_side side;
};

template <class R>
struct CGAL__Pointlist_2 {
    int size;
    CGAL__Pointlist_2_rec<R> *first;
    CGAL__Pointlist_2() ;
    ~CGAL__Pointlist_2() ;
};

template <class R>
class CGAL_Triangle_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT, TRIANGLE, POLYGON};
                        CGAL_Triangle_2_Triangle_2_pair() ;
                        CGAL_Triangle_2_Triangle_2_pair(
                                CGAL_Triangle_2<R> const *trian1,
                                CGAL_Triangle_2<R> const *trian2) ;
    ~CGAL_Triangle_2_Triangle_2_pair() {}
#ifdef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const
    @<Triangle_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
    bool                intersection(CGAL_Triangle_2<R> &result) const;
    bool                intersection(/*CGAL_Polygon_2<R> &result*/) const;
    int                 vertex_count() const;
    CGAL_Point_2<R>     vertex(int i) const;
protected:
    CGAL_Triangle_2<R> const*   _trian1;
    CGAL_Triangle_2<R> const *  _trian2;
    bool                    _known;
    Intersection_results    _result;
    CGAL__Pointlist_2<R>    _pointlist;
};

@<do_intersect macro@>@(Triangle_2@,Triangle_2@)

@<Triangle_2_Triangle_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr1, const CGAL_Triangle_2<R>&tr2)
{
    typedef CGAL_Triangle_2_Triangle_2_pair<R> is_t;
    is_t ispair(&tr1, &tr2);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    case is_t::POLYGON:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    case is_t::TRIANGLE: {
        CGAL_Triangle_2<R> itr;
        ispair.intersection(itr);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Triangle_2<R> >(itr));
    }
    }
}

#endif
@}

A triangle is a convex polygon. We maintain this convex polygon.
Every edge of the other triangle can be extended to a line.
We cut the maintained polygon consecutively with those three supporting lines.

We direct the lines in such a way that the (second) triangle lies to the left
of them. So, when we look at the maintained polygon, the vertices to the right
should be discarded.

The implementation does not make use of LEDA singly linked lists,
which it should do, probably.

@$@<Triangle_2_Triangle_2_pair implementation@>+=@{

#include <CGAL/Line_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
CGAL__Pointlist_2<R>::CGAL__Pointlist_2()
{
    size = 0;
    first = 0;
}

template <class R>
CGAL__Pointlist_2<R>::~CGAL__Pointlist_2()
{
    CGAL__Pointlist_2_rec<R> *cur;
    for (int i=0; i<size; i++) {
        cur = first;
        first = cur->next;
        delete cur;
    }
}

@}

@$@<Triangle_2_Triangle_2_pair implementation@>+=@{
template <class R>
void CGAL__init_list(CGAL__Pointlist_2<R> &list,
                const CGAL_Triangle_2<R> &trian)
{
    // check on degeneracies of trian.
    if (!trian.is_degenerate()) {
        list.size = 3;
        list.first = 0;
        for (int i=0; i<3; i++) {
            CGAL__Pointlist_2_rec<R> *newrec =
                        new CGAL__Pointlist_2_rec<R>;
            newrec->next = list.first;
            list.first = newrec;
            newrec->point = trian[i];
        }
    } else {
        // CGAL__not_implemented();
        CGAL_kernel_assertion(false);
    }
}
@}

@$@<Triangle_2_Triangle_2_pair implementation@>+=@{
#include <CGAL/Line_2_Line_2_intersection.h>

template <class R>
void CGAL__cut_off(CGAL__Pointlist_2<R> &list,
                const CGAL_Line_2<R> &cutter)
{
    int i;
    int add = 0;
    CGAL__Pointlist_2_rec<R> *cur, *last, *newrec;
    for (i=0, cur = list.first; i<list.size; i++, cur = cur->next) {
        cur->side = cutter.oriented_side(cur->point);
        last = cur;
    }
@}
Add vertices on the cutter.
@$@<Triangle_2_Triangle_2_pair implementation@>+=@{@-
    for (cur = list.first, i=0; i<list.size; i++, cur = cur->next) {
        if ((cur->side == CGAL_ON_POSITIVE_SIDE
             && last->side == CGAL_ON_NEGATIVE_SIDE)
           || (cur->side == CGAL_ON_NEGATIVE_SIDE
               && last->side == CGAL_ON_POSITIVE_SIDE)) {
            // add a vertex after cur
            add++;
            CGAL_Line_2<R> l(cur->point, last->point);
            newrec = new CGAL__Pointlist_2_rec<R>;
            newrec->next = last->next;
            last->next = newrec;
            newrec->side = CGAL_ON_ORIENTED_BOUNDARY;
            CGAL_Line_2_Line_2_pair<R> linepair(&cutter,  &l);
            CGAL_Line_2_Line_2_pair<R>::Intersection_results isr;
            isr = linepair.intersection_type();
            CGAL_kernel_assertion(isr == CGAL_Line_2_Line_2_pair<R>::POINT);
            linepair.intersection(newrec->point);
        }
        last = cur;
    }
    CGAL_kernel_assertion(add <= 2);
@}
remove the vertices on the right side of the line.
@$@<Triangle_2_Triangle_2_pair implementation@>+=@{@-
    CGAL__Pointlist_2_rec<R> **curpt;
    curpt = &list.first;
    while (*curpt != 0) {
        cur = *curpt;
        if (cur->side == CGAL_ON_NEGATIVE_SIDE) {
            add--;
            *curpt = cur->next;
            delete cur;
        } else {
            curpt = &cur->next;
        }
    }
@}
We added two identical points if the original pointlist had two points
and was cut by the cutter. Here we repair this.
@$@<Triangle_2_Triangle_2_pair implementation@>+=@{@-
    if (list.size == 2 && add == 1) {
        add = 0;
        cur = list.first;
        if (cur->side == CGAL_ON_ORIENTED_BOUNDARY) {
            list.first = cur->next;
            delete cur;
        } else {
            last = cur;
            cur = cur->next;
            last->next = cur->next;
            delete cur;
        }
    }
    list.size += add;
}

template <class R>
CGAL_Triangle_2_Triangle_2_pair<R>::
CGAL_Triangle_2_Triangle_2_pair()
{
    _trian1 = 0;
    _trian2 = 0;
    _known = false;
}

template <class R>
CGAL_Triangle_2_Triangle_2_pair<R>::
CGAL_Triangle_2_Triangle_2_pair(CGAL_Triangle_2<R> const *trian1,
         CGAL_Triangle_2<R> const *trian2)
{
    _trian1 = trian1;
    _trian2 = trian2;
    _known = false;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Triangle_2_Triangle_2_pair<R>::Intersection_results
CGAL_Triangle_2_Triangle_2_pair<R>::intersection_type() const
@<Triangle_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005


template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        /* CGAL_Polygon_2<R> &result */) const
{
    if (!_known)
        intersection_type();
    if (_result != TRIANGLE  &&  _result != POLYGON)
        return false;
    CGAL__Pointlist_2_rec<R> *cur;
    int i;
    for (i=0, cur = _pointlist.first;
         i<_pointlist.size;
         i++, cur = cur->next) {
      cout << CGAL_to_double(cur->point.x()) << ' ';
      cout << CGAL_to_double(cur->point.y()) << ' ';
    }
    cout << endl;
    return true;
}

template <class R>
int
CGAL_Triangle_2_Triangle_2_pair<R>::vertex_count() const
{
    CGAL_kernel_assertion(_known);
    return _pointlist.size;
}

template <class R>
CGAL_Point_2<R>
CGAL_Triangle_2_Triangle_2_pair<R>::vertex(int n) const
{
    CGAL_kernel_assertion(_known);
    CGAL_kernel_assertion(n >= 0 && n < _pointlist.size);
    CGAL__Pointlist_2_rec<R> *cur;
    int k;
    for (k=0, cur = _pointlist.first;
         k < n;
         k++, cur = cur->next) {
    }
    return cur->point;
}

template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        CGAL_Triangle_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != TRIANGLE)
        return false;
    result = CGAL_Triangle_2<R>(_pointlist.first->point,
                    _pointlist.first->next->point,
                    _pointlist.first->next->next->point);
    return true;
}

template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        CGAL_Segment_2<R> &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    seg = CGAL_Segment_2<R>(_pointlist.first->point,
                    _pointlist.first->next->point);
    return true;
}

template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = _pointlist.first->point;
    return true;
}

@}

@$@<Triangle_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Triangle_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Triangle_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    if (!CGAL_do_overlap(_trian1->bbox(), _trian2->bbox())) {
        ncthis->_result = NO;
        return _result;
    }
    CGAL__init_list(ncthis->_pointlist, *_trian1);
    if (_trian2->is_degenerate()) {
        // CGAL__not_implemented();
        CGAL_kernel_assertion(false);
    } else {
        CGAL_Line_2<R> l(_trian2->vertex(0), _trian2->vertex(1));
        if (l.oriented_side(_trian2->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
            // counterclockwise triangle
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(1), _trian2->vertex(2));
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(2), _trian2->vertex(0));
            CGAL__cut_off(ncthis->_pointlist, l);
        } else {
            l = l.opposite();
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(0), _trian2->vertex(2));
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(2), _trian2->vertex(1));
            CGAL__cut_off(ncthis->_pointlist, l);
        }
    }
    switch (_pointlist.size) {
    case 0:
        ncthis->_result = NO;
        break;
    case 1:
        ncthis->_result = POINT;
        break;
    case 2:
        ncthis->_result = SEGMENT;
        break;
    case 3:
        ncthis->_result = TRIANGLE;
        break;
    default:
        ncthis->_result = POLYGON;
    }
    return _result;
}
@}



@B@<Intersection of triangle with a line, ray, segment or point@>

@O@<../include/CGAL/Triangle_2_Line_2_intersection.h@>==@{
#include <CGAL/Line_2_Triangle_2_intersection.h>
@}

@O@<../include/CGAL/Line_2_Triangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_LINE_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_LINE_2_TRIANGLE_2_INTERSECTION_H

#include <CGAL/Line_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Triangle_2.h>
#include <CGAL/Point_2.h>

template <class R>
class CGAL_Line_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Line_2_Triangle_2_pair() ;
    CGAL_Line_2_Triangle_2_pair(CGAL_Line_2<R> const *line,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Line_2_Triangle_2_pair() {}
#ifdef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const
    @<Line_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Line_2<R> const*_line;
    CGAL_Triangle_2<R> const *  _trian;
    bool                    _known;
    Intersection_results     _result;
    CGAL_Point_2<R>         _intersection_point;
    CGAL_Point_2<R>         _other_point;
};

@<do_intersect macro@>@(Line_2@,Triangle_2@)

@<Line_2_Triangle_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Line_2_Triangle_2_pair<R> is_t;
    is_t ispair(&line, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Line_2_pair
: public CGAL_Line_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Line_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Line_2<R> const *line) :
                        CGAL_Line_2_Triangle_2_pair<R>(line, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Line_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Line_2<R> &line)
{
    return CGAL_intersection(line, tr);
}
#endif
@}

@$@<Line_2_Triangle_2_pair implementation@>==@{
#include <CGAL/Straight_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
CGAL_Line_2_Triangle_2_pair<R>::
CGAL_Line_2_Triangle_2_pair()
{
    _known = false;
    _line = 0;
    _trian = 0;
}

template <class R>
CGAL_Line_2_Triangle_2_pair<R>::
CGAL_Line_2_Triangle_2_pair(CGAL_Line_2<R> const *line,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _line = line;
    _trian = trian;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Line_2_Triangle_2_pair<R>::Intersection_results
CGAL_Line_2_Triangle_2_pair<R>::intersection_type() const
@<Line_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Line_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Line_2_Triangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Line_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Line_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Line_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    CGAL__Straight_2<R> straight(*_line);
CGAL_Line_2<R> l(_trian->vertex(0), _trian->vertex(1));
if (l.oriented_side(_trian->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
//    if (_trian->is_counterclockwise()) {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(2)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(0)));
    } else {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(0)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(2)));
    }
    switch (straight.current_state()) {
    case CGAL__Straight_2<R>::EMPTY:
        ncthis->_result = NO;
        return _result;
    case CGAL__Straight_2<R>::POINT: {
        straight.current(ncthis->_intersection_point);
        ncthis->_result = POINT;
        return _result;
        }
    case CGAL__Straight_2<R>::SEGMENT: {
        CGAL_Segment_2<R> seg;
        straight.current(seg);
        ncthis->_intersection_point = seg.start();
        ncthis->_other_point = seg.end();
        ncthis->_result = SEGMENT;
        return _result;
        }
    default:  // should not happen.
        CGAL_kernel_assertion(false);
        ncthis->_result = NO;
        return _result;
    }
}
@}

@O@<../include/CGAL/Triangle_2_Ray_2_intersection.h@>==@{
#include <CGAL/Ray_2_Triangle_2_intersection.h>
@}

@O@<../include/CGAL/Ray_2_Triangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_RAY_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_RAY_2_TRIANGLE_2_INTERSECTION_H

#include <CGAL/Segment_2.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Triangle_2.h>
#include <CGAL/Point_2.h>

template <class R>
class CGAL_Ray_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Ray_2_Triangle_2_pair() ;
    CGAL_Ray_2_Triangle_2_pair(CGAL_Ray_2<R> const *ray,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Ray_2_Triangle_2_pair() {}
#ifdef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const
    @<Ray_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Ray_2<R> const* _ray;
    CGAL_Triangle_2<R> const *  _trian;
    bool                    _known;
    Intersection_results     _result;
    CGAL_Point_2<R>         _intersection_point;
    CGAL_Point_2<R>         _other_point;
};

@<do_intersect macro@>@(Ray_2@,Triangle_2@)

@<2D Ray Triangle intersection implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Ray_2<R> &ray, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Ray_2_Triangle_2_pair<R> is_t;
    is_t ispair(&ray, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Ray_2_pair
: public CGAL_Ray_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Ray_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Ray_2<R> const *ray) :
                        CGAL_Ray_2_Triangle_2_pair<R>(ray, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Ray_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Ray_2<R> &ray)
{
    return CGAL_intersection(ray, tr);
}
#endif
@}

@$@<2D Ray Triangle intersection implementation@>==@{

#include <CGAL/Line_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>
#include <CGAL/Straight_2.h>

template <class R>
CGAL_Ray_2_Triangle_2_pair<R>::
CGAL_Ray_2_Triangle_2_pair()
{
    _known = false;
    _ray = 0;
    _trian = 0;
}

template <class R>
CGAL_Ray_2_Triangle_2_pair<R>::
CGAL_Ray_2_Triangle_2_pair(CGAL_Ray_2<R> const *ray,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _ray = ray;
    _trian = trian;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Ray_2_Triangle_2_pair<R>::Intersection_results
CGAL_Ray_2_Triangle_2_pair<R>::intersection_type() const
@<Ray_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Ray_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Ray_2_Triangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Ray_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Ray_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Ray_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    CGAL__Straight_2<R> straight(*_ray);
CGAL_Line_2<R> l(_trian->vertex(0), _trian->vertex(1));
if (l.oriented_side(_trian->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
//    if (_trian->is_counterclockwise()) {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(2)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(0)));
    } else {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(0)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(2)));
    }
    switch (straight.current_state()) {
    case CGAL__Straight_2<R>::EMPTY:
        ncthis->_result = NO;
        return _result;
    case CGAL__Straight_2<R>::POINT: {
        straight.current(ncthis->_intersection_point);
        ncthis->_result = POINT;
        return _result;
        }
    case CGAL__Straight_2<R>::SEGMENT: {
        CGAL_Segment_2<R> seg;
        straight.current(seg);
        ncthis->_intersection_point = seg.start();
        ncthis->_other_point = seg.end();
        ncthis->_result = SEGMENT;
        return _result;
        }
    default:  // should not happen.
        CGAL_kernel_assertion(false);
        ncthis->_result = NO;
        return _result;
    }
}
@}

@O@<../include/CGAL/Triangle_2_Segment_2_intersection.h@>==@{
#include <CGAL/Segment_2_Triangle_2_intersection.h>
@}

@O@<../include/CGAL/Segment_2_Triangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_SEGMENT_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_SEGMENT_2_TRIANGLE_2_INTERSECTION_H

#include <CGAL/Segment_2.h>
#include <CGAL/Triangle_2.h>
#include <CGAL/Point_2.h>

template <class R>
class CGAL_Segment_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Segment_2_Triangle_2_pair() ;
    CGAL_Segment_2_Triangle_2_pair(CGAL_Segment_2<R> const *seg,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Segment_2_Triangle_2_pair() {}
#ifdef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const
    @<Segment_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Segment_2<R> const *  _seg;
    CGAL_Triangle_2<R> const * _trian;
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _intersection_point;
    CGAL_Point_2<R>            _other_point;
};

@<do_intersect macro@>@(Segment_2@,Triangle_2@)

@<Segment_2_Triangle_2_pair implementation@>


#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Segment_2<R> &seg, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Segment_2_Triangle_2_pair<R> is_t;
    is_t ispair(&seg, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Segment_2_pair
: public CGAL_Segment_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Segment_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Segment_2<R> const *seg) :
                        CGAL_Segment_2_Triangle_2_pair<R>(seg, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Segment_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Segment_2<R> &seg)
{
    return CGAL_intersection(seg, tr);
}
#endif
@}

@$@<Segment_2_Triangle_2_pair implementation@>==@{

#include <CGAL/Line_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>
#include <CGAL/Straight_2.h>

template <class R>
CGAL_Segment_2_Triangle_2_pair<R>::
CGAL_Segment_2_Triangle_2_pair()
{
    _known = false;
    _seg = 0;
    _trian = 0;
}

template <class R>
CGAL_Segment_2_Triangle_2_pair<R>::
CGAL_Segment_2_Triangle_2_pair(CGAL_Segment_2<R> const *seg,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _seg = seg;
    _trian = trian;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Segment_2_Triangle_2_pair<R>::Intersection_results
CGAL_Segment_2_Triangle_2_pair<R>::intersection_type() const
@<Segment_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool
CGAL_Segment_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Segment_2_Triangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Segment_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Segment_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Segment_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    CGAL__Straight_2<R> straight(*_seg);
CGAL_Line_2<R> l(_trian->vertex(0), _trian->vertex(1));
if (l.oriented_side(_trian->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(2)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(0)));
    } else {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(0)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(2)));
    }
    switch (straight.current_state()) {
    case CGAL__Straight_2<R>::EMPTY:
        ncthis->_result = NO;
        return _result;
    case CGAL__Straight_2<R>::POINT: {
        straight.current(ncthis->_intersection_point);
        ncthis->_result = POINT;
        return _result;
        }
    case CGAL__Straight_2<R>::SEGMENT: {
        CGAL_Segment_2<R> seg;
        straight.current(seg);
        ncthis->_intersection_point = seg.start();
        ncthis->_other_point = seg.end();
        ncthis->_result = SEGMENT;
        return _result;
        }
    default:  // should not happen.
        CGAL_kernel_assertion(false);
        ncthis->_result = NO;
        return _result;
    }
}
@}


@O@<../include/CGAL/Triangle_2_Point_2_intersection.h@>==@{
#include <CGAL/Point_2_Triangle_2_intersection.h>
@}

@O@<../include/CGAL/Point_2_Triangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_POINT_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_POINT_2_TRIANGLE_2_INTERSECTION_H

#include <CGAL/Point_2.h>
#include <CGAL/Triangle_2.h>
#include <CGAL/Point_2.h>

template <class R>
class CGAL_Point_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT};
    CGAL_Point_2_Triangle_2_pair() ;
    CGAL_Point_2_Triangle_2_pair(CGAL_Point_2<R> const *pt,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Point_2_Triangle_2_pair() {}
#ifdef CGAL_WORKAROUND_005
    Intersection_results intersection_type() const
    @<Point_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
protected:
    CGAL_Point_2<R> const *    _pt;
    CGAL_Triangle_2<R> const * _trian;
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _intersection_point;
    CGAL_Point_2<R>            _other_point;
};

@<do_intersect macro@>@(Point_2@,Triangle_2@)

@<Point_2_Triangle_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Point_2<R> &pt, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Point_2_Triangle_2_pair<R> is_t;
    is_t ispair(&pt, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Point_2_pair
: public CGAL_Point_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Point_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Point_2<R> const *pt) :
                        CGAL_Point_2_Triangle_2_pair<R>(pt, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Point_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Point_2<R> &pt)
{
    return CGAL_intersection(pt, tr);
}

#endif
@}

@$@<Point_2_Triangle_2_pair implementation@>==@{

#include <CGAL/Line_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>
#include <CGAL/Straight_2.h>

template <class R>
CGAL_Point_2_Triangle_2_pair<R>::
CGAL_Point_2_Triangle_2_pair()
{
    _known = false;
    _pt = 0;
    _trian = 0;
}

template <class R>
CGAL_Point_2_Triangle_2_pair<R>::
CGAL_Point_2_Triangle_2_pair(CGAL_Point_2<R> const *pt,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _pt = pt;
    _trian = trian;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Point_2_Triangle_2_pair<R>::Intersection_results
CGAL_Point_2_Triangle_2_pair<R>::intersection_type() const
@<Point_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005



template <class R>
bool
CGAL_Point_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = *_pt;
    return true;
}
@}

@$@<Point_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    typedef CGAL_Line_2<R> line_t;
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Point_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Point_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    if (_trian->has_on_unbounded_side(*_pt)) {
        ncthis->_result = NO;
    } else {
        ncthis->_result = POINT;
    }
    return _result;
/*
    line_t l(_trian->vertex(0), _trian->vertex(1));
    if (l.has_on_positive_side(_trian->vertex(2))) {
        for (int i=0; i<3; i++) {
            if (line_t(_trian->vertex(i), _trian->vertex(i+1)).
                                has_on_negative_side(*_pt)) {
                ncthis->_result = NO;
                return _result;
            }
        }
    } else {
        for (int i=0; i<3; i++)
            if(line_t(_trian->vertex(i), _trian->vertex(i-1)).
                                has_on_negative_side(*_pt)){
                ncthis->_result = NO;
                return _result;
            }
    }
*/
}
@}

@B@<Iso_rectangle Line intersection@>

@O@<../include/CGAL/Iso_rectangle_2_Line_2_intersection.h@>==@{
#include <CGAL/Line_2_Iso_rectangle_2_intersection.h>
@}

@O@<../include/CGAL/Line_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H
#define CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H

#include <CGAL/Line_2.h>
#include <CGAL/Iso_rectangle_2.h>

template <class R>
class CGAL_Line_2_Iso_rectangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Line_2_Iso_rectangle_2_pair() ;
    CGAL_Line_2_Iso_rectangle_2_pair(CGAL_Line_2<R> const *pt,
                            CGAL_Iso_rectangle_2<R> const *iso);
    ~CGAL_Line_2_Iso_rectangle_2_pair() {}
#ifndef CGAL_WORKAROUND_005
  Intersection_results intersection_type() const;
#else
  Intersection_results intersection_type() const
@<Iso_rectangle_2_Line_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Point_2<R>             _ref_point;
    CGAL_Vector_2<R>            _dir;
    CGAL_Point_2<R>             _isomin;
    CGAL_Point_2<R>             _isomax;
    bool                        _known;
    Intersection_results        _result;
    R::FT                       _min, _max;
};

@<do_intersect macro@>@(Line_2@,Iso_rectangle_2@)

@<Line_2_Iso_rectangle_2_pair implementation@>

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Iso_rectangle_2<R>&iso)
{
    typedef CGAL_Line_2_Iso_rectangle_2_pair<R> is_t;
    is_t ispair(&line, &iso);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> ipt;
        ispair.intersection(ipt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(ipt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Iso_rectangle_2_Line_2_pair
: public CGAL_Line_2_Iso_rectangle_2_pair<R> {
public:
    CGAL_Iso_rectangle_2_Line_2_pair(
            CGAL_Iso_rectangle_2<R> const *iso,
            CGAL_Line_2<R> const *line) :
                        CGAL_Line_2_Iso_rectangle_2_pair<R>(line, iso) {}
};

@<do_intersect macro@>@(Iso_rectangle_2@,Line_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Iso_rectangle_2<R>&iso, const CGAL_Line_2<R>&line)
{
    return CGAL_intersection(line, iso);
}

#endif
@}

@$@<Line_2_Iso_rectangle_2_pair implementation@>==@{

#include <CGAL/Line_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
CGAL_Line_2_Iso_rectangle_2_pair<R>::
CGAL_Line_2_Iso_rectangle_2_pair()
{
    _known = false;
}

template <class R>
CGAL_Line_2_Iso_rectangle_2_pair<R>::
CGAL_Line_2_Iso_rectangle_2_pair(CGAL_Line_2<R> const *line,
                            CGAL_Iso_rectangle_2<R> const *iso)
{
    _known = false;
    _ref_point = line->point();
    _dir = line->direction().vector();
    _isomin = iso->min();
    _isomax = iso->max();
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Line_2_Iso_rectangle_2_pair<R>::Intersection_results
CGAL_Line_2_Iso_rectangle_2_pair<R>::intersection_type() const
@<Iso_rectangle_2_Line_2_pair intersection_type body@>
#endif


template <class R>
bool
CGAL_Line_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _ref_point + _min * _dir;
    return true;
}

template <class R>
bool
CGAL_Line_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_ref_point + _min*_dir, _ref_point + _max*_dir);
    return true;
}
@}

The following body of the intersection type member function is used twice.
Once inline (which the g++ compiler wants because of a bug) and once outline.

@$@<Iso_rectangle_2_Line_2_pair intersection_type body@>@M==@{@-
{
    typedef CGAL_Line_2<R> line_t;
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Line_2_Iso_rectangle_2_pair<R> *ncthis =
                (CGAL_Line_2_Iso_rectangle_2_pair<R> *) this;
    ncthis->_known = true;
    typedef R::FT FT;
    bool all_values = true;
    int i;
    for (i=0; i< _ref_point.dimension(); i++) {
        if (_dir.homogeneous(i) == R::RT(0)) {
            if (_ref_point.cartesian(i) < _isomin.cartesian(i)) {
                ncthis->_result = NO;
                return NO;
            }
            if (_ref_point.cartesian(i) > _isomax.cartesian(i)) {
                ncthis->_result = NO;
                return NO;
            }
        } else {
            FT newmin, newmax;
            if (_dir.homogeneous(i) > R::RT(0)) {
                newmin = (_isomin.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomax.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            } else {
                newmin = (_isomax.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomin.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            }
            if (all_values) {
                ncthis->_min = newmin;
                ncthis->_max = newmax;
            } else {
                if (newmin > _min)
                    ncthis->_min = newmin;
                if (newmax < _max)
                    ncthis->_max = newmax;
                if (_max < _min) {
                    ncthis->_result = NO;
                    return NO;
                }
            }
            all_values = false;
        }
    }
    CGAL_kernel_assertion(!all_values);
    if (_max == _min) {
        ncthis->_result = POINT;
        return POINT;
    }
    ncthis->_result = SEGMENT;
    return SEGMENT;
}
@}

@B@<2D Ray Iso_rectangle intersection@>


@O@<../include/CGAL/Iso_rectangle_2_Ray_2_intersection.h@>==@{
#include <CGAL/Ray_2_Iso_rectangle_2_intersection.h>
@}


@O@<../include/CGAL/Ray_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_RAY_2_BBOX_2_INTERSECTION_H
#define CGAL_RAY_2_BBOX_2_INTERSECTION_H

#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Ray_2_Iso_rectangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Ray_2_Iso_rectangle_2_pair() ;
    CGAL_Ray_2_Iso_rectangle_2_pair(CGAL_Ray_2<R> const *ray,
                          CGAL_Iso_rectangle_2<R> const *rect) ;

#ifndef CGAL_WORKAROUND_005
  Intersection_results intersection_type() const;

#else
  Intersection_results intersection_type() const
@<Ray_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                       intersection(
                                    CGAL_Point_2<R> &result) const;
    bool                       intersection(
                                    CGAL_Segment_2<R> &result) const;
protected:
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _ref_point;
    CGAL_Vector_2<R>           _dir;
    CGAL_Point_2<R>            _isomin;
    CGAL_Point_2<R>            _isomax;
    R::FT                     _min,
                               _max;
};

@<do_intersect macro@>@(Ray_2@,Iso_rectangle_2@)

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Ray_2<R> &ray,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    typedef CGAL_Ray_2_Iso_rectangle_2_pair<R> is_t;
    is_t ispair(&ray, &iso);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> ipt;
        ispair.intersection(ipt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(ipt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}


@<Ray_2_Iso_rectangle_2_pair implementation@>

template <class R>
class CGAL_Iso_rectangle_2_Ray_2_pair:
          public CGAL_Ray_2_Iso_rectangle_2_pair<R> {
public:
    CGAL_Iso_rectangle_2_Ray_2_pair() {}
    CGAL_Iso_rectangle_2_Ray_2_pair(CGAL_Iso_rectangle_2<R> const *rect,
                               CGAL_Ray_2<R> const *ray)
                :CGAL_Ray_2_Iso_rectangle_2_pair<R> (ray, rect){}
};

@<do_intersect macro@>@(Iso_rectangle_2@,Ray_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Iso_rectangle_2<R>&iso, const CGAL_Ray_2<R>&ray)
{
    return CGAL_intersection(ray, iso);
}

#endif
@}


@$@<Ray_2_Iso_rectangle_2_pair implementation@>==@{

template <class R>
CGAL_Ray_2_Iso_rectangle_2_pair<R>::CGAL_Ray_2_Iso_rectangle_2_pair()
{
    _known = false;
}

template <class R>
CGAL_Ray_2_Iso_rectangle_2_pair<R>::
CGAL_Ray_2_Iso_rectangle_2_pair(
        CGAL_Ray_2<R> const *ray,
        CGAL_Iso_rectangle_2<R> const *iso)
{
    _known = false;
    _isomin = iso->min();
    _isomax = iso->max();
    _ref_point = ray->start();
    _dir = ray->direction().vector();
    _min = 0;
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Ray_2_Iso_rectangle_2_pair<R>::Intersection_results
CGAL_Ray_2_Iso_rectangle_2_pair<R>::intersection_type() const
@<Ray_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool CGAL_Ray_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    CGAL_Point_2<R> p1(_ref_point + _min*_dir);
    CGAL_Point_2<R> p2(_ref_point + _max*_dir);
    seg = CGAL_Segment_2<R>(p1, p2);
    return true;
}

template <class R> bool CGAL_Ray_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = CGAL_Point_2<R>(_ref_point + _min*_dir);
    return true;
}
@}

@$@<Ray_2_Iso_rectangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    CGAL_Ray_2_Iso_rectangle_2_pair<R> *ncthis =
                (CGAL_Ray_2_Iso_rectangle_2_pair<R> *) this;
    ncthis->_known = true;
    bool to_infinity = true;
    for (int i=0; i<_ref_point.dimension(); i++) {
        if (_dir.homogeneous(i) == R::RT(0)) {
            if (_ref_point.cartesian(i) < _isomin.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
            if (_ref_point.cartesian(i) > _isomax.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
        } else {
            R::FT newmin, newmax;
            if (_dir.homogeneous(i) > R::RT(0)) {
                newmin = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            } else {
                newmin = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            }
            if (newmin > _min)
                ncthis->_min = newmin;
            if (to_infinity) {
                ncthis->_max = newmax;
            } else {
                if (newmax < _max)
                    ncthis->_max = newmax;
            }
            if (_max < _min) {
                ncthis->_result = NO;
                return _result;
            }
            to_infinity = false;
        }
    }
    CGAL_kernel_assertion(!to_infinity);
    if (_max == _min) {
        ncthis->_result = POINT;
        return _result;
    }
    ncthis->_result = SEGMENT;
    return _result;
}
@}


@B@<2D Segment Iso_rectangle intersection@>


@O@<../include/CGAL/Iso_rectangle_2_Segment_2_intersection.h@>==@{
#include <CGAL/Segment_2_Iso_rectangle_2_intersection.h>
@}


@O@<../include/CGAL/Segment_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_SEGMENT_2_BBOX_2_INTERSECTION_H
#define CGAL_SEGMENT_2_BBOX_2_INTERSECTION_H

#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Point_2.h>
#include <CGAL/utils.h>
#include <CGAL/number_utils.h>

template <class R>
class CGAL_Segment_2_Iso_rectangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Segment_2_Iso_rectangle_2_pair() ;
    CGAL_Segment_2_Iso_rectangle_2_pair(CGAL_Segment_2<R> const *seg,
                          CGAL_Iso_rectangle_2<R> const *rect) ;

#ifndef CGAL_WORKAROUND_005
  Intersection_results intersection_type() const;

#else
  Intersection_results intersection_type() const
@<Segment_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

    bool                       intersection(
                                    CGAL_Point_2<R> &result) const;
    bool                       intersection(
                                    CGAL_Segment_2<R> &result) const;
protected:
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _ref_point;
    CGAL_Vector_2<R>           _dir;
    CGAL_Point_2<R>            _isomin;
    CGAL_Point_2<R>            _isomax;
    R::FT                      _min,
                               _max;
};

@<do_intersect macro@>@(Segment_2@,Iso_rectangle_2@)

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Segment_2<R> &seg,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    typedef CGAL_Segment_2_Iso_rectangle_2_pair<R> is_t;
    is_t ispair(&seg, &iso);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> ipt;
        ispair.intersection(ipt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(ipt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}


@<Segment_2_Iso_rectangle_2_pair implementation@>

template <class R>
class CGAL_Iso_rectangle_2_Segment_2_pair:
          public CGAL_Segment_2_Iso_rectangle_2_pair<R> {
public:
    CGAL_Iso_rectangle_2_Segment_2_pair() {}
    CGAL_Iso_rectangle_2_Segment_2_pair(CGAL_Iso_rectangle_2<R> const *rect,
                               CGAL_Segment_2<R> const *seg)
                :CGAL_Segment_2_Iso_rectangle_2_pair<R> (seg, rect){}
};

@<do_intersect macro@>@(Iso_rectangle_2@,Segment_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(
    const CGAL_Iso_rectangle_2<R>&iso,
    const CGAL_Segment_2<R>&seg)
{
    return CGAL_intersection(seg, iso);
}

#endif
@}


@$@<Segment_2_Iso_rectangle_2_pair implementation@>==@{

template <class R>
CGAL_Segment_2_Iso_rectangle_2_pair<R>::CGAL_Segment_2_Iso_rectangle_2_pair()
{
    _known = false;
}

template <class R>
CGAL_Segment_2_Iso_rectangle_2_pair<R>::
CGAL_Segment_2_Iso_rectangle_2_pair(
        CGAL_Segment_2<R> const *seg,
        CGAL_Iso_rectangle_2<R> const *iso)
{
    _known = false;
    _isomin = iso->min();
    _isomax = iso->max();
    _ref_point = seg->source();
    _dir = seg->direction().vector();
    _min = 0;
    int main_dir = (CGAL_abs(_dir.x()) > CGAL_abs(_dir.y()) ) ? 0 : 1;
    _max = (seg->target().cartesian(main_dir)-_ref_point.cartesian(main_dir)) /
            _dir.cartesian(main_dir);
}

#ifndef CGAL_WORKAROUND_005
template <class R>
CGAL_Segment_2_Iso_rectangle_2_pair<R>::Intersection_results
CGAL_Segment_2_Iso_rectangle_2_pair<R>::intersection_type() const
@<Segment_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_WORKAROUND_005

template <class R>
bool CGAL_Segment_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    CGAL_Point_2<R> p1(_ref_point + _min*_dir);
    CGAL_Point_2<R> p2(_ref_point + _max*_dir);
    seg = CGAL_Segment_2<R>(p1, p2);
    return true;
}

template <class R> bool CGAL_Segment_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = CGAL_Point_2<R>(_ref_point + _min*_dir);
    return true;
}
@}

@$@<Segment_2_Iso_rectangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
    CGAL_Segment_2_Iso_rectangle_2_pair<R> *ncthis =
                (CGAL_Segment_2_Iso_rectangle_2_pair<R> *) this;
    ncthis->_known = true;
    for (int i=0; i<_ref_point.dimension(); i++) {
        if (_dir.homogeneous(i) == R::RT(0)) {
            if (_ref_point.cartesian(i) < _isomin.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
            if (_ref_point.cartesian(i) > _isomax.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
        } else {
            R::FT newmin, newmax;
            if (_dir.homogeneous(i) > R::RT(0)) {
                newmin = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            } else {
                newmin = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            }
            if (newmin > _min)
                ncthis->_min = newmin;
            if (newmax < _max)
                ncthis->_max = newmax;
            if (_max < _min) {
                ncthis->_result = NO;
                return _result;
            }
        }
    }
    if (_max == _min) {
        ncthis->_result = POINT;
        return _result;
    }
    ncthis->_result = SEGMENT;
    return _result;
}
@}

@B@<2D Point Iso_rectangle intersection@>

@O@<../include/CGAL/Iso_rectangle_2_Point_2_intersection.h@>==@{
#include <CGAL/Point_2_Iso_rectangle_2_intersection.h>
@}

@O@<../include/CGAL/Point_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H
#define CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H

#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/Point_2.h>


template <class R>
inline bool
CGAL_do_intersect(
    const CGAL_Point_2<R> &pt,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    return !iso.has_on_unbounded_side(pt);
}

#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Point_2<R> &pt,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    if (CGAL_do_intersect(pt,iso)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

template <class R>
inline bool
CGAL_do_intersect(
    const CGAL_Iso_rectangle_2<R> &iso,
    const CGAL_Point_2<R> &pt)
{
    return !iso.has_on_unbounded_side(pt);
}


template <class R>
inline CGAL_Object
CGAL_intersection(
    const CGAL_Iso_rectangle_2<R> &iso,
    const CGAL_Point_2<R> &pt)
{
    if (CGAL_do_intersect(pt, iso)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

#endif
@}

@O@<../include/CGAL/Iso_rectangle_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL notice@>
// Author: Geert-Jan Giezeman

#ifndef CGAL_ISO_RECTANGLE_2_ISO_RECTANGLE_2_INTERSECTION_H
#define CGAL_ISO_RECTANGLE_2_ISO_RECTANGLE_2_INTERSECTION_H

#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/Object.h>

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Iso_rectangle_2<R> &irect1,
    const CGAL_Iso_rectangle_2<R> &irect2)
{
    const CGAL_Point_2<R> &min1 = irect1.min();
    const CGAL_Point_2<R> &min2 = irect2.min();
    const CGAL_Point_2<R> &max1 = irect1.max();
    const CGAL_Point_2<R> &max2 = irect2.max();
    R::FT minx, miny, maxx, maxy;
    CGAL_Point_2<R> newmin;
    CGAL_Point_2<R> newmax;
    minx = (min1.x() >= min2.x()) ? min1.x() : min2.x();
    maxx = (max1.x() <= max2.x()) ? max1.x() : max2.x();
    if (maxx < minx)
        return CGAL_Object();
    miny = (min1.y() >= min2.y()) ? min1.y() : min2.y();
    maxy = (max1.y() <= max2.y()) ? max1.y() : max2.y();
    if (maxy < miny)
        return CGAL_Object();
    if (R::FT_denominator(minx) == R::FT_denominator(miny)) {
        newmin = CGAL_Point_2<R>(R::FT_numerator(minx), R::FT_numerator(miny),
                    R::FT_denominator(minx));
    } else {
        newmin = CGAL_Point_2<R>(R::FT_numerator(minx)*R::FT_denominator(miny),
                    R::FT_numerator(miny)*R::FT_denominator(minx),
                    R::FT_denominator(minx) * R::FT_denominator(miny));
    }
    if (R::FT_denominator(maxx) == R::FT_denominator(maxy)) {
        newmax = CGAL_Point_2<R>(R::FT_numerator(maxx), R::FT_numerator(maxy),
                    R::FT_denominator(maxx));
    } else {
        newmax = CGAL_Point_2<R>(R::FT_numerator(maxx)*R::FT_denominator(maxy),
                    R::FT_numerator(maxy)*R::FT_denominator(maxx),
                    R::FT_denominator(maxx) * R::FT_denominator(maxy));
    }
    return CGAL_make_object(CGAL_Iso_rectangle_2<R>(newmin, newmax));
}

template <class R>
inline bool
CGAL_do_intersect(
    const CGAL_Iso_rectangle_2<R> &irect1,
    const CGAL_Iso_rectangle_2<R> &irect2)
{
    CGAL_Object obj(CGAL_intersection(rect1, rect2));
    CGAL_Iso_rectangle_2<R> irect;
    return (CGAL_assign(irect, obj));
}

#endif
@}


@B@<Packing intersections together@>

@O@<../include/CGAL/intersection_2_2.h@>==@{@-
@<CGAL notice@>
// Author: Geert-Jan Giezeman


#ifndef CGAL_INTERSECTION_2_2_H
#define CGAL_INTERSECTION_2_2_H

#include <CGAL/Triangle_2_Triangle_2_intersection.h>
#include <CGAL/Triangle_2_Line_2_intersection.h>
#include <CGAL/Triangle_2_Ray_2_intersection.h>
#include <CGAL/Triangle_2_Segment_2_intersection.h>
#include <CGAL/Line_2_Iso_rectangle_2_intersection.h>
#include <CGAL/Ray_2_Iso_rectangle_2_intersection.h>
#include <CGAL/Segment_2_Iso_rectangle_2_intersection.h>
#include <CGAL/Point_2_Iso_rectangle_2_intersection.h>
#include <CGAL/Iso_rectangle_2_Iso_rectangle_2_intersection.h>

#endif
@}

