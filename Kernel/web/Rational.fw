@! $RCSfile: Rational.fw,v $
@! $Revision: 1.1 $
@! $Date: 1996/03/13 15:32:23 $

@B@<Rational Numbers@>

\leda\ provides a number type rational. We need some more functions
defined for number types.  We derive from rational as we might add
member functions.


@C@<Source File@>

@O@<../src/Rational.C@>==@{@-
@<CGAL notice@>
// Source: Rational.C
// Author: Andreas.Fabri@@sophia.inria.fr

#include <CGAL/Rational.h>

double CGAL_to_double(const CGAL_Rational &r)
{
  //  the followng is wrong:
  //  return r.numerator().todouble()/r.denominator().todouble();
  return r.todouble();
}

bool CGAL_is_finite(const CGAL_Rational &)
{
  return true;
}

bool CGAL_is_valid(const CGAL_Rational &)
{
  return true;
}
@}

@C@<Header File@>

@O@<../include/CGAL/Rational.h@>==@{@-
@<CGAL notice@>
// Source: Rational.h
// Author: Andreas.Fabri@@sophia.inria.fr
#ifndef CGAL_RATIONAL_H
#define CGAL_RATIONAL_H

#include <CGAL/misc.h>
#include <LEDA/rational.h>

#include <LEDA/REDEFINE_NAMES.h>
typedef rational CGAL_Rational;
#include <LEDA/UNDEFINE_NAMES.h>

/*
class  CGAL_Rational : public rational
{
public:
  CGAL_Rational()
  {}

 CGAL_Rational(double d)
   : rational(d)
  {}

  CGAL_Rational(int i)
   : rational(i)
  {}

  CGAL_Rational(int m, int n)
   : rational(m, n)
  {}

  CGAL_Rational(integer a)
   : rational(a)
  {}

  CGAL_Rational(integer a, integer b)
   : rational(a, b)
  {}

};
*/
extern double CGAL_to_double(const CGAL_Rational &r);

extern bool CGAL_is_finite(const CGAL_Rational &);

extern bool CGAL_is_valid(const CGAL_Rational &);
#endif  // CGAL_RATIONAL_H
@}
