
@! test_kernel_3.fw
@! Author: Stefan Schirra
@A@<Tests for three dimensional CGAL@>
The testfiles generated by this webfile contain checks for
the three-dimensional kernel classes via the representation class.
The file checks methods only that are public and specified.
They can be used to test both homogeneous and Cartesian
implementation.
Additional internal functionality is checked elsewhere, such that
this test can be used for representations others than @{CGAL_Homogeneous@}
and @{CGAL_Cartesian@}.
Every public member function is called at least once.
There is no proof for completeness of the test. All test uses
integers only. All class tests are prefixed by @{CGAL__test_cls@},
tests testing global functions are prefixed by @{CGAL__test_fct@}.
Transformations are tested in @{test_cls_aff_transformation(R)@};
besides (in-)equality and assignment operators are tested in
@{CGAL__test_fct@}.

@B@<Vector_3@>
We start with vectors. The choice of the numbers of type @{R::RT@} ensures
that even the Cartesian coordinates are integral. Checking the access to
homogeneous coordinates is dangerous, since homogeneous coordinates are
not unique. The specification should guarantee that the return homogeneous
coordinates are valid, if they are accessed in a non-interrupted sequence.

@O@<../test/include/CGAL/_test_cls_vector_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/user_classes.h>
#include <CGAL/Vector_3_rft_wrapper.h>
#include <CGAL/Vector_3.h>

template <class R> bool CGAL__test_cls_vector_3(const R& );
@}

{
@O@<../test/include/CGAL/_test_cls_vector_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_VECTOR_3_CC
#define CGAL__TEST_CLS_VECTOR_3_CC
#include <CGAL/_test_cls_vector_3.h>

template <class R>
bool
CGAL__test_cls_vector_3(const R& )
{
 cout << "Testing class Vector_3" ;

 R::Vector_3       iv;

 CGAL_Vector_3<R>  v1;
 CGAL_Vector_3<R>  v2(iv);
 CGAL_Vector_3<R>  v0(CGAL_NULL_VECTOR);

 R::RT  n1( 12 );
 R::RT  n2( -4 );
 R::RT  n3(  6 );
 R::RT  n4(  2 );

 CGAL_Vector_3<R>  v3(n1, n2, n3);
 CGAL_Vector_3<R>  v4(n1, n2, n3, n4);
 CGAL_Vector_3<R>  v5(n1, n2, n3, n4);
 CGAL_Vector_3<R>  v6( v5 );
                   v1 = v4;
 CGAL_Vector_3<R>  v7(-n1, -n2, -n3, -n4);

 cout << '.';

 assert( v4 == v5 );
 assert( v5 == v6 );
 assert( v4 == v6 );
 assert( v1 == v6 );
 assert( v0 == CGAL_NULL_VECTOR);
 assert( v5 == v7 );

 assert( v3 != v4 );
 assert( v0 != v1 );
 assert( v1 != CGAL_NULL_VECTOR);

 assert( v3.hx() == n1 );   // don't replace v3
 assert( v3.hy() == n2 );
 assert( v3.hz() == n3 );

 assert( R::FT( v5.hx()) / R::FT(v5.hw()) == R::FT( n1) / R::FT( n4) );
 assert( R::FT( v5.hy()) / R::FT(v5.hw()) == R::FT( n2) / R::FT( n4) );
 assert( R::FT( v5.hz()) / R::FT(v5.hw()) == R::FT( n3) / R::FT( n4) );

 assert( v5.x() == R::FT( n1) / R::FT( n4) );
 assert( v5.y() == R::FT( n2) / R::FT( n4) );
 assert( v5.z() == R::FT( n3) / R::FT( n4) );

 cout << '.';

 assert( v3.homogeneous(0) == v3.hx() );  // don't replace v3
 assert( v3.homogeneous(1) == v3.hy() );
 assert( v3.homogeneous(2) == v3.hz() );
 assert( v3.homogeneous(3) == v3.hw() );
 assert( v6.cartesian(0) == v6.x() );
 assert( v6.cartesian(1) == v6.y() );
 assert( v6.cartesian(2) == v6.z() );

 cout << '.';

 assert( v0.dimension() == 3 );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_VECTOR_3_CC
@}

@O@<../test/include/CGAL/_test_fct_vector_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Vector_3.h>

template <class R> bool CGAL__test_fct_vector_3(const R& );
@}

@O@<../test/include/CGAL/_test_fct_vector_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_VECTOR_3_CC
#define CGAL__TEST_FCT_VECTOR_3_CC
#include <CGAL/_test_fct_vector_3.h>

template <class R>
bool
CGAL__test_fct_vector_3(const R& )
{
 cout << "Testing functions Vector_3" ;

 R::RT  n1( 12 );
 R::RT  n2( -4 );
 R::RT  n3(  6 );
 R::RT  n4(  2 );
 R::RT  n5(  9 );
 R::RT  n6(-18 );
 R::RT  n7( 36 );
 R::RT  n8(  3 );
 R::RT  n9( 15 );
 R::RT n10( -8 );

 CGAL_Vector_3<R>  v0(CGAL_NULL_VECTOR);
 CGAL_Vector_3<R>  v1(n1, n2, n3, n4);
 CGAL_Vector_3<R>  v2(n5, n6, n7, n8);
 CGAL_Vector_3<R>  v3(n5, n10, n9);
 CGAL_Vector_3<R>  v4(n8, -n2, -n5);
 CGAL_Vector_3<R> mv4(-n8, n2, n5);

 assert( v1 + v2 == v3 );
 assert( v1 - v2 == v4 );
 assert( v3 - v1 == v2 );
 assert( v3 - v2 == v1 );
 assert( v4 + v2 == v1 );
 assert( v4 + v2 == v3 - v2);

 cout << '.';

 assert( (-(- v1)) == v1 );
 assert( -v4 == mv4);
 assert( mv4 == v2 - v1);
 assert( -( v1 - v2) == mv4);
 assert( v1 + v0 == v1 );
 assert( v0 - v4 == mv4 );
 assert( v0 + v4 == v4 );
 assert( v2 - v0 == v2 );

 cout << '.';

#ifdef CGAL_VECTOR_WRAPPER
 assert( R::FT(v1 * v2) == R::FT(66) );
 assert( R::FT(v1 * v0) == R::FT(0) );
 assert( CGAL_Vector_3<R>( n1, n2, n3) == R::RT(2) * v1 );
 assert( CGAL_Vector_3<R>( n5, n6, n7) == R::RT(3) * v2 );
 assert( v2 / R::RT(3) == CGAL_Vector_3<R>( R::RT(1), -n4, -n2) );
 assert( (CGAL_Vector_3<R>&)(R::RT(3) * (v2 / R::RT(3))) == v2 );
 assert( (v2 * R::RT(3)) / R::RT(3) == v2 );
#else // no multiplication scalar * vector ( only from the right side )
 assert( v1 * v2 == R::FT(66) );
 assert( v1 * v0 == R::FT(0) );
 assert( CGAL_Vector_3<R>( n1, n2, n3) == v1 * R::RT(2));
 assert( CGAL_Vector_3<R>( n5, n6, n7) == v2 * R::RT(3));
 assert( v2 / R::RT(3) == CGAL_Vector_3<R>( R::RT(1), -n4, -n2) );
 assert( (v2 * R::RT(3)) / R::RT(3) == v2 );
 assert( (v2 / R::RT(3)) * R::RT(3) == v2 );
#endif // CGAL_VECTOR_WRAPPER

 cout << '.';

 assert( v2.cartesian(0) == v2[0] );
 assert( v2.cartesian(1) == v2[1] );
 assert( v2.cartesian(2) == v2[2] );


 CGAL_Point_3<R> p0(CGAL_ORIGIN);
 CGAL_Point_3<R> p1 = CGAL_ORIGIN + v1;
 CGAL_Point_3<R> p2 = CGAL_ORIGIN + v2;
 CGAL_Point_3<R> p3 = CGAL_ORIGIN + v3;

 assert( CGAL_ORIGIN + v2 == CGAL_Point_3<R>( n5, n6, n7, n8) );
 assert( CGAL_ORIGIN - v2 == CGAL_Point_3<R>( -n5, -n6, -n7, n8) );
 assert( p1 - p1 == v0 );
 assert( p1 - p0 == p1 - CGAL_ORIGIN);
 assert( p1 - p2 == v4 );
 assert( p2 + v4 == p1 );
 assert( p3 - v1 == p2 );
 assert( p3 - p1 == v2 );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_VECTOR_3_CC
@}

@B@<Point_3@>
The test is very similar to the test for vectors, the numbers are
different.

@O@<../test/include/CGAL/_test_cls_point_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_3.h>

template <class R> bool CGAL__test_cls_point_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_point_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_POINT_3_CC
#define CGAL__TEST_CLS_POINT_3_CC
#include <CGAL/_test_cls_point_3.h>

template <class R>
bool
CGAL__test_cls_point_3(const R& )
{
 cout << "Testing class Point_3" ;

 R::Point_3       ip;

 CGAL_Point_3<R>  p1;
 CGAL_Point_3<R>  p2(ip);
 CGAL_Point_3<R>  p0(CGAL_ORIGIN);

 R::RT  n1(-35 );
 R::RT  n2( 50 );
 R::RT  n3(-20 );
 R::RT  n4(  5 );

 CGAL_Point_3<R>  p3(n1, n2, n3);
 CGAL_Point_3<R>  p4(n1, n2, n3, n4);
 CGAL_Point_3<R>  p5(n1, n2, n3, n4);
 CGAL_Point_3<R>  p6( p5 );
                  p1 = p4;

 cout << '.';

 assert( p4 == p5 );
 assert( p5 == p6 );
 assert( p4 == p6 );
 assert( p1 == p6 );
 assert( p0 == CGAL_ORIGIN);

 assert( p3 != p4 );
 assert( p0 != p1 );
 assert( p1 != CGAL_ORIGIN);

 assert( p3.hx() == n1 );   // don't replace p3
 assert( p3.hy() == n2 );
 assert( p3.hz() == n3 );

 assert( R::FT(p5.hx()) / R::FT(p5.hw()) == R::FT( n1) / R::FT( n4) );
 assert( R::FT(p5.hy()) / R::FT(p5.hw()) == R::FT( n2) / R::FT( n4) );
 assert( R::FT(p5.hz()) / R::FT(p5.hw()) == R::FT( n3) / R::FT( n4) );

 assert( p5.x() == R::FT( n1) / R::FT( n4 ) );
 assert( p5.y() == R::FT( n2) / R::FT( n4 ) );
 assert( p5.z() == R::FT( n3) / R::FT( n4 ) );

 cout << '.';

 assert( p3.homogeneous(0) == p3.hx() );  // don't replace p3
 assert( p3.homogeneous(1) == p3.hy() );
 assert( p3.homogeneous(2) == p3.hz() );
 assert( p3.homogeneous(3) == p3.hw() );
 assert( p6.cartesian(0) == p6.x() );
 assert( p6.cartesian(1) == p6.y() );
 assert( p6.cartesian(2) == p6.z() );

 cout << '.';

 assert( p0.dimension() == 3 );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_POINT_3_CC
@}

@O@<../test/include/CGAL/_test_fct_point_vector_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_3.h>
#include <CGAL/Vector_3.h>

template <class R> bool CGAL__test_fct_point_vector_3(const R& );
@}

@O@<../test/include/CGAL/_test_fct_point_vector_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_POINT_VECTOR_3_CC
#define CGAL__TEST_FCT_POINT_VECTOR_3_CC
#include <CGAL/_test_fct_point_vector_3.h>

template <class R>
bool
CGAL__test_fct_point_vector_3(const R& )
{
 cout << "Testing functions Point_3 Vector_3" ;

 R::RT  n1( 12 );
 R::RT  n2( -4 );
 R::RT  n3(  6 );
 R::RT  n4(  2 );
 R::RT  n5(  9 );
 R::RT  n6(-18 );
 R::RT  n7( 36 );
 R::RT  n8(  3 );
 R::RT  n9( 15 );
 R::RT n10( -8 );

 CGAL_Vector_3<R>  v0(CGAL_NULL_VECTOR);
 CGAL_Vector_3<R>  v1(n1, n2, n3, n4);
 CGAL_Vector_3<R>  v2(n5, n6, n7, n8);
 CGAL_Vector_3<R>  v3(n5, n10, n9);
 CGAL_Vector_3<R>  v4(n8, -n2, -n5);

 cout << '.';

 CGAL_Point_3<R> p0(CGAL_ORIGIN);
 CGAL_Point_3<R> p1 = CGAL_ORIGIN + v1;
 CGAL_Point_3<R> p2 = CGAL_ORIGIN + v2;
 CGAL_Point_3<R> p3 = CGAL_ORIGIN + v3;

 assert( CGAL_ORIGIN + v2 == CGAL_Point_3<R>( n5, n6, n7, n8) );
 assert( CGAL_ORIGIN - v2 == CGAL_Point_3<R>( -n5, -n6, -n7, n8) );
 assert( p1 - p1 == v0 );
 assert( p1 - p0 == p1 - CGAL_ORIGIN);
 assert( p1 - p2 == v4 );
 assert( p2 + v4 == p1 );
 assert( p3 - v1 == p2 );
 assert( p3 - p1 == v2 );

 cout << "..";
 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_POINT_VECTOR_3_CC
@}

The following is based on @{predicates_on_points_3.h@}.
@O@<../test/include/CGAL/_test_fct_point_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_3.h>
#include <CGAL/Vector_3.h>
#include <CGAL/predicates_on_points_3.h>

template <class R> bool CGAL__test_fct_point_3(const R& );
@}

@O@<../test/include/CGAL/_test_fct_point_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_FCT_POINT_3_CC
#define CGAL__TEST_FCT_POINT_3_CC
#include <CGAL/_test_fct_point_3.h>

template <class R>
bool
CGAL__test_fct_point_3(const R& )
{
 cout << "Testing functions Point_3" ;

 CGAL_Point_3<R> p1( R::RT(18), R::RT(15), R::RT(-21), R::RT(3) );
 CGAL_Point_3<R> p2( R::RT(18), R::RT(15), R::RT( 12), R::RT(3) );
 CGAL_Point_3<R> p3( R::RT(18), R::RT(12), R::RT(-21), R::RT(3) );
 CGAL_Point_3<R> p4( R::RT(28), R::RT(40), R::RT( 20), R::RT(4) );
 CGAL_Point_3<R> p5( R::RT(12), R::RT(-4), R::RT(-20), R::RT(4) );

 assert( CGAL_compare_lexicographically_xyz(p1,p2) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xyz(p3,p2) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xyz(p3,p1) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xyz(p3,p2) == CGAL_SMALLER );
 assert( CGAL_compare_lexicographically_xyz(p2,p1) == CGAL_LARGER );
 assert( CGAL_compare_lexicographically_xyz(p2,p3) == CGAL_LARGER );
 assert( CGAL_compare_lexicographically_xyz(p4,p3) == CGAL_LARGER );
 assert( CGAL_compare_lexicographically_xyz(p4,p4) == CGAL_EQUAL );

 assert( CGAL_lexicographically_xyz_smaller_or_equal(p1,p1) );
 assert( CGAL_lexicographically_xyz_smaller_or_equal(p3,p1) );
 assert( CGAL_lexicographically_xyz_smaller_or_equal(p3,p2) );
 assert( CGAL_lexicographically_xyz_smaller_or_equal(p3,p4) );

 assert( !CGAL_lexicographically_xyz_smaller(p3,p3) );
 assert( CGAL_lexicographically_xyz_smaller(p3,p2) );
 assert( !CGAL_lexicographically_xyz_smaller(p4,p3) );

 assert( CGAL_x_equal(p1,p1) );
 assert( CGAL_x_equal(p2,p3) );
 assert( !CGAL_x_equal(p2,p4) );

 assert( CGAL_y_equal(p1,p2) );
 assert( !CGAL_y_equal(p1,p3) );

 assert( CGAL_z_equal(p1,p3) );
 assert( !CGAL_z_equal(p4,p5) );

 cout <<'.';

 CGAL_Point_3<R> p6 ( R::RT(6), R::RT(4), R::RT(7) );
 assert( CGAL_coplanar( p1, p2, p3, p6) );
 assert( CGAL_coplanar( p1, p1, p3, p4) );
 assert( CGAL_coplanar( p4, p1, p5, p5 + (p4-p1) ) );
 assert( !CGAL_coplanar( p4, p1, p2, p3 ) );

 assert( !CGAL_collinear( p1, p2, p3 ) );
 assert( CGAL_collinear( p1, p2, p2 + (p2-p1) ) );

 assert( CGAL_between( p1, p2 + (p2-p1), p2 ) );
 assert( !CGAL_between( p1, p2, p2 + (p2-p1)) );
 assert( !CGAL_between( p1, p2, p5 ) );

 assert( CGAL_collinear_between( p1, p2 + (p2-p1), p2 ) );
 assert( !CGAL_collinear_between( p1, p2, p2 + (p2-p1)) );

 cout << '.';

 CGAL_Point_3<R> pe0( R::RT(1), R::RT(0), R::RT(0) );
 CGAL_Point_3<R> pe1( R::RT(0), R::RT(1), R::RT(0) );
 CGAL_Point_3<R> pe2( R::RT(0), R::RT(0), R::RT(1) );

 assert( CGAL_orientation( CGAL_Point_3<R>(CGAL_ORIGIN), pe0, pe1, pe2 ) \
                           == CGAL_POSITIVE);

 assert( CGAL_orientation( p1, p2, p3, p6 ) == CGAL_ZERO );

 CGAL_Point_3<R> p7( R::RT(-8), R::RT(0), R::RT(0), R::RT(-2) );
 CGAL_Point_3<R> p8( R::RT(8), R::RT(4), R::RT(0), R::RT(2) );
 CGAL_Point_3<R> p9( R::RT(0), R::RT(12), R::RT(0), R::RT(4) );

 assert( CGAL_orientation( p7, p8, p9, p4) == CGAL_POSITIVE );
 assert( CGAL_orientation( p7, p9, p8, p5) == CGAL_POSITIVE );
 assert( CGAL_orientation( p7, p8, p9, p5) == CGAL_NEGATIVE );
 assert( CGAL_orientation( p8, p7, p9, p4) == CGAL_NEGATIVE );

 cout <<'.';

 CGAL_Point_3<R> p10( R::RT(0), R::RT(0), R::RT(16), R::RT(8) );

#ifdef CGAL_CARTESIAN // not yet implemented for HOMOGENEOUS

 assert( CGAL_side_of_bounded_sphere(p7,p8,p9,p10,p1) ==CGAL_ON_UNBOUNDED_SIDE);
 assert( CGAL_side_of_bounded_sphere(p7,p8,p9,p10,p1) ==CGAL_ON_UNBOUNDED_SIDE);

 CGAL_Point_3<R> p0(CGAL_ORIGIN);

 assert( CGAL_side_of_bounded_sphere(p7,p8,p9,p10,p0) ==CGAL_ON_BOUNDED_SIDE);

 CGAL_Vector_3<R> v001( R::RT(0), R::RT(0), R::RT(1) );
 CGAL_Vector_3<R> v010( R::RT(0), R::RT(1), R::RT(0) );
 CGAL_Vector_3<R> v100( R::RT(1), R::RT(0), R::RT(0) );

 assert( CGAL_side_of_bounded_sphere(p3 + v001, p3-v001, p3+v010, p3-v010, \
                                     p3 + v100) == CGAL_ON_BOUNDARY );

#endif // CGAL_CARTESIAN

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_FCT_POINT_3_CC
@}

For convenience, we provide a function for testing all of
points, vectors, and directions.
@O@<../test/include/CGAL/_test_pvd_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_PVD_3_CC
#define CGAL__TEST_PVD_3_CC

#include <CGAL/_test_cls_vector_3.cc>
#include <CGAL/_test_fct_vector_3.cc>
#include <CGAL/_test_cls_point_3.cc>
#include <CGAL/_test_fct_point_vector_3.cc>
#include <CGAL/_test_fct_point_3.cc>
#include <CGAL/_test_cls_direction_3.cc>

template <class R>
bool
CGAL__test_pvd_3(const R& r)
{
 return
    CGAL__test_cls_vector_3(r)
 && CGAL__test_fct_vector_3(r)
 && CGAL__test_cls_point_3(r)
 && CGAL__test_fct_point_vector_3(r)
 && CGAL__test_fct_point_3(r)
 && CGAL__test_cls_direction_3(r) ;
}
#endif // CGAL__TEST_PVD_3_CC
@}

@B@<Direction_3@>
Next the tests for directions.

@O@<../test/include/CGAL/_test_cls_direction_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Vector_3.h>
#include <CGAL/Direction_3.h>

template <class R> bool CGAL__test_cls_direction_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_direction_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_DIRECTION_3_CC
#define CGAL__TEST_CLS_DIRECTION_3_CC
#include <CGAL/_test_cls_direction_3.h>

template <class R>
bool
CGAL__test_cls_direction_3(const R& )
{
 cout << "Testing class Direction_3" ;

 R::Direction_3  id;

 CGAL_Direction_3<R> d0;
 CGAL_Direction_3<R> d1(id);

 cout << '.';
 R::RT   n0 = 10;
 R::RT  n1 = 8;
 R::RT  n2 = 4;
 R::RT  n3 = 2;

 CGAL_Vector_3<R>  v( n1, n2, n3);
 CGAL_Direction_3<R> d2(v);
 CGAL_Direction_3<R> d3( n0, n1, n2);
 CGAL_Direction_3<R> d4( d3 );
 CGAL_Direction_3<R> d5 = d3;

 assert( d3 == d3 );
 assert( d3 == d4 );
 assert( d5 == d3 );
 assert( d2 != d3 );
 assert( d3 != d2 );

 cout << '.';
 CGAL_Vector_3<R> vv = d2.vector();
 assert( v == vv );

 d0 = -d3;

 assert( d0 != d3 );
 assert( d3 == -d0);

 cout << '.';
 assert( d3.delta(0) == n0 );
 assert( d3.delta(1) == n1 );
 assert( d3.delta(2) == n2 );
 assert( d3.delta(0) == d3.dx() );
 assert( d3.delta(1) == d3.dy() );
 assert( d3.delta(2) == d3.dz() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_DIRECTION_3_CC
@}

@B@<Plane_3@>

@O@<../test/include/CGAL/_test_cls_plane_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Plane_3.h>

template <class R> bool CGAL__test_cls_plane_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_plane_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_PLANE_3_CC
#define CGAL__TEST_CLS_PLANE_3_CC
#include <CGAL/_test_cls_plane_3.h>

template <class R>
bool
CGAL__test_cls_plane_3(const R& )
{
 cout << "Testing class Plane_3" ;

 R::Plane_3  ip;
 CGAL_Plane_3<R> pl0(ip);

 R::RT  x1 = -1;
 R::RT  x2 =  4;

 CGAL_Point_3<R> p1(x1,x1,x1),
                 p2(x2,x2,x2),
                 px(R::RT(1),R::RT(0),R::RT(0)),
                 py(R::RT(0),R::RT(1),R::RT(0)),
                 pz(R::RT(0),R::RT(0),R::RT(1));

 CGAL_Point_3<R> p3(p1);
 CGAL_Direction_3<R> d1( R::RT(5), R::RT(-5), R::RT(10) );
 CGAL_Vector_3<R>    v1 = d1.vector();

 CGAL_Plane_3<R> pld( p1, d1);
 CGAL_Plane_3<R> plv( p1, v1);

 CGAL_Line_3<R>  l,
                 lp(p1,p2),
                 lxy(px,py);

 CGAL_Segment_3<R>  s12(p1,p2);
 CGAL_Ray_3<R>      r12(p1,p2);

 CGAL_Plane_3<R> xy_pl(CGAL_ORIGIN,px,py);
 CGAL_Plane_3<R> plc(xy_pl);
 CGAL_Plane_3<R> pl1(p1,pz,p2);
 CGAL_Plane_3<R> pls(s12,pz);
 CGAL_Plane_3<R> plr(r12,pz);
 CGAL_Plane_3<R> pla;
 CGAL_Plane_3<R> xy_pl_eq( R::RT(0), R::RT(0), R::RT(1), R::RT(0) );
 CGAL_Plane_3<R> neg_xy_pl_eq( R::RT(0), R::RT(0), R::RT(-1), R::RT(0) );

 cout << '.';

 pla = xy_pl;
 assert( pla == pla );
 assert( plc ==  xy_pl );
 assert( pla == xy_pl );
 assert( plc == pla );
 assert( xy_pl == xy_pl_eq );
 assert( xy_pl != neg_xy_pl_eq);
 assert( pld == plv );
 assert( pls == plr );

 CGAL_Point_3<R> origo( CGAL_ORIGIN );
 CGAL_Vector_3<R> v_zdir( R::RT(0), R::RT(0), R::RT(12) );
 CGAL_Plane_3<R> xy_pl_v( origo, v_zdir);

 assert( xy_pl == xy_pl_v );

 assert( xy_pl_eq.a() == R::RT(0) );
 assert( xy_pl_eq.b() == R::RT(0) );
 assert( xy_pl_eq.c() == R::RT(1) );
 assert( xy_pl_eq.d() == R::RT(0) );
 assert( CGAL_Plane_3<R>(pl1.a(), pl1.b(), pl1.c(), pl1.d() ) == pl1 );

 cout <<'.';

 assert( xy_pl_eq.perpendicular_line(px) == xy_pl.perpendicular_line(px) );
 assert( xy_pl.perpendicular_line(px) == \
         neg_xy_pl_eq.perpendicular_line(px).opposite() );
 assert( neg_xy_pl_eq.opposite() == xy_pl );
 assert( plr != plr.opposite() );
 assert( plc.has_on_boundary(plc.point()) );
 assert( plc.orthogonal_direction() == pla.orthogonal_direction() );
 assert( plc.perpendicular_line( plc.point() ) == \
         CGAL_Line_3<R>( plc.point(), plc.orthogonal_direction()) );
 assert( CGAL_Line_3<R>( pl1.point(), pl1.point() + pl1.orthogonal_vector() ) \
         == CGAL_Line_3<R>( pl1.point(), pl1.orthogonal_direction()) );
 assert( xy_pl.has_on_boundary(CGAL_Point_3<R>(R::RT(345),R::RT(23),R::RT(0))));

 CGAL_Vector_3<R> nov = pl1.orthogonal_vector();
 CGAL_Vector_3<R> vb1 = pl1.base1();
 CGAL_Vector_3<R> vb2 = pl1.base2();
 assert( (nov*pl1.base1()) == R::FT(0)  && (nov*pl1.base2()) == R::FT(0) );
 assert( (pl1.base2()*pl1.base1()) == R::FT(0) );
 assert( pl1.has_on_boundary(pl1.point() + pl1.base1()) );
 assert( pl1.has_on_boundary(pl1.point() + pl1.base2()) );

 cout << '.';

 assert( pl1.has_on_boundary( pl1.to_3d( pl1.to_2d( pl1.point() ))) );
 assert( pl1.has_on_boundary( pl1.to_3d( pl1.to_2d( pz ))) );

 assert( neg_xy_pl_eq.oriented_side( p1 ) == CGAL_POSITIVE );
 assert( xy_pl.oriented_side( p1 ) == CGAL_NEGATIVE );
 assert( pl1.oriented_side( p1 ) == CGAL_ZERO );
 assert( xy_pl.has_on_positive_side( p2 ) );
 assert( xy_pl.has_on_negative_side( p1 ) );

 CGAL_Plane_3<R> pldeg(p1, p1, p2);
 assert( pldeg.is_degenerate() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_PLANE_3_CC
@}

@B@<Line_3@>

@O@<../test/include/CGAL/_test_cls_line_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Line_3.h>

template <class R> bool CGAL__test_cls_line_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_line_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_LINE_3_CC
#define CGAL__TEST_CLS_LINE_3_CC
#include <CGAL/_test_cls_line_3.h>

template <class R>
bool
CGAL__test_cls_line_3(const R& )
{
 cout << "Testing class Line_3" ;

 R::Line_3 il;
 CGAL_Line_3<R> l0( il );
 CGAL_Line_3<R> l1;

 R::RT n1 =  3;
 R::RT n2 = 53;
 R::RT n3 =-14;
 R::RT n4 = 28;
 R::RT n5 = 16;
 R::RT n6 = -6;
 R::RT n7 = 11;
 R::RT n8 =-17;
 R::RT n9 = 30;

 CGAL_Point_3<R> p1( n1, n2, n3);
 CGAL_Point_3<R> p2( n4, n5, n6);
 CGAL_Point_3<R> p3( n7, n8, n9);

 CGAL_Line_3<R> l2(p1,p2);
 CGAL_Line_3<R> l3(l2);

 assert( l2 == l2);
 assert( l2 == l3);

 CGAL_Direction_3<R> dir( n9, n3, n1);
 CGAL_Line_3<R> l4(p3, dir);
 assert( l2 != l4);

 CGAL_Segment_3<R> seg(p1,p2);
 CGAL_Ray_3<R>     ray(p2,p1);
 CGAL_Line_3<R>    l5(seg);
 CGAL_Line_3<R>    l6(ray);
 assert( l2 == l5);

 cout <<'.';

 assert( l2 == l5 );
 assert( l2.direction() == l5.direction() );
 assert( l5.direction() ==  - l6.direction() );
 assert( l5.has_on( p1 ) );
 assert( l5.has_on( p2 ) );
 assert( l5.has_on( l5.point() ));
 assert( l6.has_on( p1 ) );
 assert( l6.has_on( p2 ) );
 assert( l6.has_on( l5.point() ));
 assert( l5.opposite() == l6 );
 assert( l2.opposite() == l6 );
 assert( l5 != l6 );

 CGAL_Plane_3<R> pl = l6.perpendicular_plane( l6.point() );
 CGAL_Plane_3<R> plstrich(l6.point(), l6.direction() );
 assert( pl == plstrich );
 assert( pl.orthogonal_direction() == l6.direction() );
 CGAL_Plane_3<R> plzweistrich(l6.point(), l5.direction() );
 assert( plzweistrich.opposite() == pl );

 cout << '.';

 assert( l4.point(2) - l4.point(1) == l4.point(1) - l4.point(0) );
 CGAL_Point_3<R> p1l4proj = l4.projection(p1);
 assert( l4.has_on( p1l4proj ) );
 assert( l4.perpendicular_plane( p1l4proj ).has_on( p1l4proj ) );
 assert( l4.perpendicular_plane( p1l4proj ).has_on( p1 ) );
 CGAL_Point_3<R> p4 = l4.projection(p2);
 CGAL_Point_3<R> p5 = l4.projection(p3);
 assert(  ( l4.direction() == ( p5 - p4 ).direction() )\
        ||( l4.direction() == ( p4 - p5 ).direction() )  );
 assert( l5.direction() == - l6.direction() );

 cout <<'.';

 assert( l2.has_on(p1) );
 assert( l2.has_on(p2) );
 assert( l4.has_on(p4) );
 assert( l4.has_on(p5) );
 assert( CGAL_Line_3<R>(p1,p1).is_degenerate() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_LINE_3_CC
@}

@B@<Segment_3@>

@O@<../test/include/CGAL/_test_cls_segment_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Segment_3.h>

template <class R> bool CGAL__test_cls_segment_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_segment_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_SEGMENT_3_CC
#define CGAL__TEST_CLS_SEGMENT_3_CC
#include <CGAL/_test_cls_segment_3.h>

template <class R>
bool
CGAL__test_cls_segment_3(const R& )
{
 cout << "Testing class Segment_3" ;

 R::Segment_3 is;
 CGAL_Segment_3<R>  s1(is);

 R::RT  n1 =  7;
 R::RT  n2 = 21;
 R::RT  n3 = 14;
 R::RT  n4 =-10;
 R::RT  n5 =  5;
 R::RT  n6 = 20;
 R::RT  n7 = -1;
 R::RT  n8 =  3;

 CGAL_Point_3<R> p1( n1, n2, n3, n1);
 CGAL_Point_3<R> p2( n4, n5, n6, n5);
 CGAL_Point_3<R> p3( n2, n8, n2, n8);

 CGAL_Segment_3<R> s2( p1, p2 );
 CGAL_Segment_3<R> s3( p2, p1 );
 CGAL_Segment_3<R> s4( s2 );
 s1 = s4;

 assert( s1 == s1 );
 assert( s4 == s2 );
 assert( s1 == s4 );
 assert( s1 == s2 );
 assert( s2 != s3 );

 CGAL_Segment_3<R> s5 (p3, p3 + (p1 - p3) + (p1 - p3) );
 assert( s5.has_on( p1 ) );
 assert( s5.has_on( p3 ) );
 assert( s2.has_on( p2 ) );

 cout <<'.';

 assert( s5.source() == p3 );
 assert( s5.target() == p1 + (p1 - p3) );
 assert( s2.source() != s3.source() );
 assert( s2.target() != s3.target() );

 cout <<'.';

 assert( s2.min() == p2 );
 assert( s2.max() == p1 );
 assert( s2.min() == s3.min() );
 assert( s2.max() == s3.max() );
 assert( s5.max() != s5.min() );
 assert( s5.max() == s5.opposite().max() );
 assert( s5.vertex(0) == s5.source() );
 assert( s2.vertex(1) == s2.target() );
 assert( s2.vertex(1) == s2.min() );
 assert( s2[1] == s1[1] );
 assert( s2[1] == s3[0] );

 cout << '.';

 assert( s2.squared_length() == R::FT( R::RT(17) ) );
 assert( s2.direction() == CGAL_Direction_3<R>(s2.target() - s2.source() ));
 assert( s2.direction() == s3.opposite().direction() );

 assert( s1.supporting_line() == s2.supporting_line() );
 CGAL_Line_3<R> lin(p1,p2);
 assert( s2.supporting_line() == lin );

 CGAL_Segment_3<R> sdeg(p3,p3);
 assert( sdeg.is_degenerate() );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_SEGMENT_3_CC
@}

@B@<Ray_3@>

@O@<../test/include/CGAL/_test_cls_ray_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Ray_3.h>

template <class R> bool CGAL__test_cls_ray_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_ray_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_RAY_3_CC
#define CGAL__TEST_CLS_RAY_3_CC
#include <CGAL/_test_cls_ray_3.h>

template <class R>
bool
CGAL__test_cls_ray_3(const R& )
{
 cout << "Testing class Ray_3" ;

 R::Ray_3 ir;
 CGAL_Ray_3<R>  r1(ir);

 R::RT  n1 =  8;
 R::RT  n2 = 20;
 R::RT  n3 =  4;
 R::RT  n4 = 10;
 R::RT  n5 =  5;
 R::RT  n6 = 20;
 R::RT  n7 = -2;
 R::RT  n8 =  3;

 CGAL_Point_3<R> p1( n1, n2, n3, n3);
 CGAL_Point_3<R> p2( n4, n5, n6, n5);
 CGAL_Point_3<R> p3( n7, n2, n4, n7);

 CGAL_Ray_3<R> r2( p1, p2 );
 CGAL_Ray_3<R> r3( p2, p1 );
 CGAL_Ray_3<R> r4( r2 );
 r1 = r4;
 CGAL_Direction_3<R> dir( p2 - p1 );
 CGAL_Ray_3<R> r7(p1, dir);

 assert( r1 == r1 );
 assert( r4 == r2 );
 assert( r1 == r4 );
 assert( r1 == r2 );
 assert( r7 == r2 );
 assert( r2 != r3 );

 cout <<'.';

 CGAL_Ray_3<R> r5 (p3, p3 + (p1 - p3) );
 assert( r5.has_on( p1 ) );
 assert( r5.has_on( p3 ) );
 assert( r5.has_on( p3 + (p1 - p3) ) );
 assert( r3.has_on( p2 + (p1 - p2) + (p1 - p2) ) );
 assert( r2.has_on( r2.second_point() ));
 assert( r5.has_on( r5.second_point() ));
 assert( r4.has_on( r4.point(1) ));
 assert( r4.has_on( r4.point(3) ));

 cout <<'.';

 assert( r5.source() == p3 );
 assert( r2.source() != r3.source() );
 assert( r7.direction() == dir );
 assert( r2.direction() == CGAL_Direction_3<R>(r2.point(2) - r2.point(1) ));
 assert( r2.direction() == r3.opposite().direction() );
 assert( r1.supporting_line() == r2.supporting_line() );
 CGAL_Line_3<R> lin(p1,p2);
 assert( r2.supporting_line() == lin );

 cout << '.';

 CGAL_Ray_3<R> r8( p3, dir );
 CGAL_Ray_3<R> r9( p3, -dir );
 assert( r8.opposite() == r9 );
 assert( r9.opposite() == r8 );
 CGAL_Ray_3<R> sdeg(p3,p3);
 assert( sdeg.is_degenerate() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_RAY_3_CC
@}

@B@<Triangle_3@>
@O@<../test/include/CGAL/_test_cls_triangle_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Triangle_3.h>

template <class R> bool CGAL__test_cls_triangle_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_triangle_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_TRIANGLE_3_CC
#define CGAL__TEST_CLS_TRIANGLE_3_CC
#include <CGAL/_test_cls_triangle_3.h>

template <class R>
bool
CGAL__test_cls_triangle_3(const R& )
{
 cout << "Testing class Triangle_3" ;

 R::Triangle_3 it;
 CGAL_Triangle_3<R> t0(it);

 R::RT n0 =  0;
 R::RT n1 = 12;
 R::RT n2 = 16;
 R::RT n3 = -4;
 R::RT n4 =  2;
 R::RT n5 =  3;
 R::RT n6 = 30;
 R::RT n7 =  9;
 R::RT n8 = 24;
 R::RT n9 =  8;

 CGAL_Point_3<R> p1( n1, n2, n3, n4);
 CGAL_Point_3<R> p2( n2, n9, n3,-n3);
 CGAL_Point_3<R> p3( n5, n6, n1, n5);
 CGAL_Point_3<R> p4( n7, n7, n8, n5);

 CGAL_Point_3<R> ps3( n0, n0, n7, n5);
 CGAL_Point_3<R> ps2( n0, n7, n0, n5);
 CGAL_Point_3<R> ps1( n7, n0, n0, n5);

 CGAL_Triangle_3<R> t1(p1,p2,p3);
 CGAL_Triangle_3<R> t2(p4,p2,p3);
 CGAL_Triangle_3<R> t3(ps1,ps2,ps3);
 CGAL_Triangle_3<R> t4(ps2,ps1,ps3);
 CGAL_Triangle_3<R> t5( t1 );
 t0 = t1;

 assert( t0 == t0 );
 assert( t0 == t1 );
 assert( t5 == t1 );
 assert( t2 != t4 );
 assert( t3 != t4 );

 cout <<'.';

 CGAL_Plane_3<R> pl1( p1,p2,p3);
 CGAL_Plane_3<R> pl2( p4,p2,p3);
 assert( t1.supporting_plane() == pl1 );
 assert( t2.supporting_plane() == pl2 );
 assert( t3.supporting_plane() == t4.supporting_plane().opposite() );

 cout <<'.';

 assert( t1.has_on(p3) );
 assert( t1.has_on(p2) );
 assert( t2.has_on(p4) );
 assert( ! t1.has_on(p4) );
 CGAL_Point_3<R> pt( n7, n7, n7, n7);
 assert( t3.has_on( pt ) );
 assert( t4.has_on( pt ) );

 assert( t1.vertex(0) == p1 );
 assert( t1.vertex(1) == p2 );
 assert( t1.vertex(2) == p3 );
 assert( t4[0] == ps2 );
 assert( t4[1] == ps1 );
 assert( t4[2] == ps3 );

 cout <<'.';

 CGAL_Triangle_3<R> tdeg1( p3,p3,p1);
 CGAL_Triangle_3<R> tdeg2( p3,p3,p3);
 assert( tdeg1.is_degenerate() );
 assert( tdeg2.is_degenerate() );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_TRIANGLE_3_CC
@}

@B@<Tetrahedron_3@>
@O@<../test/include/CGAL/_test_cls_tetrahedron_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Tetrahedron_3.h>

template <class R> bool CGAL__test_cls_tetrahedron_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_tetrahedron_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_TETRAHEDRON_3_CC
#define CGAL__TEST_CLS_TETRAHEDRON_3_CC
#include <CGAL/_test_cls_tetrahedron_3.h>

template <class R>
bool
CGAL__test_cls_tetrahedron_3(const R& )
{
 cout << "Testing class Tetrahedron_3" ;

 R::Tetrahedron_3 it;
 CGAL_Tetrahedron_3<R>  t0(it);

 R::RT n0 =  0;
 R::RT n1 = 12;
 R::RT n2 = 16;
 R::RT n3 = -4;
 R::RT n4 =  2;
 R::RT n5 =  3;
 R::RT n6 = 30;
 R::RT n7 =  9;
 R::RT n8 = 24;
 R::RT n9 =  8;

 CGAL_Point_3<R> p1( n1, n2, n3, n4);
 CGAL_Point_3<R> p2( n2, n9, n3,-n3);
 CGAL_Point_3<R> p3( n5, n6, n1, n5);
 CGAL_Point_3<R> p4( n7, n7, n8, n5);

 CGAL_Point_3<R> ps3( n0, n0, n7, n5);
 CGAL_Point_3<R> ps2( n0, n7, n0, n5);
 CGAL_Point_3<R> ps1( n7, n0, n0, n5);
 CGAL_Point_3<R> ps0( CGAL_ORIGIN );

 CGAL_Tetrahedron_3<R> t1(p1,p2,p3,p4);
 CGAL_Tetrahedron_3<R> t2(p2,p1,p3,p4);
 CGAL_Tetrahedron_3<R> t3(ps0,ps1,ps2,ps3); // positive oriented
 CGAL_Tetrahedron_3<R> t4(ps0,ps1,ps3,ps2); // negative oriented
 CGAL_Tetrahedron_3<R> t5(ps0,p1,p3,ps2);
 CGAL_Tetrahedron_3<R> t6(t3);
 t0 = t4;

 assert( t4 == t4 );
 assert( t4 == t0 );
 assert( t6 == t3 );
 assert( t4 != t2 );
 assert( t4 != t3 );

 cout << '.';

 assert( t5.vertex(0) == ps0 );
 assert( t5.vertex(1) == p1 );
 assert( t5.vertex(2) == p3 );
 assert( t5.vertex(3) == ps2 );
 assert( t5.vertex(4) == ps0 );
 assert( t5.vertex(5) == p1 );
 assert( t1[0] == p1 );
 assert( t1[1] == p2 );
 assert( t1[2] == p3 );
 assert( t1[3] == p4 );
 assert( t1[4] == p1 );
 assert( t1[9] == p2 );

 CGAL_Tetrahedron_3<R> t7( p1,p1,p2,p3);
 CGAL_Tetrahedron_3<R> t8( p2,p2,p2,p2);
 assert( t7.is_degenerate() );
 assert( t8.is_degenerate() );

 cout << '.';

 CGAL_Point_3<R> p5(n6,n6,n6,n4);
 CGAL_Point_3<R> p6(n4,n4,n4,n9);
 CGAL_Point_3<R> p7(n7,n7,n7,n7);
 assert( t3.has_on_unbounded_side( p5 ));
 assert( t3.has_on_bounded_side( p6 ));
 assert( t3.has_on_boundary( p7 ));
 assert( t4.has_on_unbounded_side( p5 ));
 assert( t4.has_on_bounded_side( p6 ));
 assert( t4.has_on_boundary( p7 ));
 assert( t2.has_on_unbounded_side( p5 ));
 assert( t4.bounded_side( p5 ) == CGAL_ON_UNBOUNDED_SIDE );
 assert( t4.bounded_side( p6 ) == CGAL_ON_BOUNDED_SIDE );
 assert( t4.bounded_side( p7 ) == CGAL_ON_BOUNDARY );

 cout << '.';

 assert( t3.oriented_side( p3 ) != t4.oriented_side( p3 ) );
 assert( t4.has_on_positive_side( p5 ));
 assert( t4.has_on_negative_side( p6 ));
 assert( t3.has_on_positive_side( p6 ));
 assert( t3.has_on_negative_side( p5 ));
 assert( t4.oriented_side( p5 ) == CGAL_ON_POSITIVE_SIDE );
 assert( t4.oriented_side( p6 ) == CGAL_ON_NEGATIVE_SIDE );
 assert( t4.oriented_side( p7 ) == CGAL_ON_ORIENTED_BOUNDARY );
 assert( t3.oriented_side( p7 ) == CGAL_ON_ORIENTED_BOUNDARY );
 assert( t3.oriented_side( p6 ) == CGAL_ON_POSITIVE_SIDE );
 assert( t3.oriented_side( p5 ) == CGAL_ON_NEGATIVE_SIDE );
 assert( t2.has_on_boundary(p2) );
 assert( t2.bounded_side(p3) == CGAL_ON_BOUNDARY );
 assert( t2.oriented_side(p4) == CGAL_ON_ORIENTED_BOUNDARY );
 CGAL_Point_3<R> p8(n3, n0, n0, n3);
 CGAL_Point_3<R> p9(n0, n3, n0, n3);
 assert( t3.has_on_boundary( p8 ) );
 assert( t3.has_on_boundary( p9 ) );
 assert( t4.has_on_boundary( p8 ) );
 assert( t4.has_on_boundary( p9 ) );
 assert( t3.bounded_side(p8) == CGAL_ON_BOUNDARY );
 assert( t3.oriented_side(p8) == CGAL_ON_ORIENTED_BOUNDARY );
 assert( t4.bounded_side(p9) == CGAL_ON_BOUNDARY );
 assert( t4.oriented_side(p9) == CGAL_ON_ORIENTED_BOUNDARY );

 cout << "done" << endl;
 return true;
}
#endif // CGAL__TEST_CLS_TETRAHEDRON_3_CC
@}

@B@<Aff_transformation_3@>
First we create a lot of objects and then we test scaling, translation,
and general affine transformations.
@O@<../test/include/CGAL/_test_cls_aff_transformation_3.h@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#include <CGAL/Point_3.h>
#include <CGAL/Vector_3.h>
#include <CGAL/Direction_3.h>
#include <CGAL/Plane_3.h>
#include <CGAL/Line_3.h>
#include <CGAL/Segment_3.h>
#include <CGAL/Ray_3.h>
#include <CGAL/Triangle_3.h>
#include <CGAL/Tetrahedron_3.h>
#include <CGAL/Aff_transformation_3.h>

template <class R> bool CGAL__test_cls_aff_transformation_3(const R& );
@}

@O@<../test/include/CGAL/_test_cls_aff_transformation_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_CLS_AFF_TRANSFORMATION_3_CC
#define CGAL__TEST_CLS_AFF_TRANSFORMATION_3_CC
#include <CGAL/_test_cls_aff_transformation_3.h>

template <class R>
bool
CGAL__test_cls_aff_transformation_3(const R& )
{
 cout << "Testing class Aff_transformation_3" ;

 R::Aff_transformation_3 ia;
 CGAL_Aff_transformation_3<R> a1(ia);

 R::RT n0 =  0;
 R::RT n1 =-15;
 R::RT n2 = 44;
 R::RT n3 =  4;
 R::RT n4 =  5;
 R::RT n5 = 25;
 R::RT n6 = -2;
 R::RT n7 =  8;
 R::RT n8 = 18;
 R::RT n9 =  9;
 R::RT n10=  3;
 R::RT n11=-12;
 R::RT n12= 20;
 R::RT n13=  1;
 R::RT n14= 35;

 CGAL_Vector_3<R> vec( n3, n8, n7,  n6 );  // (-2,-9,-4)
 CGAL_Vector_3<R> tvec;
 CGAL_Point_3<R>  pnt( n8, n1, n9, n10 );  // ( 6,-5, 3)
 CGAL_Point_3<R>  tpnt;
 CGAL_Point_3<R>  pvec = CGAL_ORIGIN + vec;
 CGAL_Vector_3<R> vpnt = pnt - CGAL_ORIGIN;

 CGAL_Point_3<R>  p1(-n3, n7, n11, n3 );   // (-1, 2,-3)
 CGAL_Point_3<R>  p2( n5, n4,-n12, n4 );   // ( 5, 1,-4)
 CGAL_Point_3<R>  p3( n1, n0, n14, n4 );   // (-3, 0, 7)
 CGAL_Point_3<R>  p4( n7, n2, n8, -n6 );   // ( 4,11, 9)

 CGAL_Direction_3<R> d0(n13, n0, n0);
 CGAL_Direction_3<R> d1(n0, n13, n0);
 CGAL_Direction_3<R> d2(n0, n0, n13);
 CGAL_Direction_3<R> dir = (p2 - p4).direction();
 CGAL_Direction_3<R> tdir;

 CGAL_Plane_3<R>  pla(p1,p2,p3);
 CGAL_Plane_3<R>  tpla;

 CGAL_Point_3<R>   tp1;
 CGAL_Point_3<R>   tp2;
 CGAL_Point_3<R>   tp3;
 CGAL_Point_3<R>   tp4;
 CGAL_Segment_3<R> seg(p1,p2);
 CGAL_Segment_3<R> tseg;
 CGAL_Ray_3<R>     ray(p3,p2);
 CGAL_Ray_3<R>     tray;
 CGAL_Line_3<R>    lin(p2,p4);
 CGAL_Line_3<R>    tlin;
 CGAL_Triangle_3<R>     tri( p2,p3,p4);
 CGAL_Triangle_3<R>     ttri;
 CGAL_Tetrahedron_3<R>  tet(p1, p2, p3, p4);
 CGAL_Tetrahedron_3<R>  ttet;



 CGAL_Aff_transformation_3<R> ident(n8,  n0,  n0,  n0,
                                    n0,  n8,  n0,  n0,
                                    n0,  n0,  n8,  n0,
                                                   n8 );

 CGAL_Aff_transformation_3<R> gat1( n7,  n9,  n8,  n2,
                                    n5, n11, n10,  n4,
                                    n3,  n6, n12,  n2,
                                                   n3 );

 CGAL_Aff_transformation_3<R> gat2( n7,  n9,  n8,  n2,
                                    n5, n11, n10,  n4,
                                    n3,  n6, n12,  n2,
                                                  n13 );

 CGAL_Aff_transformation_3<R> gat3( n4,  n6,  n7,  n0,
                                   n12,  n8,  n8,  n0,
                                   n11,  n3,  n9,  n0,
                                                  n13 );

 CGAL_Aff_transformation_3<R> scale11( CGAL_SCALING, n2, n3 );

 CGAL_Aff_transformation_3<R> gscale(n2,  n0, n0,  n0,
                                     n0,  n2, n0,  n0,
                                     n0,  n0, n2,  n0,
                                                   n3 );

 CGAL_Aff_transformation_3<R> gtrans(n10, n0,  n0,  n8,
                                     n0, n10,  n0,  n1,
                                     n0,  n0, n10,  n9,
                                                   n10 );

 CGAL_Aff_transformation_3<R> translate( CGAL_TRANSLATION, vpnt );

 CGAL_Aff_transformation_3<R> xrefl(-n4,  n0, n0,  n0,
                                     n0,  n4, n0,  n0,
                                     n0,  n0, n4,  n0,
                                                   n4 );

 CGAL_Aff_transformation_3<R> gat4( gat3);

 CGAL_Aff_transformation_3<R> gat5( n7,  n9,  n8,
                                    n5, n11, n10,
                                    n3,  n6, n12,
                                                  n13 );

 CGAL_Aff_transformation_3<R> gat6( n4,  n6,  n7,
                                   n12,  n8,  n8,
                                   n11,  n3,  n9,
                                                  n13 );



 CGAL_Aff_transformation_3<R> a[11];

 cout << '.';

 a[0] = ident;
 a[1] = gat1;
 a[2] = gat2;
 a[3] = gat3;
 a[4] = scale11;
 a[5] = gscale;
 a[6] = gtrans;
 a[7] = translate;
 a[8] = xrefl;
 a[9] = gat5;
 a[10]= gat6;

 CGAL_Aff_transformation_3<R> inv;

 for (int i = 0; i< 10; i++)
 {
    tp1 = p1.transform( a[i] );
    tp2 = p2.transform( a[i] );
    tp3 = p3.transform( a[i] );
    tp4 = p4.transform( a[i] );
    tpla = pla.transform( a[i] );
    tseg = seg.transform( a[i] );
    tray = ray.transform( a[i] );
    tlin = lin.transform( a[i] );
    ttri = tri.transform( a[i] );
    ttet = tet.transform( a[i] );
    assert( tpla == CGAL_Plane_3<R>( tp1, tp2, tp3) );
    assert( tseg == CGAL_Segment_3<R>(tp1, tp2) );
    assert( tray == CGAL_Ray_3<R>(tp3, tp2) );
    assert( tlin == CGAL_Line_3<R>(tp2, tp4) );
    assert( ttri == CGAL_Triangle_3<R>(tp2, tp3, tp4) );
    assert( ttet == CGAL_Tetrahedron_3<R>(tp1, tp2, tp3, tp4) );
    inv = a[i].inverse();
    tp4  = tp4.transform(  inv );
    tpla = tpla.transform( inv );
    tseg = tseg.transform( inv );
    tray = tray.transform( inv );
    tlin = tlin.transform( inv );
    ttri = ttri.transform( inv );
    ttet = ttet.transform( inv );
    assert( tp4  == p4 );
    assert( tpla == pla );
    assert( tseg == seg );
    assert( tray == ray );
    assert( tlin == lin );
    assert( ttri == tri );
    assert( ttet == tet );
 };

 cout << '.';

 // ident
 assert( vec.transform(ident) == vec );
 assert( dir.transform(ident) == dir );
 assert( pnt.transform(ident) == pnt );
 assert( pla.transform(ident) == pla );

 // scale11 and gscale
 tpnt = pnt.transform(scale11);
 tvec = vec.transform(scale11);
 tdir = dir.transform(scale11);
 tseg = seg.transform(scale11);
 assert( tseg.squared_length() == R::FT(11)* R::FT(11)* seg.squared_length() );
 assert( R::FT(11)* R::FT(11)* R::FT( vec*vec ) == R::FT( tvec*tvec ) );
 assert( vec.direction() == tvec.direction() );
 assert( dir == tdir );
 tdir = d0.transform(scale11);
 assert( d0 == tdir);
 tpnt = pnt.transform(gscale);
 tvec = vec.transform(gscale);
 tdir = dir.transform(gscale);
 tseg = seg.transform(gscale);
 assert( tseg.squared_length() == R::FT(11)* R::FT(11)* seg.squared_length() );
 assert( R::FT(11)* R::FT(11)* R::FT( vec*vec ) == R::FT( tvec*tvec ) );
 assert( seg.transform(scale11) == seg.transform(gscale) );
 assert( vec.transform(scale11) == vec.transform(gscale) );
 assert( dir.transform(scale11) == dir.transform(gscale) );
 assert( pnt.transform(scale11) == pnt.transform(gscale) );
 assert( pla.transform(scale11) == pla.transform(gscale) );

 // translate and gtrans
 tvec = vec.transform(translate);
 tdir = dir.transform(translate);
 tp2 = p2.transform(translate);
 tp3 = p3.transform(translate);
 assert( vec == tvec );
 assert( dir == tdir );
 assert( tp2  == p2 + vpnt );
 assert( tp3  == p3 + vpnt );
 tvec = vec.transform(gtrans);
 tdir = dir.transform(gtrans);
 tp2 = p2.transform(gtrans);
 tp3 = p3.transform(gtrans);
 assert( vec == tvec );
 assert( dir == tdir );
 assert( tp2  == p2 + vpnt );
 assert( tp3  == p3 + vpnt );
 assert( vec.transform(translate) == vec.transform(gtrans) );
 assert( dir.transform(translate) == dir.transform(gtrans) );
 assert( pnt.transform(translate) == pnt.transform(gtrans) );
 assert( pla.transform(translate) == pla.transform(gtrans) );

 // xrefl
 tdir = d0.transform(xrefl);
 assert( tdir == -d0 );
 tdir = d1.transform(xrefl);
 assert( tdir == d1 );
 tdir = d2.transform(xrefl);
 assert( tdir == d2 );

 cout << '.';

 // composition
 assert( pnt.transform(xrefl).transform(xrefl) == pnt );
 assert( dir.transform(xrefl).transform(xrefl) == dir );
 assert( vec.transform(xrefl).transform(xrefl) == vec );
 assert( pla.transform(xrefl).transform(xrefl) == pla );
 CGAL_Aff_transformation_3<R> co1 = xrefl * xrefl;
 assert( pnt.transform(xrefl).transform(xrefl) == pnt.transform(co1) );
 assert( dir.transform(xrefl).transform(xrefl) == dir.transform(co1) );
 assert( vec.transform(xrefl).transform(xrefl) == vec.transform(co1) );
 assert( pla.transform(xrefl).transform(xrefl) == pla.transform(co1) );
 co1 = gat2 * gat3;
 assert( pnt.transform(gat3).transform(gat2) == pnt.transform(co1) );
 assert( dir.transform(gat3).transform(gat2) == dir.transform(co1) );
 assert( vec.transform(gat3).transform(gat2) == vec.transform(co1) );
 assert( pla.transform(gat3).transform(gat2) == pla.transform(co1) );
 co1 = ident * gat1;
 assert( vec.transform(gat1) == vec.transform(co1) );
 assert( dir.transform(gat1) == dir.transform(co1) );
 assert( pnt.transform(gat1) == pnt.transform(co1) );
 assert( pla.transform(gat1) == pla.transform(co1) );
 co1 = gat1 * ident;
 assert( vec.transform(gat1) == vec.transform(co1) );
 assert( dir.transform(gat1) == dir.transform(co1) );
 assert( pnt.transform(gat1) == pnt.transform(co1) );
 assert( pla.transform(gat1) == pla.transform(co1) );
 co1 = gat1 * gat1.inverse() ;
 assert( vec == vec.transform(co1) );
 assert( dir == dir.transform(co1) );
 assert( pnt == pnt.transform(co1) );
 assert( pla == pla.transform(co1) );

 // even
 assert( translate.is_even() );
 assert( gtrans.is_even() );
 assert( gscale.is_even() );
 assert( scale11.is_even() );
 assert( ident.is_even() );
 assert( xrefl.is_odd() );

 assert( vec.transform( gat5 ) == vec.transform( gat2 ) );
 assert( dir.transform( gat5 ) == dir.transform( gat2 ) );

 assert( pnt.transform( gat6 ) == pnt.transform( gat3 ) );
 assert( vec.transform( gat6 ) == vec.transform( gat3 ) );
 assert( dir.transform( gat6 ) == dir.transform( gat3 ) );
 assert( pla.transform( gat6 ) == pla.transform( gat3 ) );

 cout << "done" << endl;
 return true;
}

#endif // CGAL__TEST_CLS_AFF_TRANSFORMATION_3_CC
@}

For convenience, a full test function.
@O@<../test/include/CGAL/_test_3.cc@>==@{@-
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL__TEST_3_CC
#define CGAL__TEST_3_CC

#include <CGAL/_test_cls_vector_3.cc>
#include <CGAL/_test_fct_vector_3.cc>
#include <CGAL/_test_cls_point_3.cc>
#include <CGAL/_test_fct_point_vector_3.cc>
#include <CGAL/_test_fct_point_3.cc>
#include <CGAL/_test_cls_direction_3.cc>
#include <CGAL/_test_cls_plane_3.cc>
#include <CGAL/_test_cls_line_3.cc>
#include <CGAL/_test_cls_segment_3.cc>
#include <CGAL/_test_cls_ray_3.cc>
#include <CGAL/_test_cls_triangle_3.cc>
#include <CGAL/_test_cls_tetrahedron_3.cc>
#include <CGAL/_test_cls_aff_transformation_3.cc>

template <class R>
bool
CGAL__test_3(const R& r)
{
 return
    CGAL__test_cls_vector_3(r)
 && CGAL__test_fct_vector_3(r)
 && CGAL__test_cls_point_3(r)
 && CGAL__test_fct_point_vector_3(r)
 && CGAL__test_fct_point_3(r)
 && CGAL__test_cls_direction_3(r)
 && CGAL__test_cls_plane_3( r )
 && CGAL__test_cls_line_3( r )
 && CGAL__test_cls_segment_3( r )
 && CGAL__test_cls_ray_3( r )
 && CGAL__test_cls_triangle_3( r )
 && CGAL__test_cls_tetrahedron_3( r )
 && CGAL__test_cls_aff_transformation_3( r )
 ;
}

#endif // CGAL__TEST_3_CC
@}
