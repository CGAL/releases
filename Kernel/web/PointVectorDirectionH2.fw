@B@<Points, Vectors, and Directions in 2D@>
Here comes the implementation of points, vectors, and directions
in two-dimensional space with homogeneous representation.
This representation allows you
division-free computations in many cases and hence it allows you to use
(exact) integer arithmetic.
Homogenous representations are parametrized by two
numbertypes @{FT@} and @{RT@}.
It is assumed that an @{FT@} can be created from an @{RT@}, either
by a constructor in the @{FT@} with an argument of type @{RT@} or
by a conversion operator @{operator FT()@} in the class @{RT@}.
@{RT@} is the internally used representation type for the coordinates,
typically a number-type representing integers, @{FT@} is used whenever
division is needed, for example when returning the Cartesian $x$-coordinate
of a point. It is typically representing rational numbers.

We distinguish between points and vectors. Directions are non-zero vectors
without length.

@C@<Class CGAL_PointH2<FT,RT>@>

The constructors of points ensure that the homogenizing coordinate is always
non-negative. This is a crucial assumption for the correctness of
many predicates on points.
For the representative of a @{CGAL_PointH2@} the class
@{CGAL__Threetuple@} is used.
The homogenizing coordinate is the last one, as was decided at the meeting
end of August 95 in Berlin. Well, this is a specification issue, but in order
to keep the implementation readable, this decision is reflected in the
implementation.

@$@<class CGAL_PointH2<FT,RT>@>+=@{@-
template < class FT, class RT >
class CGAL_PointH2 : public CGAL_Handle
{

public:
            CGAL_PointH2();
            CGAL_PointH2(const CGAL_Origin & o);
            CGAL_PointH2(const CGAL_PointH2<FT,RT> & p);
            CGAL_PointH2(const RT& hx, const RT& hy );
            CGAL_PointH2(const RT& hx, const RT& hy, const RT& hw );
            ~CGAL_PointH2();

    CGAL_PointH2<FT,RT> &
            operator=( const CGAL_PointH2& p);

    bool    operator==( const CGAL_PointH2<FT,RT>& p) const;
    bool    operator!=( const CGAL_PointH2<FT,RT>& p) const;
    bool    identical(  const CGAL_PointH2<FT,RT>& p) const;
    int     id() const;

    FT      x()  const;
    FT      y()  const;

    RT      hx() const;
    RT      hy() const;
    RT      hw() const;

    FT      cartesian(int i)   const;
    FT      operator[](int i)  const;
    RT      homogeneous(int i) const;

    int     dimension() const;
    CGAL_Bbox_2
            bbox() const;

    CGAL_PointH2<FT,RT>
            transform( const CGAL_Aff_transformationH2<FT,RT> & t) const;
@}
There are some member functions that are not documented in the manual.
That simply means that there is no guarantee that they will keep existing
in the future. By now they are used at some places where they are convenient
now.
@$@<class CGAL_PointH2<FT,RT>@>+=@{@-
    CGAL_DirectionH2<FT,RT>
            direction() const;

            CGAL_PointH2(const CGAL_VectorH2<FT,RT>& v);
@}
Now the friend functions which are public, but less public than the interface
of the class. Their friendship is interesting for the implementor only, while
the interface is interesting especially for the user.
@$@<class CGAL_PointH2<FT,RT>@>+=@{@-
 friend CGAL_PointH2<FT,RT> operator+(const CGAL_Origin & o,
                                      const CGAL_VectorH2<FT,RT> & v);
 friend CGAL_PointH2<FT,RT> operator-(const CGAL_Origin & o,
                                      const CGAL_VectorH2<FT,RT> & v);
@}
Finally the pointer to the representant. By the LEDA mechanism it is a
pointer to @{CGAL_Rep@}.
@$@<class CGAL_PointH2<FT,RT>@>+=@{@-
protected:
    CGAL__Threetuple<RT>*
        ptr() const;
};
@}

@D@<Constructors and Destructor@>

The constructors guarantee that the homogenizing coordinate is
non-negative. This is a crucial assumption for the correctness of many
routines (and should be tested there as a precondition),
e.g.\ the sidednesstest for a line. Hence every constructor for points
has to compute the sign of the homogenizing coordinate first.
A natural question arising here is, should we have the same assumption for
vectors? While the homogenizing coordinate could be arbitray in the first
version of the code for the homogeneous representation, the new code also
assumes that the homogenizing coordinate of vectors is non-negative. This
simplifies the conversion between points and vectors, but slows down the
construction of vectors, because every constructor has to compute the sign
of the homogenizing coordinate first. Therefore an undocumented (meaning
``not appearing in the user manual'') constructor, which assumes that the
homogenizing coordinate is non-negative, is added.
Also for directions the same assumption is made that the homogenizing coordinate
is non-negative.
Now points, vectors, and directions can really share the same representation!
Note that @{CGAL_Handle@} and @{CGAL_Rep@} does most of the work in the
constructors and destructor.

@$@<code templates for CGAL_PointH2<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_PointH2<FT,RT>::CGAL_PointH2()
{
 PTR = new CGAL__Threetuple<RT>();
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>::CGAL_PointH2(const CGAL_Origin&)
{
 PTR = new CGAL__Threetuple<RT>( RT(0)  , RT(0)  , RT(1)   );
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>::CGAL_PointH2(const CGAL_PointH2<FT,RT>& p) :
 CGAL_Handle(p)
{
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>::CGAL_PointH2(const RT& hx, const RT& hy)
{
 PTR = new CGAL__Threetuple<RT>( hx, hy, RT(1) );
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>::CGAL_PointH2(const RT& hx, const RT& hy, const RT& hw)
{
 if ( hw >= RT(0)   )
 {
    PTR = new CGAL__Threetuple<RT>( hx, hy, hw);
 }
 else
 {
    PTR = new CGAL__Threetuple<RT>(-hx,-hy,-hw);
 }
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>::~CGAL_PointH2()
{
}
@}
The following ``copy'' constructor is not in the manual. We need it in
order to obtain the point corresponding to a vector. As points and
vectors have the same representative and as they are not modifyable,
we only create a new handle.
The assignment is defined here and not inhereted from the LEDA handle
mechanism in order to be able to check preconditions explicitely.
@$@<code templates for CGAL_PointH2<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_PointH2<FT,RT>::CGAL_PointH2(const CGAL_VectorH2<FT,RT>& v) :
 CGAL_Handle( (CGAL_Handle&) v)
{
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>&
CGAL_PointH2<FT,RT>::operator=(const CGAL_PointH2<FT,RT>& p)
{
 CGAL_Handle::operator=(p);
 return *this;
}
@}

@D@<Equality and Identity@>
Identity and Inequality are trivial. Points are equal if they have the same
Cartesian coordinates.
@$@<code templates for CGAL_PointH2<FT,RT>@>+=@{@-
template < class FT, class RT >
bool
CGAL_PointH2<FT,RT>::operator==( const CGAL_PointH2<FT,RT>& p) const
{
 return (  (hx() * p.hw() == p.hx() * hw() )
         &&(hy() * p.hw() == p.hy() * hw() ) );
}

template < class FT, class RT >
bool
CGAL_PointH2<FT,RT>::operator!=( const CGAL_PointH2<FT,RT>& p) const
{
 return !(*this == p);
}

template < class FT, class RT >
bool
CGAL_PointH2<FT,RT>::identical( const CGAL_PointH2<FT,RT>& p) const
{
 return ( PTR == p.PTR );
}

template < class FT, class RT >
int
CGAL_PointH2<FT,RT>::id() const
{
 return (int)PTR;
}
@}

@D@<Access functions@>
Access functions for Cartesian coordinates require that conversion from
@{RT@} to@{FT@} is possible. If these access functions are never used they
should not be instantiated and should compile even without the conversion.
@$@<code templates for CGAL_PointH2<FT,RT>@>+=@{@-
template < class FT, class RT >
FT
CGAL_PointH2<FT,RT>::x()  const
{
 return ( FT( hx() ) / FT( hw() ));
}

template < class FT, class RT >
FT
CGAL_PointH2<FT,RT>::y()  const
{
 return ( FT( hy() ) / FT( hw() ));
}

template < class FT, class RT >
RT
CGAL_PointH2<FT,RT>::hx() const
{
 return  ptr()->e0 ;
}

template < class FT, class RT >
RT
CGAL_PointH2<FT,RT>::hy() const
{
 return  ptr()->e1 ;
}

template < class FT, class RT >
RT
CGAL_PointH2<FT,RT>::hw() const
{
 return  ptr()->e2;
}

template < class FT, class RT >
FT
CGAL_PointH2<FT,RT>::cartesian(int i) const
{
 CGAL_kernel_precondition( (i==0 || i==1) );
 switch (i)
 {
    case 0:  return x();
    case 1:  return y();
 }
 return FT(RT());
}

template < class FT, class RT >
RT
CGAL_PointH2<FT,RT>::homogeneous(int i) const
{
 CGAL_kernel_precondition( (i>=0) && (i<=2) );
 switch (i)
 {
    case 0:   return hx();
    case 1:   return hy();
    case 2:   return hw();
 }
 return RT();
}

template < class FT, class RT >
FT
CGAL_PointH2<FT,RT>::operator[](int i) const
{
 return cartesian(i);
}
@}

@D@<Further member functions@>
The member functions @{direction()@} and @{transform()@} are reduced
to functions of the corresponding classes. @{bbox()@} has to create a
bounding box with @{double @} coordinates that contains the point.
The arguments of the constructor are $x_{\rm min}$, $y_{\rm min}$,
$x_{\rm max}$, and $y_{\rm max}$. We could use global functions
@{lower_double_bound(double)@} and @{upper_double_bound(double)@}, which
compute the next smaller and larger @{double@} for a given @{double@},
e.g.\ for the result of @{CGAL_to_double( RT ) @}, which computes the
nearest double approximation for a number represented as an @{RT@}.
Then we could make use of the fact that IEEE-floatingpoint-standard
guarantees that the divison operation computes the best approximation.
Isn't that too much effort for a simple tool that should be used to
speed up computation? Note, we do not cache bounding boxes. So every
intersection routine would first call the complicated bounding box computation.
This would not result in a speed up!
Hence a very rough approximation that can be computed easily might be better.

@$@<code templates for CGAL_PointH2<FT,RT>@>+=@{
template < class FT, class RT >
int
CGAL_PointH2<FT,RT>::dimension() const
{
 return 2;
}

template < class FT, class RT >
CGAL_DirectionH2<FT,RT>
CGAL_PointH2<FT,RT>::direction() const
{
 return CGAL_DirectionH2<FT,RT>(*this);
}
@}

@$@<further code templates for CGAL_PointH2<FT,RT>@>+=@{
template < class FT, class RT >
CGAL_Bbox_2
CGAL_PointH2<FT,RT>::bbox() const
{
 // double eps  = exp2(-52);
 // the following is faster as it can be evaluated at compile time
 // and it is machine independent
 double eps  = double(1.0) /(double(1<<26) * double(1<<26));
 double hxd  = CGAL_to_double( hx() );
 double hyd  = CGAL_to_double( hy() );
 double hwd  = CGAL_to_double( hw() );
 double xmin = ( hxd - eps*hxd ) / ( hwd + eps*hwd );
 double xmax = ( hxd + eps*hxd ) / ( hwd - eps*hwd );
 double ymin = ( hyd - eps*hyd ) / ( hwd + eps*hwd );
 double ymax = ( hyd + eps*hyd ) / ( hwd - eps*hwd );
 if ( hx() < RT(0)   )
 {
    CGAL_swap(xmin, xmax);
 }
 if ( hy() < RT(0)   )
 {
    CGAL_swap(ymin, ymax);
 }
 return CGAL_Bbox_2(xmin, ymin, xmax, ymax);
}

template < class FT, class RT >
CGAL_PointH2<FT,RT>
CGAL_PointH2<FT,RT>::transform(const CGAL_Aff_transformationH2<FT,RT>& t) const
{
 return t.transform(*this);
}
@}

@D@<Some inline code@>

@$@<inline code for CGAL_PointH2<FT,RT>@>+=@{@-
template < class FT, class RT >
inline
CGAL__Threetuple<RT>*
CGAL_PointH2<FT,RT>::ptr() const
{
 return (CGAL__Threetuple<RT>*)PTR;
}
@}

@C@<Class CGAL_VectorH2<FT,RT>@>

Vectors are the elements of the vector space underlying our
geometric space.
Since we use homogeneous representation to make exact geometric computation
easier by avoiding division and not to simplify the correlation between
points, vectors, and affine transformations, the vectors in our class do not
have a zero in the homgenizing coordinate, which would allow do add vectors
to points by adding homogeneous components. With our representation,
this addition step is more complicated, but all that is hidden to the user.
As for points, we assure that the homogenizing coordinate in our representation
is non-negative.

Conversion between points and vectors is done in such a way that the
mathematical concept becomes evident.
There is a constant @{CGAL_ORIGIN@} of type @{CGAL_Origin@},
that is used for the conversion.
To convert a vector @{v@} to a point @{p@} you have to write
@{p = CGAL_ORIGIN + v; @}.
For the inverse you write @{v = p - CGAL_ORIGIN;@}

@$@<class CGAL_VectorH2<FT,RT>@>==@{@+
template < class FT, class RT >
class CGAL_VectorH2 : public CGAL_Handle
{
public:
            CGAL_VectorH2();
            CGAL_VectorH2(const CGAL_VectorH2& v);
            CGAL_VectorH2(const CGAL_Null_vector &);
            CGAL_VectorH2(const RT& x, const RT& y);
            CGAL_VectorH2(const RT& x, const RT& y, const RT& w );
            ~CGAL_VectorH2();
    CGAL_VectorH2<FT,RT> &
            operator=(const CGAL_VectorH2<FT,RT>& v);

    bool    operator==( const CGAL_VectorH2<FT,RT>& v) const;
    bool    operator!=( const CGAL_VectorH2<FT,RT>& v) const;
    bool    operator==( const CGAL_Null_vector&) const;
    bool    operator!=( const CGAL_Null_vector& v) const;
    bool    identical ( const CGAL_VectorH2<FT,RT>& v) const;
    int     id() const;

    FT      x()  const;
    FT      y()  const;
    RT      hx() const;
    RT      hy() const;
    RT      hw() const;
    FT      cartesian(int i)   const;
    RT      homogeneous(int i) const;
    FT      operator[](int i)  const;

    int     dimension() const;
    CGAL_DirectionH2<FT,RT>
            direction() const;
    CGAL_VectorH2<FT,RT>
            transform(const CGAL_Aff_transformationH2<FT,RT>& t ) const;
    CGAL_VectorH2<FT,RT>
            perpendicular(const CGAL_Orientation& o ) const;

    CGAL_VectorH2<FT,RT>
            operator-() const;

// undocumented:

            CGAL_VectorH2(const CGAL_PointH2<FT,RT> & p);
            CGAL_VectorH2(const CGAL_DirectionH2<FT,RT> & dir);
// friends:

friend CGAL_VectorH2<FT,RT> operator-( const CGAL_PointH2<FT,RT> &,
                                       const CGAL_Origin & );
friend CGAL_VectorH2<FT,RT> operator-( const CGAL_Origin &,
                                       const CGAL_PointH2<FT,RT> & );
friend CGAL_PointH2<FT,RT>  operator+( const CGAL_Origin &,
                                       const CGAL_VectorH2<FT,RT> & );
friend CGAL_PointH2<FT,RT>  operator-( const CGAL_Origin &,
                                       const CGAL_VectorH2<FT,RT> & );
friend CGAL_VectorH2<FT,RT> operator+( const CGAL_VectorH2<FT,RT> &,
                                       const CGAL_VectorH2<FT,RT> & );
friend CGAL_VectorH2<FT,RT> operator-( const CGAL_VectorH2<FT,RT> &,
                                       const CGAL_VectorH2<FT,RT> & );
friend FT                   operator*( const CGAL_VectorH2<FT,RT> &,
                                       const CGAL_VectorH2<FT,RT> & );
friend CGAL_VectorH2<FT,RT> operator*( const CGAL_VectorH2<FT,RT> &,
                                       const RT & );
friend CGAL_VectorH2<FT,RT> operator*( const RT &,
                                       const CGAL_VectorH2<FT,RT> & );
friend CGAL_VectorH2<FT,RT> operator/( const CGAL_VectorH2<FT,RT> &,
                                       const RT & );

protected:

    CGAL__Threetuple<RT>*
            ptr() const;
};
@}

@D@<Constructors and Destructor@>

The constructors make the homogenizing coordinate non-negative.

@$@<code templates for CGAL_VectorH2<FT,RT>@>+=@{@+
template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2()
{
 PTR = new CGAL__Threetuple<RT>();
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2(const CGAL_Null_vector &)
{
 PTR = new CGAL__Threetuple<RT>(RT(0), RT(0), RT(1) );
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2(const CGAL_VectorH2<FT,RT>& v) :
 CGAL_Handle(v)
{
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2(const RT& x, const RT& y)
{
 PTR = new CGAL__Threetuple<RT>( x,  y,  RT(1) );
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2(const RT& x, const RT& y, const RT& w)
{
 if ( w >= RT(0)   )
 {
    PTR = new CGAL__Threetuple<RT>( x,  y,  w);
 }
 else
 {
    PTR = new CGAL__Threetuple<RT>(-x, -y, -w);
 }
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::~CGAL_VectorH2()
{
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2(const CGAL_PointH2<FT,RT> & p) :
 CGAL_Handle( (CGAL_Handle&) p)
{
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>::CGAL_VectorH2(const CGAL_DirectionH2<FT,RT> & dir) :
 CGAL_Handle( (CGAL_Handle &) dir)
{
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT> &
CGAL_VectorH2<FT,RT>::operator=(const CGAL_VectorH2<FT,RT> &v)
{
 CGAL_Handle::operator=(v);
 return *this;
}
@}

@D@<Equality and Identity@>

@$@<code templates for CGAL_VectorH2<FT,RT>@>+=@{@-
template < class FT, class RT >
bool
CGAL_VectorH2<FT,RT>::operator==( const CGAL_Null_vector&) const
{
 return (hx() == RT(0)) && (hy() == RT(0));
}

template < class FT, class RT >
bool
CGAL_VectorH2<FT,RT>::operator!=( const CGAL_Null_vector& v) const
{
  return !(*this == v);
}

template < class FT, class RT >
bool
CGAL_VectorH2<FT,RT>::operator==( const CGAL_VectorH2<FT,RT>& v) const
{
 return (  (hx() * v.hw() == v.hx() * hw() )
         &&(hy() * v.hw() == v.hy() * hw() ) );
}

template < class FT, class RT >
bool
CGAL_VectorH2<FT,RT>::operator!=( const CGAL_VectorH2<FT,RT>& v) const
{
 return !(*this == v);
}

template < class FT, class RT >
bool
CGAL_VectorH2<FT,RT>::identical( const CGAL_VectorH2<FT,RT>& v) const
{
 return ( PTR == v.PTR );
}

template < class FT, class RT >
int
CGAL_VectorH2<FT,RT>::id() const
{
 return (int)PTR;
}
@}

@D@<Access member functions@>

@$@<code templates for CGAL_VectorH2<FT,RT>@>+=@{@-
template < class FT, class RT >
FT
CGAL_VectorH2<FT,RT>::x()  const
{
 return FT(ptr()->e0 )/FT(ptr()->e2 ) ;
}


template < class FT, class RT >
FT
CGAL_VectorH2<FT,RT>::y()  const
{
 return FT(ptr()->e1 )/FT(ptr()->e2 ) ;
}

template < class FT, class RT >
RT
CGAL_VectorH2<FT,RT>::hx() const
{
 return  ptr()->e0 ;
}

template < class FT, class RT >
RT
CGAL_VectorH2<FT,RT>::hy() const
{
 return  ptr()->e1 ;
}

template < class FT, class RT >
RT
CGAL_VectorH2<FT,RT>::hw() const
{
 return  ptr()->e2 ;
}

template < class FT, class RT >
FT
CGAL_VectorH2<FT,RT>::cartesian(int i) const
{
 CGAL_kernel_precondition( (i==0 || i==1) );
 switch (i)
 {
    case 0:  return x();
    case 1:  return y();
 }
 return FT(RT());
}

template < class FT, class RT >
RT
CGAL_VectorH2<FT,RT>::homogeneous(int i) const
{
 CGAL_kernel_precondition( (i>=0) && (i<=2) );
 switch (i)
 {
    case 0:  return hx();
    case 1:  return hy();
    case 2:  return hw();
 }
 return RT();
}

template < class FT, class RT >
FT
CGAL_VectorH2<FT,RT>::operator[](int i) const
{
 return cartesian(i);
}

template < class FT, class RT >
int
CGAL_VectorH2<FT,RT>::dimension() const
{
 return 2;
}

template < class FT, class RT >
CGAL_DirectionH2<FT,RT>
CGAL_VectorH2<FT,RT>::direction() const
{
 return CGAL_DirectionH2<FT,RT>(*this);
}
@}

@D@<Unary operators@>
Only unary operators are member functions, binary ones are global.
@$@<code templates for CGAL_VectorH2<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_VectorH2<FT,RT>
CGAL_VectorH2<FT,RT>::operator-() const
{
 return CGAL_VectorH2<FT,RT>(- hx(), - hy(), hw() );
}
@}


@D@<Further member functions@>

@$@<further code templates for CGAL_VectorH2<FT,RT>@>+=@{@-
template < class FT, class RT >
CGAL_VectorH2<FT,RT>
CGAL_VectorH2<FT,RT>::perpendicular(const CGAL_Orientation& o) const
{
 CGAL_kernel_precondition(o != CGAL_COLLINEAR);
 if (o == CGAL_COUNTERCLOCKWISE)
 {
    return CGAL_VectorH2<FT,RT>(-hy(), hx(), hw());
 }
 else
 {
    return CGAL_VectorH2<FT,RT>(hy(), -hx(), hw());
 }
}

template < class FT, class RT >
CGAL_VectorH2<FT,RT>
CGAL_VectorH2<FT,RT>::transform(const CGAL_Aff_transformationH2<FT,RT>& t) const
{
 return t.transform(*this);
}
@}

@$@<inline code for CGAL_VectorH2<FT,RT>@>+=@{@-
template < class FT, class RT >
inline
CGAL__Threetuple<RT>*
CGAL_VectorH2<FT,RT>::ptr() const
{
 return (CGAL__Threetuple<RT>*)PTR;
}

@}

@D@<Operations on vectors@>

@$@<vectoroperations@>==@{@-
template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator+(const CGAL_VectorH2<FT,RT>& u, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_VectorH2<FT,RT>( u.hx()*v.hw() + v.hx()*u.hw(),
                              u.hy()*v.hw() + v.hy()*u.hw(),
                              u.hw()*v.hw() );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator-(const CGAL_VectorH2<FT,RT>& u, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_VectorH2<FT,RT>( u.hx()*v.hw() - v.hx()*u.hw(),
                              u.hy()*v.hw() - v.hy()*u.hw(),
                              u.hw()*v.hw() );
}

template <class FT, class RT>
FT
operator*(const CGAL_VectorH2<FT,RT>& u, const CGAL_VectorH2<FT,RT>& v)
{

 return (   FT( RT(u.hx()*v.hx() + u.hy()*v.hy()) )  /
            FT( RT(u.hw()*v.hw() ) )    );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator/(const CGAL_VectorH2<FT,RT>& v, const RT& f)
{
 return CGAL_VectorH2<FT,RT>( v.hx(), v.hy(), v.hw()*f );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator*(const CGAL_VectorH2<FT,RT>& v, const RT& f)
{
 return CGAL_VectorH2<FT,RT>( v.hx()*f, v.hy()*f, v.hw() );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator*(const RT& f, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_VectorH2<FT,RT>( v.hx()*f, v.hy()*f, v.hw() );
}
@}

@D@<Point and Vectors Interaction@>

Only vectors can be added to points.
A vector is an equivalence class of differences between points.
There is a special ``point'' called @{CGAL_ORIGIN@} which is the
origin of our geometric space.

@$@<point and vector interaction@>==@{@+
template <class FT, class RT>
CGAL_PointH2<FT,RT>
operator+(const CGAL_Origin&, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_PointH2<FT,RT>( v );
}

template <class FT, class RT>
CGAL_PointH2<FT,RT>
operator-(const CGAL_Origin&, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_PointH2<FT,RT>( -v );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator-(const CGAL_PointH2<FT,RT>& p, const CGAL_Origin&)
{
 return CGAL_VectorH2<FT,RT>( p );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator-(const CGAL_Origin&, const CGAL_PointH2<FT,RT>& p)
{
 return  - CGAL_VectorH2<FT,RT>( p );
}
@}

@$@<addition of points and vectors@>==@{@+

template <class FT, class RT>
CGAL_PointH2<FT,RT>
operator+(const CGAL_PointH2<FT,RT>& p, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_PointH2<FT,RT>( p.hx()*v.hw() + v.hx()*p.hw(),
                             p.hy()*v.hw() + v.hy()*p.hw(),
                             p.hw()*v.hw() );
}

template <class FT, class RT>
CGAL_PointH2<FT,RT>
operator-(const CGAL_PointH2<FT,RT>& p, const CGAL_VectorH2<FT,RT>& v)
{
 return CGAL_PointH2<FT,RT>( p.hx()*v.hw() - v.hx()*p.hw(),
                             p.hy()*v.hw() - v.hy()*p.hw(),
                             p.hw()*v.hw() );
}

template <class FT, class RT>
CGAL_VectorH2<FT,RT>
operator-(const CGAL_PointH2<FT,RT>& p, const CGAL_PointH2<FT,RT>& q)
{
 return CGAL_VectorH2<FT,RT>( p.hx()*q.hw() - q.hx()*p.hw(),
                              p.hy()*q.hw() - q.hy()*p.hw(),
                              p.hw()*q.hw() );
}
@}

@C@<Class CGAL_DirectionH2<FT,RT>@>

Directions are direction vectors and in 2D a substitute for both
unit vectors and angles.
They are introduced to hid some error prone computations like
normalization of a vector or comparing slopes using trigonometric
functions.
Since length does not matter there is no need for a third homogenizing
parameter. Currently it exists to facilitate conversion between directions
and vectors by allowing them to share representants.

@$@<class CGAL_DirectionH2<FT,RT>@>==@{@+

template < class FT, class RT >
class CGAL_DirectionH2 : public CGAL_Handle
{
public:
            CGAL_DirectionH2();
            CGAL_DirectionH2(const CGAL_DirectionH2 & d );
            CGAL_DirectionH2(const CGAL_PointH2<FT,RT> & p );
            CGAL_DirectionH2(const CGAL_VectorH2<FT,RT> & v );
            CGAL_DirectionH2(const RT& x, const RT& y);
            CGAL_DirectionH2(const RT& x, const RT& y, const RT& w );
            ~CGAL_DirectionH2();
    CGAL_DirectionH2<FT,RT> &
            operator=(const CGAL_DirectionH2 & d);

    bool    operator==( const CGAL_DirectionH2& d) const;
    bool    operator!=( const CGAL_DirectionH2& d) const;
    bool    operator< ( const CGAL_DirectionH2& d) const;
    bool    operator<=( const CGAL_DirectionH2& d) const;
    bool    operator> ( const CGAL_DirectionH2& d) const;
    bool    operator>=( const CGAL_DirectionH2& d) const;
    bool    counterclockwise_in_between( const CGAL_DirectionH2& d1,
                                         const CGAL_DirectionH2& d2 ) const;
    bool    identical ( const CGAL_DirectionH2& d) const;
    int     id() const;

    CGAL_DirectionH2<FT,RT>
            operator-() const;


    CGAL_VectorH2<FT,RT>    vector() const;

    RT      x() const;
    RT      y() const;

    RT      delta(int i) const;
    RT      dx() const;
    RT      dy() const;

    CGAL_DirectionH2<FT,RT>
          perpendicular(const CGAL_Orientation &o) const;
    CGAL_DirectionH2<FT,RT>
          transform(const CGAL_Aff_transformationH2<FT,RT> &) const ;

protected:

    CGAL__Threetuple<RT>*
          ptr() const;
};
@}

@D@<Constructors and Destructor@>

@$@<code templates for CGAL_DirectionH2<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::CGAL_DirectionH2()
{
 PTR = new CGAL__Threetuple<RT>();
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::CGAL_DirectionH2(const CGAL_DirectionH2<FT,RT>& d ) :
 CGAL_Handle( (CGAL_Handle&) d )
{
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::CGAL_DirectionH2(const CGAL_PointH2<FT,RT> & p ) :
 CGAL_Handle( (CGAL_Handle&) p)
{
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::CGAL_DirectionH2(const CGAL_VectorH2<FT,RT> & v ) :
 CGAL_Handle( (CGAL_Handle&) v)
{
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::CGAL_DirectionH2(const RT& x, const RT& y)
{
 PTR = new CGAL__Threetuple<RT>( x, y, RT(1) );
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::CGAL_DirectionH2(const RT& x,
                                          const RT& y,
                                          const RT& w )
{
 if (w > RT(0)   )
 {
    PTR = new CGAL__Threetuple<RT>( x, y, w);
 }
 else
 {
    PTR = new CGAL__Threetuple<RT>(-x,-y,-w);
 }
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>::~CGAL_DirectionH2()
{
}

template < class FT, class RT >
CGAL_DirectionH2<FT,RT> &
CGAL_DirectionH2<FT,RT>::operator=(const CGAL_DirectionH2<FT,RT> &d)
{
 CGAL_Handle::operator=(d);
 return *this;
}
@}

@D@<Equality and Identity@>

In the equality test slopes are compared first and then we
exclude oppositeness by checking signs.
Note that both signs of $x$ and $y$ have to be compared since
one of them might be zero.

@$@<code templates for CGAL_DirectionH2<FT,RT>@>+=@{@-

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::operator==( const CGAL_DirectionH2<FT,RT>& d) const
{
 return (  ( x() * d.y() == y() * d.x() )
         &&( CGAL_sign( x() ) == CGAL_sign( d.x() ) )
         &&( CGAL_sign( y() ) == CGAL_sign( d.y() ) ) );
}

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::operator!=( const CGAL_DirectionH2<FT,RT>& d) const
{
 return !(*this == d);
}

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::identical( const CGAL_DirectionH2<FT,RT>& d) const
{
 return ( PTR == d.PTR );
}

template <class FT, class RT >
int
CGAL_DirectionH2<FT,RT>::id() const
{
 return (int)PTR;
}
@}

@D@<Comparison operators@>

All comparison operations are with respect to the following linear
order on directions. The linear order is based on the counterclockwise
cylic order of directions (say, on the unit circle). This cyclic
order is made linear by cutting it off at the positive $x$-axis, such
that the smallest element in the linear order is the direction of the
positive $x$-axis. There is no largest direction.
The comparison itself is based on ordertype of points.
The comparison @{in_between(d1,d2)@} tests whether the direction @{*this@} is
counterclockwise in between @{d1@} and @{d2@}.

@$@<comparison operators for directions@>+=@{@-
template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::operator< (const CGAL_DirectionH2<FT,RT>& d) const
{
 return (CGAL_compare_angles_with_x_axis(*this,d) == CGAL_SMALLER);
}

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::operator> (const CGAL_DirectionH2<FT,RT>& d) const
{
 return (CGAL_compare_angles_with_x_axis(*this,d) == CGAL_LARGER);
}

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::operator>= (const CGAL_DirectionH2<FT,RT>& d) const
{
 return !(CGAL_compare_angles_with_x_axis(*this,d) == CGAL_SMALLER);
}

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::operator<= (const CGAL_DirectionH2<FT,RT>& d) const
{
 return !(CGAL_compare_angles_with_x_axis(*this,d) == CGAL_LARGER);
}

template <class FT, class RT >
bool
CGAL_DirectionH2<FT,RT>::counterclockwise_in_between(
                           const CGAL_DirectionH2<FT,RT>& d1,
                           const CGAL_DirectionH2<FT,RT>& d2) const
{
 if ( d1 <= *this)
 {
    return ( *this <= d2 )||( d2 <= d1 );
 }
 else
 {
    return ( *this <= d2 )&&( d2 <= d1 );
 }
}
@}

@D@<Operators@>

@$@<code templates for CGAL_DirectionH2<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_DirectionH2<FT,RT>
CGAL_DirectionH2<FT,RT>::operator-() const
{
 return CGAL_DirectionH2<FT,RT>( - x(), - y() );
}
@}

@D@<Access member functions@>

There are now two undocumented access functions @{x()@} and @{y()@}
for directions. Note that they return an @{RT@}.

@$@<code templates for CGAL_DirectionH2<FT,RT>@>+=@{@-
template <class FT, class RT >
RT
CGAL_DirectionH2<FT,RT>::dx() const
{
 return ptr()->e0;
}

template <class FT, class RT >
RT
CGAL_DirectionH2<FT,RT>::dy() const
{
 return ptr()->e1;
}

template <class FT, class RT >
RT
CGAL_DirectionH2<FT,RT>::delta(int i) const
{
 CGAL_kernel_precondition( ( i == 0 ) || ( i == 1 ) );
 if (i == 0)
 {
    return dx();
 }
 return dy();
}

template <class FT, class RT >
RT
CGAL_DirectionH2<FT,RT>::x() const
{
 return ptr()->e0;
}

template <class FT, class RT >
RT
CGAL_DirectionH2<FT,RT>::y() const
{
 return ptr()->e1;
}
@}

@D@<For internal use only@>

@$@<inline code for CGAL_DirectionH2<FT,RT>@>+=@{@-
template <class FT, class RT >
inline
CGAL__Threetuple<RT>*
CGAL_DirectionH2<FT,RT>::ptr() const
{
 return (CGAL__Threetuple<RT>*)PTR;
}

@}

@D@<Further member functions@>

@$@<further code templates for CGAL_DirectionH2<FT,RT>@>+=@{@-
template <class FT, class RT >
CGAL_DirectionH2<FT,RT>
CGAL_DirectionH2<FT,RT>::perpendicular(const CGAL_Orientation& o) const
{
 CGAL_kernel_precondition(o != CGAL_COLLINEAR);
 if (o == CGAL_COUNTERCLOCKWISE)
 {
    return CGAL_DirectionH2<FT,RT>(-dy(), dx());
 }
 else
 {
    return CGAL_DirectionH2<FT,RT>(dy(), -dx());
 }
}

template <class FT, class RT >
CGAL_DirectionH2<FT,RT>
CGAL_DirectionH2<FT,RT>::transform(
                           const CGAL_Aff_transformationH2<FT,RT>& t) const
{
 return t.transform(*this);
}

template <class FT, class RT >
CGAL_VectorH2<FT,RT>
CGAL_DirectionH2<FT,RT>::vector() const
{
 return CGAL_VectorH2<FT,RT>( x(), y() );
}
@}

@C@<Header files@>
Homogeneous points, vectors, and directions have a common haeder file,
because they are heavily intertwined. In @{PointH2.h@}, @{VectorH2.h@},
and @{DirectionH2.h@} this file is included.

@O@<../include/CGAL/PVDH2.h@>==@{
@<CGAL notice@>
// Source: PVDH2.h
// Author: Stefan.Schirra@@mpi-sb.mpg.de

#ifndef CGAL_PVDH2
#define CGAL_PVDH2
#define CGAL_POINTH2_H
#define CGAL_VECTORH2_H
#define CGAL_DIRECTIONH2_H

#include <CGAL/Threetuple.h>
#include <CGAL/homogeneous_classes.h>
#include <CGAL/Origin.h>

@<class CGAL_PointH2<FT,RT>@>
@<class CGAL_VectorH2<FT,RT>@>
@<class CGAL_DirectionH2<FT,RT>@>

@<inline code for CGAL_PointH2<FT,RT>@>
@<inline code for CGAL_VectorH2<FT,RT>@>
@<inline code for CGAL_DirectionH2<FT,RT>@>

@<code templates for CGAL_PointH2<FT,RT>@>
@<code templates for CGAL_VectorH2<FT,RT>@>
@<code templates for CGAL_DirectionH2<FT,RT>@>

@<vectoroperations@>
@<point and vector interaction@>
@<addition of points and vectors@>

#include <CGAL/predicates_on_directionsH2.h>
@<comparison operators for directions@>

#include <CGAL/Aff_transformationH2.h>
#include <CGAL/Bbox_2.h>
#include <CGAL/misc.h>

@<further code templates for CGAL_PointH2<FT,RT>@>
@<further code templates for CGAL_VectorH2<FT,RT>@>
@<further code templates for CGAL_DirectionH2<FT,RT>@>


#endif // CGAL_PVDH2
@}

@O@<../include/CGAL/PointH2.h@>==@{@-
@<CGAL notice@>
#include <CGAL/PVDH2.h>
@}

@O@<../include/CGAL/VectorH2.h@>==@{@-
@<CGAL notice@>
#include <CGAL/PVDH2.h>
@}

@O@<../include/CGAL/DirectionH2.h@>==@{@-
@<CGAL notice@>
#include <CGAL/PVDH2.h>
@}
