% $Id: Circle_2.tex,v 1.3 1996/07/08 12:19:15 fabri Exp fabri $


\begin {classtemplate} {CGAL_Circle_2<R>}
\CCsection{2D Circle}

\definition  An object $c$ of the class \classname\ is a circle 
in the two-dimensional Euclidean plane $\E_2$. 
A circle is the set of points in $\E_2$ that have distance
\LatexHtml{$\sqrt({\mbox{\CCstyle{c.squared_radius()}}})$}{sqrt( c.squared_radius() )} from \CCstyle{c.center()}
of the circle.

An object $c$ of the class \classname\ is oriented, i.e., it has
clockwise or counterclockwise orientation.
circle (resp. its boundary) splits $\E_2$ in a positive and a negative side,
where the positive side is to the left of the boundary.
Furthermore it splits $\E_2$ in a bounded and an unbounded side. 


\creation
\creationvariable{c}

\CCstyle{#include <CGAL/Circle_2.h>}

\hidden \constructor{CGAL_Circle_2();}
             {introduces an uninitialized variable \var.}

\hidden \constructor{CGAL_Circle_2(const CGAL_Circle_2<R> &u);}
 	    {copy constructor.}


\def\CCalternateThreeColumn{\CCtrue}
\constructor{CGAL_Circle_2(const CGAL_Point_2<R> &p, 
	                   const CGAL_Point_2<R> &q, 
                           const CGAL_Point_2<R> &r);}
            {introduces a circle \var\ which passes through the points
              $p$,  $q$ and $r$. The orientation of \var\ is the orientation
              of \CCstyle{p}, \CCstyle{q}, and \CCstyle{r}. If the three points
              \CCstyle{p}, \CCstyle{q}, and \CCstyle{r} are collinear, the 
              circle is degenerate where the center is undefined and the 
              squared radius is zero.}

\constructor{CGAL_Circle_2(const CGAL_Point_2<R> &center, 
	                   const R::FT &squared_radius);}
            {introduces a circle \var, defined by a \CCstyle{center},
	     a \CCstyle{squared_radius}  and positive orientation, i.e.
             positive side and bounded side coincide.}

\constructor{CGAL_Circle_2(const CGAL_Point_2<R> &center, 
	                   const R::FT &squared_radius,
                           const CGAL_Orientation &orientation);}
            {introduces a circle \var, with midpoint \CCstyle{center}, 
	     a \CCstyle{squared_radius} and an  \CCstyle{orientation}.}

\constructor{CGAL_Circle_2(const CGAL_Point_2<R> &center, 
                           const CGAL_Point_2<R> &p);}
            {introduces a circle \var\ with midpoint \CCstyle{center}
             and positive orientation, such that \CCstyle{p} lies on \var.}

\constructor{CGAL_Circle_2(const CGAL_Point_2<R> &center, 
                           const CGAL_Point_2<R> &p,
                           const CGAL_Orientation &orientation);}
            {introduces a circle \var\ with midpoint \CCstyle{center}
             and orientation \CCstyle{orientation}, such that 
             \CCstyle{p} lies on \var.}

\operations
\threecolumns{4.5cm}{4cm}

\hidden \method{CGAL_Circle_2<R> & operator=(const CGAL_Circle_2<R> &c2);}
        {Assignment.}

\method{bool operator==(const CGAL_Circle_2<R> &c2) const;}
       {Test for equality: two circles are equal, iff they have the 
        same center, radius and orientation.}

\method{bool operator!=(const CGAL_Circle_2<R> &c2) const;}
       {Test for inequality.}

\method{CGAL_Point_2<R> center() const;}
       {returns the center of~\var.}

\method{R::RT squared_radius() const;}
       {returns the squared radius of~\var.}

\method{CGAL_Orientation orientation() const;}
       {returns the orientation of~\var.}


\method{bool is_degenerate() const;}
       {circle \var\ is degenerate, iff the squared radius equals zero.}


\method{CGAL_Oriented_side oriented_side(const CGAL_Point_2<R> &p) const;}
       {returns \CCstyle{CGAL_ON_POSITIVE_SIDE}, 
	\CCstyle{CGAL_ON_ORIENTED_BOUNDARY} or 
        \CCstyle{CGAL_ON_NEGATIVE_SIDE}, depending on where point $p$ is.}

\method{bool has_on_boundary(const CGAL_Point_2<R> &p) const;}
       {}

\method{bool has_on_positive_side(const CGAL_Point_2<R> &p) const;}
       {returns true, if \CCstyle{p} is to the left of the oriented
       boundary of \var.} 

\method{bool has_on_negative_side(const CGAL_Point_2<R> &p) const;}
       {returns true, if \CCstyle{p} is to the right of the oriented
       boundary of \var.}

\method{CGAL_Bounded_side bounded_side(const CGAL_Point_2<R> &p) const;}
       {returns true, if \CCstyle{p} is inside of~\var.}

\method{bool has_on_bounded_side(const CGAL_Point_2<R> &p) const;}
       {returns true, if \CCstyle{p} is on the boundary of~\var.}

\method{bool has_on_unbounded_side(const CGAL_Point_2<R> &p) const;}
       {returns true, if \CCstyle{p} is outside of~\var.}

\method{CGAL_Circle_2<R> opposite();}
       {returns a circle where the boundary is oriented the other
        way round (this flips the positive and the negative side,
          but not the bounded and unbounded side).} 

\method{CGAL_Bbox_2 bbox() const;}
       {returns a bounding box containing \var.}

\method{CGAL_Circle_2<R>  orthogonal_transform(const CGAL_Aff_transformation_2<R> &at) const;}
       {returns the circle obtained by applying $at$ on~\var.
        Precondition: \CCstyle{at} is an orthogonal transformation}

As soon as \CCstyle{CGAL_Ellipse_2<R>} will be available, there will be
as well.

\method{CGAL_Ellipse_2<R> transform(const CGAL_Aff_transformation_2<R> & at) const;}{}




\implementation
A circle is internally represented as a point, a squared radius and an orientation.

\end {classtemplate} 

% $Log: Circle_2.tex,v $
%

