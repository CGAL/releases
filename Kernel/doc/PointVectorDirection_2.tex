
\cleardoublepage
\chapter{2D Point, Vector and Direction \label{PointVectorDirection}}


We strictly distinguish between points, vectors and directions: 
A {\em point} is a point in the two-dimensional euclidean plane
$\E_2$, a {\em vector} is the difference of two points $p_2$, $p_1$
and denotes the direction and the distance from $p_1$ to $p_2$ in the
vector space $\R^2$, a {\em direction} is a vector where we forget
about its length.

They are different mathematical concepts, for example they behave
different under affine transformations and an addition of two
points is meaningless in affine geometry.  By putting them in different
classes we not only get cleaner code, but also type checking from the
compiler which avoids ambigous expressions. Hence, it pays twice to
make this distinction.

\input{Point_2.tex}

\newpage
\input{Vector_2.tex}

\newpage
\input{Direction_2.tex}


\section{Conversion between Points and Vectors\label{conversion}}

We said that it does not make sense to add two points, but it does
make sense to subtract them and the result should be a vector. 
\cgal\ defines a symbolic constant \CCstyle{CGAL_ORIGIN}  which denotes
the point at the origin.  Subtracting it from a
point $p$ results in the locus vector of $p$. 

\begin{cprog}

  CGAL_Point_2< CGAL_Cartesian<double> >  p(1.0, 1.0), q;

  CGAL_Vector2< CGAL_Cartesian<double> >  v;

  v = p - CGAL_ORIGIN;

  q = CGAL_ORIGIN + v;  
\end{cprog} 

In order to obtain the point corresponding to a vector $v$ you simply
have to add $v$ to \CCstyle{CGAL_ORIGIN}. If you want to determine 
the point $q$ in the middle between two points $p_1$ and $p_2$, you can write

\begin{cprog}

  q = p_1 + (p_2 - p_1) / 2.0;
\end{cprog}  



\section{Implementation}

Points, vectors and directions use a handle/representative mechanism:
A handle is an intelligent pointer, a representative is an object with a
reference counter. The three classes have the same internal
representation, namely a tuple of coordinates (plus a homogenizing
coordinate in the case of homogeneous coordinates), which makes
assignment, copy constructors and type conversion cheap. 

An assigment makes the handle of the left hand side point to the
representative the handle on the right hand sidepoints to.  The copy
constructor creates a new handle which points to the same
representative. This especially pays if your coordinates are of
non-constant size.

What about conversion? We explained that you convert by subtracting
the origin from a point to obtain its locus vector, or by adding a
vector to the origin to obtain the corresponding point.  Although the
origin behaves like a point,  \CCstyle{CGAL_ORIGIN} is not an object of
the class \CCstyle{CGAL_Point_2<R>} but of the class
\CCstyle{CGAL_Origin}.  All constructors and operators taking a point
as argument are overloaded with the origin class in order to avoid
memory allocation (for a point with coordinates zero), and arithmetic 
operations (where numbers would be added to zero). To give an example:
When you ``add'' a vector $v$ to the origin only a new handle is created
which points to the representation of $v$.




