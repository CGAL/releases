% $Id: Vector_3.tex,v 1.2 1996/07/08 12:19:15 fabri Exp fabri $

\begin {classtemplate} {CGAL_Vector_3<R>}
\CCsection{3D Vector}

\definition

An object of the class \classname\ is a vector in the three-dimensional 
vector space $\R^2$. Geometrically spoken a vector is the difference
of two points $p_3$, $p_1$ and denotes the direction and the distance
from   $p_1$ to $p_3$. 

\cgal\ defines a symbolic constant \CCstyle{CGAL_NULL_VECTOR}. We 
will explicitely state where you can pass this constant as an argument
instead of a vector initialized with zeros.


\creation
\creationvariable{v}

\CCstyle{#include <CGAL/Vector_3.h>}

\hidden\constructor{CGAL_Vector_3();}
             {introduces an uninitialized variable \var.}

\hidden \constructor{CGAL_Vector_3(const CGAL_Vector_3<R> &w);}
 	    {copy constructor.}

\constructor{CGAL_Vector_3(const R::RT &hx, const R::RT &hy, const R::FT &hz, const R::RT &hw = R::RT(1));}
            {introduces a vector \var\ initialized to $(hx/hw, hy/hw, hz/hw)$.
             If the third argument is not explicitely given it defaults
             to \CCstyle{R::RT(1)}.}


\operations
\threecolumns{5cm}{4cm}

\hidden \method{CGAL_Vector_3<R> & operator=(const CGAL_Vector_3<R> &w);}
        {Assignment.}

\method{bool operator==(const CGAL_Vector_3<R> &w) const;}
       {Test for equality: two vectors are equal, iff their $x$, $y$ 
        and $z$ coodinates are equal. You can compare with the
        \CCstyle{CGAL_NULL_VECTOR}.}

\method{bool operator!=(const CGAL_Vector_3<R> &w) const;}
       {Test for inequality.You can compare with the
        \CCstyle{CGAL_NULL_VECTOR}.}


There are two sets of coordinate access functions, namely to the
homogeneous and to the Cartesian coordinates. They can be used
independently from the chosen representation type \CCstyle{R}.

\method{R::RT hx() const;}
       {returns the homogeneous $x$ coordinate.}

\method{R::RT hy() const;}
       {returns the homogeneous $y$ coordinate.}

\method{R::RT hz() const;}
       {returns the homogeneous $z$ coordinate.}

\method{R::RT hw() const;}
       {returns the homogenizing  coordinate.}

Here come the Cartesian access functions. Note that you do not loose
information with the homogeneous representation, because then the field
type is a quotient.


\method{R::FT x() const;}
       {returns the \CCstyle{x}-coordinate of \var, that is $hx/hw$.}

\method{R::FT y() const;}
       {returns the \CCstyle{y}-coordinate of \var, that is $hy/hw$.}

\method{R::FT z() const;}
       {returns the \CCstyle{z} coordinate of \var, that is $hz/hw$.}

The following operations are for convenience and for making the
class \classname\ compatible with code for higher dimensional vectors.
Again they come in a Cartesian and homogeneous flavor.

\method{R::RT homogeneous(int i) const;}
       {returns the i'th homogeneous coordinate of \var, starting with 0.
        \precond $0\leq i \leq 3$.}

\method{R::FT cartesian(int i) const;}
       {returns the i'th cartesian coordinate of \var, starting at 0.
        \precond $0\leq i \leq 2$.}

\method{R::FT operator[](int i) const;}
       {returns  \CCstyle{coordinate(i)}.
        \precond $0\leq i \leq 2$.}

\method{int dimension() const;}
       {returns the dimension (the constant 3).}

\method{CGAL_Vector_3<R>  transform(const CGAL_Aff_transformation_3<R> &t) const;}
       {returns the vector obtained by applying $t$ on \var.}

The following operations can be applied on vectors:

\method{CGAL_Vector_3<R>        operator+(const CGAL_Vector_3<R> &w) const;}
       {Addition.}

\method{CGAL_Vector_3<R>        operator-(const CGAL_Vector_3<R> &w) const;}
       {Subtraction.}

\method{CGAL_Vector_3<R>        operator-() const;}
       {Negation.}

\method{R::FT                  operator*(const CGAL_Vector_3<R> &w) const;}
       {returns the scalar product (= inner product) of the two vectors.}


\method{CGAL_Vector_3<R> operator*(const R::RT &s) const;}
       {Multiplication with a scalar from the right. Although it would
        be more natural, \cgal does not offer a multiplication with a 
        scalar from the left.\LatexHtml{\footnote{This is due to compiler problems
        which will hopefully be overcome sooner or later.}}{This is due to compiler problems
        which will hopefully be overcome sooner or later.}}


\method{CGAL_Vector_3<R> operator*(const R::FT &s) const;}
       {Multiplication with a scalar from the right.}


%\function{CGAL_Vector_3<R> operator*(const R::RT &s, 
%				       const CGAL_Vector_3<R> &w);}
%       {Multiplication with a scalar from the left.}

\method{CGAL_Vector_3<R>        operator/(const R::RT &s) const;}
       {Division by a scalar.}

\method{CGAL_Direction_3<R> direction() const;}
       {returns the direction of \var.}



\end {classtemplate} 

% $Log: Vector_3.tex,v $
% Revision 1.2  1996/07/08 12:19:15  fabri
% *** empty log message ***
%
% Revision 1.1  1996/03/13 15:42:07  fabri
% Initial revision
%
% Revision 1.1  1995/10/19 18:22:12  fabri
% Initial revision
%
