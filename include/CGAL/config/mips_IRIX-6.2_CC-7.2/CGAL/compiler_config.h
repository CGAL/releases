/* Copyright (c) 1997 The CGAL Consortium
 *
 * This software and related documentation is part of the
 * Computational Geometry Algorithms Library (CGAL).
 *
 * Compiler specific configuration file for CGAL 1.0
 * System: mips_IRIX-6.2_CC-7.2
 * generated by install_cgal 1.22
 * with install testsuite .
 */

// CGAL STL version id:
#define CGAL_STL_SGI_WWW 1

//+--------------------------------------------------------------------------
//| When a dynamic cast involves a pointer to a not yet instantiated 
//| template class, some compilers give an error.
//| This program is used to detect this problem.
//| "CGAL_CFG_DYNAMIC_CAST_BUG.C", line 45: error(3105): the type in a
//|           dynamic_cast must be a pointer or reference to a complete class
//|           type, or void *
//|     W< L<int> >* wl_ptr = dynamic_cast<W< L<int> >* >( &wp );
//|                                        ^
//+--------------------------------------------------------------------------
#define CGAL_CFG_DYNAMIC_CAST_BUG 1

//+--------------------------------------------------------------------------
//| When a class (Cls_P / Cls_Pl) refers to a not yet defined class (Cls_At),
//| some compilers give an "incomplete type error".
//| This program is used to detect a special case of this problem
//| where templates are involved.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_INCOMPLETE_TYPE_BUG_1 1

//+--------------------------------------------------------------------------
//| When a class (A) refers to a not yet defined class (B), some compilers
//| give an "incomplete type error".
//| This program is used to detect a special case of this problem
//| where virtual functions and templates are involved.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_INCOMPLETE_TYPE_BUG_3 1

//+--------------------------------------------------------------------------
//| When a class (A) refers to a not yet defined class (B), some compilers
//| give an "incomplete type error".
//| This program is used to detect a special case of this problem
//| where typedefs are involved.
//+--------------------------------------------------------------------------
#define CGAL_CFG_INCOMPLETE_TYPE_BUG_4 1

//+--------------------------------------------------------------------------
//| When a class (A) refers to a not yet defined class (B), some compilers
//| give an "incomplete type error".
//| This program is used to detect a special case of this problem
//| where typedefs are involved.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_INCOMPLETE_TYPE_BUG_4_NO_TYPENAME 1

//+--------------------------------------------------------------------------
//| This flag is set, if the compiler does not match a function
//| argument of type typename T::A correctly.
//| (e.g. SGI 7.2)
//+--------------------------------------------------------------------------
#define CGAL_CFG_MATCHING_BUG_1 1

//+--------------------------------------------------------------------------
//| This flag is set, if the compiler does not match the most
//| specialized instance of a function template correctly,
//| but complains about multiple matches.
//| (e.g. SGI 7.2)
//+--------------------------------------------------------------------------
#define CGAL_CFG_MATCHING_BUG_2 1

//+--------------------------------------------------------------------------
//| The arrow operator 'operator->()' could not be overloaded by some
//| compilers within a class template (SunPro CC 4.2 complains if the 
//| return value is not a struct). The following definition is set 
//| if it cannot be overloaded. Note that the arrow operator is mandatory
//| for iterators according to the Dec. 1996 C++ Standard draft.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_ARROW_OPERATOR 1

//+--------------------------------------------------------------------------
//| When template implementation files are not included in the source files,
//| a compiler may attempt to find the unincluded template bodies automatically.
//| For example, suppose that the following conditions are all true.
//|
//| - template entity ABC::f is declared in file xyz.h
//| - an instantiation of ABC::f is required in a compilation
//| - no definition of ABC::f appears in the source code processed by the
//|   compilation
//| 
//| In this case, the compiler may look to see if the source file xyz.n exists,
//| where n is .c, .C, .cpp, .CPP, .cxx, .CXX, or .cc. If this feature is
//| missing, the flag CGAL_CFG_NO_AUTOMATIC_TEMPLATE_INCLUSION is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_AUTOMATIC_TEMPLATE_INCLUSION 1

//+--------------------------------------------------------------------------
//| The byte order of a machine architecture distinguishes into
//| big-endian and little-endian machines.
//| The following definition is set if it is a little-endian machine.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_BIG_ENDIAN 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't know the keyword bool, the flag
//| CGAL_CFG_NO_BUILTIN_BOOL is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_BUILTIN_BOOL 1

//+--------------------------------------------------------------------------
//| Constants are not accepted by certain compilers in a template
//| argument list for template functions. The following definition is set 
//| if they are not accepted.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_CONSTANTS_IN_FUNCTION_TEMPLATES 1

//+--------------------------------------------------------------------------
//| This flag is set if the compiler doesn't support the operator const_cast.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_CONST_CAST 1

//+--------------------------------------------------------------------------
//| The Gnu g++ 2.7.2.1 isn't able to distinguish cleanly between 
//| overloading with a reference and a const reference parameter
//| if he looks fpor a match with a derived class and reports an 
//| ambigious overloading resolution. One workaround could be to
//| remove the const reference declaration. g++ will warn a converion
//| from const X& to X& but compiles. Another workaround would be the
//| explicit cast to the base class (if known).
//| The following definition is set if the compiler fails to
//| distinguish those functions.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_CONST_REFERENCE_OVERLOADING 1

//+--------------------------------------------------------------------------
//| Default template arguments that are dependant on previous template
//| arguments like in 'template< class A, class C = vector<A> >' are not
//| supported by any compiler. The following definition is set if they are
//| not supported. Note that if CGAL_CFG_NO_DEFAULT_TEMPLATE_ARGUMENTS is 
//| set, this definition must also be set.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_DEFAULT_PREVIOUS_TEMPLATE_ARGUMENTS 1

//+--------------------------------------------------------------------------
//| Default template arguments like 'template< class A = int>' are not
//| supported by any compiler. The following definition is set if they
//| are not supported.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_DEFAULT_TEMPLATE_ARGUMENTS 1

//+--------------------------------------------------------------------------
//| This flag is set if the compiler doesn't support the operator dynamic_cast.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_DYNAMIC_CAST 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't know the keyword explicit, the flag
//| CGAL_CFG_NO_EXPLICIT is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_EXPLICIT 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't support specialisation of class templates,
//| the flag CGAL_CFG_NO_EXPLICIT_CLASS_TEMPLATE_SPECIALISATION is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_EXPLICIT_CLASS_TEMPLATE_SPECIALISATION 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't like explicit specification of 
//| template arguments in template function calls, the flag
//| CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION 1

//+--------------------------------------------------------------------------
//| Iterator traits are documented in the Dec. 1996 C++ Standard draft.
//| The following definition is set if iterator are not fully supported 
//| including their use in a template class, as a default template
//| argument and as a return type of global function.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_ITERATOR_TRAITS 1

//+--------------------------------------------------------------------------
//| Implicit instantiation of a class template does only instantiate member
//| functions when needed (Dec. 1996 C++ Standard draft, 14.7.1). 
//| This implies that member functions that are not instanciated in a 
//| certain context are allowed to use functionality from the template 
//| arguments that are not provided by the actual argument. For example
//| the Gnu g++ 2.7.2 does not comply to this. The following definition
//| is set if the implicit instantiation does not work in this lazy fashion.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_LAZY_INSTANTIATION 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't support member templates, the flag
//| CGAL_CFG_NO_MEMBER_TEMPLATES is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_MEMBER_TEMPLATES 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't know namespaces, the flag
//| CGAL_CFG_NO_NAMESPACE is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_NAMESPACE 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't like explicit partial specification of 
//| template arguments in template function calls, the flag
//| CGAL_CFG_NO_PARTIAL_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_PARTIAL_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION 1

//+--------------------------------------------------------------------------
//| This flag is set if the compiler doesn't support the operator
//| reinterpret_cast.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_REINTERPRET_CAST 1

//+--------------------------------------------------------------------------
//| The parameter types of member functions might contain a scope
//| operator. This works as long as the member function is implemented
//| inline in the class. If the member function is implemented external
//| not all compilers are able to parse the scope operators correctly.
//| The following definition is set if the compiler fails parsing.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_SCOPE_MEMBER_FUNCTION_PARAMETERS 1

//+--------------------------------------------------------------------------
//| The parameter types of member functions might contain a scope
//| operator. This works as long as the member function is implemented
//| inline in the class. If the member function is implemented external
//| not all compilers are able to parse the scope operators correctly.
//| The following definition is set if the compiler fails parsing.
//| This is only relevant for compilers NOT supporting the keyword
//| typename, since otherwise the flag
//| CGAL_CFG_NO_SCOPE_MEMBER_FUNCTION_PARAMETERS is used.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_SCOPE_MEMBER_FUNCTION_PARAMETERS_NO_TYPENAME 1

//+--------------------------------------------------------------------------
//| This flag is set if the compiler doesn't support the operator const_cast.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_STATIC_CAST 1

//+--------------------------------------------------------------------------
//| The following flag is set if a compiler doesn't accept static members
//| in a template class.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_STATIC_MEMBERS_IN_CLASS_TEMPLATES 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't distinguish a template instantiation and 
//| a non-templated function with the same signature, 
//| CGAL_CFG_NO_TEMPLATE_FRIEND_DISTINCTION is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_TEMPLATE_FRIEND_DISTINCTION 1

//+--------------------------------------------------------------------------
//| Some compilers (like g++ 2.7.2) follow the old rules for argument matching
//| stated in the ARM: template functions have to match exactly. In particular,
//| derived classes don't match to base class parameters in a template function.
//| The following flag is set if this is the case.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_NO_TEMPLATE_FUNCTION_MATCHING 1

//+--------------------------------------------------------------------------
//| If a compiler doesn't know the keyword typename, the flag
//| CGAL_CFG_NO_TYPENAME is set.
//+--------------------------------------------------------------------------
#define CGAL_CFG_NO_TYPENAME 1

//+--------------------------------------------------------------------------
//| The following flag is set if a compiler does not allow the return
//| type T::A of a function or a class method.
//+--------------------------------------------------------------------------
#define CGAL_CFG_RETURN_TYPE_BUG_1 1

//+--------------------------------------------------------------------------
//| The following flag is set if a compiler does not allow the return
//| type T::A of a function or a class method.
//| This is only relevant for compilers NOT supporting the keyword
//| typename, since otherwise the flag
//| CGAL_CFG_RETURN_TYPE_BUG_1 is used.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_RETURN_TYPE_BUG_1_NO_TYPENAME 1

//+--------------------------------------------------------------------------
//| The following flag is set if a compiler does not allow the return
//| type A<T>::B of a function or class method.
//+--------------------------------------------------------------------------
//#define CGAL_CFG_RETURN_TYPE_BUG_2 1

