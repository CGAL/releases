// ======================================================================
//
// Copyright (c) 1998 The CGAL Consortium
//
// This software and related documentation is part of the
// Computational Geometry Algorithms Library (CGAL).
//
// Every use of CGAL requires a license. Licenses come in three kinds:
//
// - For academic research and teaching purposes, permission to use and
//   copy the software and its documentation is hereby granted free of  
//   charge, provided that
//   (1) it is not a component of a commercial product, and
//   (2) this notice appears in all copies of the software and
//       related documentation.
// - Development licenses grant access to the source code of the library 
//   to develop programs. These programs may be sold to other parties as 
//   executable code. To obtain a development license, please contact
//   the CGAL Consortium (at cgal@cs.uu.nl).
// - Commercialization licenses grant access to the source code and the
//   right to sell development licenses. To obtain a commercialization 
//   license, please contact the CGAL Consortium (at cgal@cs.uu.nl).
//
// This software and documentation is provided "as-is" and without
// warranty of any kind. In no event shall the CGAL Consortium be
// liable for any damage of any kind.
//
// The CGAL Consortium consists of Utrecht University (The Netherlands),
// ETH Zurich (Switzerland), Free University of Berlin (Germany),
// INRIA Sophia-Antipolis (France), Martin-Luther-University Halle-Wittenberg
// (Germany) Max-Planck-Institute Saarbrucken (Germany), RISC Linz (Austria),
// and Tel-Aviv University (Israel).
//
// ----------------------------------------------------------------------
// release       : CGAL-1.2
// release_date  : 1999, January 18
//
// file          : include/CGAL/dd_geo/regl_complex.h
// package       : Convex_hull_3 (1.1.3)
// source        : LEP dd_geo_kernel
// revision      : 2.1
// revision_date : 
// author(s)     : Kurt Mehlhorn
//                 Michael Seel
//
// coordinator   : MPI, Saarbruecken
//
// email         : cgal@cs.uu.nl
//
// ======================================================================
/*******************************************************************************
+
+  LEP dd_geokernel 2.1
+
+  This file is part of the research version of a LEDA extension package,
+  that can be used free of charge in academic research and teaching. 
+  Any commercial use of this software requires a commercial license,
+  which is distributed by the Algorithmic Solutions GmbH, 
+  Postfach 151101, 66041 Saarbruecken, FRG (fax +49 681 31104).
+
+  Copyright (c) 1997-1998  by  Max-Planck-Institut fuer Informatik
+  Im Stadtwald, 66123 Saarbruecken, Germany     
+  All rights reserved.
+ 
*******************************************************************************/

//---------------------------------------------------------------------
// file generated by notangle from regl_complex.lw
// please debug or modify LEDA web file
// mails and bugs: Michael.Seel@mpi-sb.mpg.de
// based on LEDA architecture by S. Naeher, C. Uhrig
// coding: K. Mehlhorn, M. Seel
// debugging and templatization: M. Seel
//---------------------------------------------------------------------

#ifndef CGAL_DD_GEO_REGL_COMPLEX_H
#define CGAL_DD_GEO_REGL_COMPLEX_H
#define LEP_DDGEO_REGL_COMPLEX_H

#if !defined(LEP_DDGEO_INCL_ID)
#define LEDA_ROOT_INCL_ID NOT_ANY_KERNEL_NUMBER
#define LEP_DDGEO_INCL_ID 21029
#include <LEDA/REDEFINE_NAMES.h>
#endif


#include <LEDA/array.h>
#include <LEDA/list.h>
#include <LEDA/window.h>
#include <LEDA/graph.h>
#include <LEDA/map.h>
#include <LEDA/node_map2.h>
#include <CGAL/dd_geo/config.h>

//#define _DEBUG
#include <CGAL/dd_geo/debug.h>

#ifdef DDGEO_STL_ITERATORS
#include <iterator.h>
#endif

#ifndef DDGEO_TEMPLATE_DEFAULTS
template <class TRAITS,class POINT> class rc_Simplex;
template <class TRAITS,class POINT> class rc_Vertex;
template <class TRAITS,class POINT> class regl_complex;
#else
template <class TRAITS,class POINT=typename TRAITS::POINT> class rc_Simplex;
template <class TRAITS,class POINT=typename TRAITS::POINT> class rc_Vertex;
template <class TRAITS,class POINT=typename TRAITS::POINT> class regl_complex;
#endif


template <class TRAITS,class POINT>
class rc_Vertex
{ 
  typedef rc_Simplex<TRAITS,POINT>* rc_simplex;
  friend class regl_complex<TRAITS,POINT>;
  friend class rc_Simplex<TRAITS,POINT>;
  rc_simplex  sim;
  int         index;
  POINT         ass_point;

public:

  rc_Vertex(rc_simplex s, int i, const POINT& p) :
    sim(s), index(i), ass_point(p) {}

  rc_Vertex(const POINT& p) :
    ass_point(p) {}
    
  rc_Vertex() :
    sim(nil), index(-42) {}
  // beware that ass_point was initialized here by nil_point

  ~rc_Vertex() {}

  LEDA_MEMORY(rc_Vertex);
};


template <class TRAITS,class POINT>
class rc_Simplex 
{ 
  typedef rc_Vertex<TRAITS,POINT>*  rc_vertex;
  typedef rc_Simplex<TRAITS,POINT>* rc_simplex;
  friend class regl_complex<TRAITS,POINT>;    
  // regl_complex has unrestricted access
protected:
  array<rc_vertex>    vertices;          // array of vertices
  array<rc_simplex>   neighbors;         // opposite simplices
  array<int>          opposite_vertices; // indices of opposite vertices

public:
 
  rc_Simplex(int dmax): vertices(0,dmax),
                        neighbors(0,dmax),
                        opposite_vertices(0,dmax)
  { 
    for (int i = 0; i <= dmax; i++) { 
      neighbors[i] = nil; 
      vertices[i] = nil;
      opposite_vertices[i] = -1;
    }
  }

  ~rc_Simplex() {} 

  void print(ostream& O=cout) const
  {
    O << "simplex{" ;
    rc_Vertex<TRAITS,POINT>* v;
    forall(v,vertices) {
      if (v!=nil) O << (*v).ass_point;
      else O << "(nil)";
    }
    O << "}";
 
  }
  friend ostream& operator<<(ostream& O, const rc_Simplex<TRAITS,POINT>& s)
  { s.print(O); return O; }

  LEDA_MEMORY(rc_Simplex); 
}; 

        

/*{\Manpage {regl_complex} {TRAITS} {Regular Simplicial Complex} {C}}*/
/*{\Mdefinition 

A instance |\Mvar| of type |\Mname| is a regular abstract or concrete
simplicial complex. An abstract simplicial complex is a family |\Mvar|
of subsets of some set $V$, called the vertex set of the complex,
which is closed under the subset relation, i.e., if a set $s$ belongs
to the family then all its subsets do. A set $s$ of cardinality $k +
1$ is called a $k$-simplex and $k$ is called its dimension.  If $s$ is
a subset of $t$ then $s$ is called a subsimplex or face of $t$. A
vertex $v$ is called incident to a simplex $s$ if $v$ is an element of
$s$.  A simplex is called \emph{maximal} if it is not a face of any
simplex in |\Mvar|. Two simplices of dimension $k$ are called
neighbors if they share $k-1$ vertices. A complex is connected if its
set of maximal simplices forms a connected set under the neighboring
relation.  A simplicial complex is called \emph{regular} if all
maximal simplices in the complex have the same dimension and if the
complex is connected.  

A concrete simplicial complex is an abstract simplicial complex in
which a point in some ambient space is associated with each vertex.
We use |dim| to denote the dimension of ambient space.  Simplices are
now interpreted geometrically as sets of points in ambient space,
namely as the convex hulls of (the points associated with) their
vertices. A $0$-simplex is a point, a $1$-simplex is a line segment, a
$2$-simplex is a triangle, a $3$-simplex is a tetrahedron,
etc.. \emph{The simplices is a concrete simplicial complex must
satisfy the additional conditions that the points associated with the
vertices of any simplex are affinely independet and that the
intersection of any two simplices is a face of both.} We will write
simplicial complex instead of concrete simplicial complex in the
sequel.

All maximal simplices in a regular simplicial complex have the same
dimension, which we denote |dcur|.  For each maximal
simplex\footnote{we drop the adjective maximal in the sequel} in
|\Mvar| there is an item of type |rc_simplex| and for each vertex
there is an item of type |rc_vertex|.  Each maximal simplex has |1+dcur| 
vertices indexed from $0$ to |dcur|. For any simplex $s$ and any
index $i$, |C.vertex_of(s,i)| returns the $i$-th vertex of $s$. There
may or may not be a simplex $t$ opposite to (the vertex with index)
$i$, i.e., a maximal simplex $t$ having
${|C.vertex_of(s,0)|,|C.vertex_of(s,1)|,\ldots,
|C.vertex_of(s,dcur)|} - \{|C.vertex_of(s,i)|\}$ in its vertex
set.  The function |C.opposite(s,i)| returns $t$ if it exists and
returns |nil| otherwise. If $t$ exists then $s$ and $t$ share |dcur|
vertices, namely all but vertex $i$ of $s$ and vertex
|C.opposite_vertex(s,i)| of $t$. Assume that $t = |C.opposite(s,i)|$
exists and let $j = |C.opposite_vertex(s,i)|$. Then |s = C.opposite(t,j)| 
and |i = C.opposite_vertex(t,j)| and
\begin{eqnarray*}
\lefteqn{\{|C.vertex_of(s,0)|,|C.vertex_of(s,1)|,\ldots,
|C.vertex_of(s,dcur)|\} - \{|C.vertex_of(s,i)|\} =} \\ & &
\{|C.vertex_of(t,0)|,|C.vertex_of(t,1)|,\ldots,|C.vertex_of(t,dcur)|\}
- \{|C.vertex_of(t,j)|\}.  \end{eqnarray*} In general, a
vertex belongs to many simplices. For an |rc_vertex| $v$,
the functions |C.simplex(v)| and |C.index(v)| return a pair $(s,i)$
such that |v = C.vertex_of(s,i)|.

The class |regl_complex| has a static member |nil_point| of type
|POINT|. This point is different (= not indentical) from any user
defined point and is the point associated with every vertex of an
abstract simplicial complex. It simulates the use of |nil| to denote
an undefined object.

Regular complexes are designed as the base class for triangulations of
convex hulls and Delaunay triangulations in higher dimensional
space. We have not used them yet for any other purpose. Regular
complexes are built by constructing vertices and simplices, by
assigning positions to vertices and vertices to simplices, and by
establishing neighbor relations. The update operations do not check
whether the data structure built actually encodes a simplicial
complex.  The class provides a function |check()| that performs a
partial check whether the data structure encodes a simplicial
complex. It is not checked whether two simplices intersect without
sharing a face.
}*/

template <class TRAITS,class POINT>
class regl_complex 
{ 
public:
/*{\Mtypes 4}*/
typedef rc_Vertex<TRAITS,POINT>*  rc_vertex;
/*{\Mtypemember the item type for vertices of the complex.}*/

typedef rc_Simplex<TRAITS,POINT>* rc_simplex;
/*{\Mtypemember the item type for simplices of the complex.}*/

#ifdef DDGEO_STL_ITERATORS

class rc_vertex_iterator;
class rc_simplex_iterator;

friend class rc_vertex_iterator;
friend class rc_simplex_iterator;

class rc_vertex_iterator {
/*{\Mtypemember the const iterator for vertices.}*/
  friend class regl_complex<TRAITS,POINT>;
  const regl_complex<TRAITS,POINT>* RC;
  list_item it;
  rc_vertex_iterator(const regl_complex<TRAITS,POINT>* x, 
  list_item y) : RC(x), it(y)  {}
public:
  rc_vertex_iterator() : RC(0),it(0) {}
  rc_vertex_iterator& operator++()
  { it = RC->all_verts.stl_next_item(it); return *this; }
  rc_vertex_iterator& operator--()    
  { it = RC->all_verts.stl_pred_item(it); return *this; }
  rc_vertex_iterator  operator++(int) 
  { rc_vertex_iterator tmp = *this; ++(*this); return tmp; }
  rc_vertex_iterator  operator--(int) 
  { rc_vertex_iterator tmp = *this; --(*this); return tmp; }
  const rc_vertex& operator*() const 
  { return (const rc_vertex&)RC->all_verts[it]; }
  list_item* operator->() { return &it; }
  friend bool operator==(const rc_vertex_iterator& x, 
                         const rc_vertex_iterator& y) 
  { return x.it == y.it; }

  typedef rc_vertex  value_type;
  typedef rc_vertex* pointer;
  typedef rc_vertex& reference;
  typedef bidirectional_iterator_tag iterator_category;
  typedef ptrdiff_t difference_type;
  LEDA_MEMORY(rc_vertex_iterator)
};

class rc_simplex_iterator {
/*{\Mtypemember the const iterator for simplices.}*/
  friend class regl_complex<TRAITS,POINT>;
  const regl_complex<TRAITS,POINT>* RC;
  list_item it;
  rc_simplex_iterator(const regl_complex<TRAITS,POINT>* x, 
  list_item y) : RC(x), it(y)  {}
public:
  rc_simplex_iterator() : RC(0),it(0) {}
  rc_simplex_iterator& operator++()
  { it = RC->all_simps.stl_next_item(it); return *this; }
  rc_simplex_iterator& operator--()    
  { it = RC->all_simps.stl_pred_item(it); return *this; }
  rc_simplex_iterator  operator++(int) 
  { rc_simplex_iterator tmp = *this; ++(*this); return tmp; }
  rc_simplex_iterator  operator--(int) 
  { rc_simplex_iterator tmp = *this; --(*this); return tmp; }
  const rc_simplex& operator*() const 
  { return (const rc_simplex&)RC->all_simps[it]; }
  list_item* operator->() { return &it; }
  friend bool operator==(const rc_simplex_iterator& x, 
                         const rc_simplex_iterator& y) 
  { return x.it == y.it; }

  typedef rc_simplex  value_type;
  typedef rc_simplex* pointer;
  typedef rc_simplex& reference;
  typedef bidirectional_iterator_tag iterator_category;
  typedef ptrdiff_t difference_type;
  LEDA_MEMORY(rc_simplex_iterator)
};

#endif

protected:
  int dcur;                   // dimension of the current complex
  int dmax;                   // dimension of ambient space

  list<rc_vertex>  all_verts; // list of all vertices
  list<rc_simplex> all_simps; // list of all simplices


/* the default copy constructor and assignment operator for class
   regl_complex work incorrectly; it is therefore good practice to
   either implement them correctly or to make them inaccessible. We do
   the latter. */

private:

  regl_complex(const regl_complex<TRAITS,POINT>& ); 
  regl_complex& operator=(const regl_complex<TRAITS,POINT>& ); 
  void clean_dynamic_memory()
  {
    rc_simplex s;  
    while (!all_simps.empty()) {
      s = all_simps.pop();
      delete(s); 
    }
    rc_vertex v;  
    while (!all_verts.empty()) { 
      v = all_verts.pop();
      delete(v); 
    }
  }

public:
  POINT nil_point;

  
  /*{\Mcreation}*/

  regl_complex(int d = 2) : nil_point() { dmax = d; dcur = -1; }
  /*{\Mcreate creates an instance |\Mvar| of type |\Mtype|. The
  dimension of the underlying space is $d$ and |\Mvar| is initialized to
  the empty regular complex.  Thus |dcur| equals $-1$. The traits class
  |TRAITS| specifies the models of all types and the implementations of
  all geometric primitives used by the regular complex class.

  In the following we use further template parameters like the point
  type |POINT=TRAITS::POINT|.  At this point, it suffices to say that
  |POINT| represents points in $d$-space. The complete specification of
  the traits class is to be found in section \ref{rctraitsclass}.}*/

  /*{\Mtext The above template instantiation works only for compilers
  which can handle \textit{template default arguments}. The exact
  template prototype is [[<TRAITS, POINT = TRAITS::POINT>]].  
  In case you use a compiler without that feature please write
  [[regl_complex<TRAITS,POINT>]] where we write [[\Mname]] after
  providing [[POINT]] in the global scope.  }*/ 

  ~regl_complex() { clean_dynamic_memory(); }

  /* In the destructor for |regl_complex|, we have to release the
     storage which was allocated for the simplices and the vertices. */

  /*{\Mtext The data type |\Mtype| offers neither copy constructor nor 
            assignment operator.}*/

  /*{\Moperations 3 3}*/
  /*{\Mtext \headerline{Access Operations}}*/

  int dim() const     { return dmax; }
  /*{\Mop returns the dimension of ambient space}*/

  int dcurrent() const { return dcur; }
  /*{\Mop returns the common dimension of the simplices in the
          complex.}*/

  rc_vertex vertex(rc_simplex s, int i) const 
  { return (s->vertices[i]); }
  /*{\Mop returns the $i$-th vertex of $s$.\\
  \precond $0 \leq i \leq |dcur|$. }*/

  POINT associated_point(rc_vertex v) const 
  { return (v->ass_point); }
  /*{\Mop returns the point associated with vertex |v|.}*/

  int index(rc_vertex v) const 
  { return v->index; }
  /*{\Mop returns the index of $v$ in |C.simplex(v)|.}*/

  rc_simplex simplex(rc_vertex v) const 
  { return v->sim; } 
  /*{\Mop returns a simplex of which $v$ is a vertex. Note that this
          simplex is not unique. }*/

  POINT associated_point(rc_simplex s, int i) const
  { return associated_point(vertex(s,i)); }
  /*{\Mop same as |C.associated_point(C.vertex(s,i))|. }*/

  rc_simplex opposite_simplex(rc_simplex s,int i) const 
  { return s->neighbors[i]; }
  /*{\Mop returns the simplex opposite to the $i$-th vertex of $s$
          (|nil| is there is no such simplex).\\ 
          \precond $0 \leq i \leq |dcur|$. }*/

  int index_of_opposite_vertex(rc_simplex s, int i) const
  { return s->opposite_vertices[i]; }
  /*{\Mop returns the index of the vertex opposite to the $i$-th vertex
          of $s$.\\ 
          \precond $0 \leq i \leq |dcur|$ and there is a
          simplex opposite to the $i$-th vertex of $s$. }*/


  /*{\Mtext \headerline{Update Operations}

  We give operations that allow to update a regular complex. They have
  to be used with care as they may invalidate the data structure.}*/


  void init(int d = 2)
  /*{\Mop reinitializes |\Mvar| to the empty complex in dimension |dim|.}*/
  { 
    clean_dynamic_memory();
    dmax = d; 
    dcur = -1; 
  }


  void set_dcur(int d) { dcur = d; }
  /*{\Mop sets |dcur| to |d|. }*/

  rc_simplex new_simplex() 
  { 
    rc_simplex s = new rc_Simplex<TRAITS,POINT>(dcur);
    all_simps.append(s);
    return s;
  }
  /*{\Mop adds a new simplex to |\Mvar| and returns it. The new simplex
          has no vertices yet.}*/

  rc_vertex  new_vertex() 
  { 
    rc_vertex v = new rc_Vertex<TRAITS,POINT>(nil_point);
    all_verts.append(v);
    return v;
  }
  /*{\Mop adds a new vertex to |\Mvar| and returns it. The new vertex
          has no associated simplex nor index yet. The associated point
          is the point |regl_complex::nil_point| which is a static
          member of class |regl_complex.|}*/

  rc_vertex  new_vertex(const POINT& p) 
  { 
    rc_vertex v = new rc_Vertex<TRAITS,POINT>(p);
    all_verts.append(v);
    return v;
  }
  /*{\Mop adds a new vertex to |\Mvar| and returns it. The new vertex
          has |p| as the associated point, but is has no associated
          simplex nor index yet.}*/

  void assoc_vertex_with_simplex(rc_simplex s, int i, rc_vertex v)
  { 
    s -> vertices[i] = v; 
    if (v != nil) {
      v -> sim = s;
      v -> index = i ;
    }
  }
  /*{\Mop sets the $i$-th vertex of |s| to |v| and records this fact in
          $v$. The latter occurs only if $v$ is non-nil.}*/

  void assoc_point_with_vertex(rc_vertex v, const POINT& p)
  { v -> ass_point = p; }
  /*{\Mop sets the point associated with $v$ to $p$.}*/

  void set_neighbor(rc_simplex s, int i, rc_simplex s1, int j)
  { 
    s  -> neighbors[i] = s1;
    s1 -> neighbors[j] = s; 
    s  -> opposite_vertices[i] = j;
    s1 -> opposite_vertices[j] = i;
  }
  /*{\Mop sets the neihbor opposite to vertex $i$ of |s| to |s1| and
          records vertex $j$ of |s1| as the vertex opposite to $i$.}*/

  void check_topology() const;
  /*{\Mop Partially checks whether |\Mvar| is an abstract simplicial
  complex. This function terminates without error if each vertex is a
  vertex of the simplex of which it claims to be a vertex, if the
  vertices of all simplices are pairwise distinct, if the neighbor
  relationship is symmetric, and if neighboring simplices share exactly
  |dcur| vertices.  It returns an error message if one of these
  conditions is violated.  Note that it is not checked whether simplices
  that share |dcur| vertices are neighbors in the data structure.}*/

  void check_topology_and_geometry() const;
  /*{\Mop In addition to the above, this function checks whether all
  vertices have an associated point different from
  |regl_complex::nil_point| and whether the points associated with the
  vertices of any simplex are affinely independent. It returns an error
  message otherwise.  Note that it is not checked whether the
  intersection of any two simplices is a facet of both.}*/



  void print_statistics()
  { 
    newline;
    cout << "regl_complex - statistic" << endl;
    cout << "number of vertices = " << all_verts.size() << endl;
    cout << "number of simplices = " << all_simps.size() << endl;
    newline; 
  }


  /*{\Mtext \headerline{Lists and Iterators}
  \setopdims{3cm}{2cm}}*/

  list<rc_simplex> all_simplices() const 
  { return all_simps; }
  /*{\Mop returns the set of all maximal simplices in |\Mvar|.}*/

  list<rc_vertex> all_vertices() const 
  { return all_verts; }
  /*{\Mop returns the set of all vertices in |\Mvar|.}*/

  #ifdef DDGEO_STL_ITERATORS
  /*{\Mtext The following iterator accessors are only activated using
  the compiler flag [[-DDDGEO_STL_ITERATORS]]. }*/

  rc_vertex_iterator vertices_begin() const
  { return rc_vertex_iterator(this,all_verts.first_item()); }
  /*{\Mop returns the start iterator for vertices of |\Mvar|.}*/

  rc_vertex_iterator vertices_end() const
  { return rc_vertex_iterator(this,
      all_verts.stl_next_item(all_verts.last_item())); }
  /*{\Mop returns the past the end iterator for vertices of |\Mvar|.}*/

  rc_simplex_iterator simplices_begin() const
  { return rc_simplex_iterator(this,all_simps.first_item()); }
  /*{\Mop returns the start iterator for simplices of |\Mvar|.}*/

  rc_simplex_iterator simplices_end() const
  { return rc_simplex_iterator(this,
      all_simps.stl_next_item(all_simps.last_item())); }
  /*{\Mop returns the past the end iterator for simplices of |\Mvar|.}*/

  #endif //DDGEO_STL_ITERATORS


};





/*{\Mtext \headerline{Visualization and conversion in low dimensions}}*/

template <class TRAITS,class POINT>
void d2_show(const regl_complex<TRAITS,POINT>& R, window& W);
/*{\Mfunc displays the regular complex R in window W.\\
\precond |dim == 2|.}*/

template <class TRAITS,class POINT>
void d2_map(const regl_complex<TRAITS,POINT>& R, GRAPH<POINT,int>& G);
/*{\Mfunc constructs the representation of |R| as a bidirected graph |G|.\\
\precond |dim == 2|.}*/

template <class TRAITS,class POINT>
void d3_graph(const regl_complex<TRAITS,POINT>& R, GRAPH<POINT,int>& G);
/*{\Mfunc constructs the representation of |R| as a bidirected graph |G|.\\
\precond |dim == 3|.}*/



#define forall_rc_simplices(s,C) forall(s,(C).all_simplices())
#define forall_rc_vertices(v,C)  forall(v,(C).all_vertices())

/*{\Mtext 
\headerline{Iteration Statements}

{\bf forall\_rc\_simplices}($s,C$)       
$\{$ ``the simplices of $C$ are successively assigned to $s$'' $\}$

{\bf forall\_rc\_vertices}($v,C$)       
$\{$ ``the vertices of $C$ are successively assigned to $v$'' $\}$

}*/

/*{\Mimplementation Each simplex stores its vertices, the adjacent
simplices, and the opposite vertices in arrays. The space requirement
for a simplex is $3 * |dim| * 4$ Bytes for the contents of the arrays
plus the actual space for the points plus the constant space overhead
for the arrays (see the manual pages for arrays).

The class |regl_complex| needs constant space plus space for a list of
simplices (which is about 12 bytes per simplex). The total space
requirement is therefore about $12(|dim| + 2)$ bytes times the number
of simplices.  }*/



#ifdef THIS_SHOULD_NEVER_BE_PARSED

/*{\Moptions
outfile=regltraits.man
}*/

/*{\Manpage {TRAITS} {} {The Traits Class for Regular Complexes} {}}*/
/*{\Mtext \label{rctraitsclass} }*/

/*{\Mdefinition The class |\Mname| allows the adaptation of the
regular complex class to an environment. It defines the model for the
type |POINT|, and the implementations for the geometric primitives
used by it.  In order to adapt the regular complex class to a new
environment, the class |\Mname| must be defined appropriately. We
specify the requirements for the class |\Mname| below.}*/


class TRAITS { 
/*{\Mcreation}*/
/*{\Mtext There are no constructors necessary as this type only provides
necessary operations by inline static operations.}*/

public:
/*{\Mtypes 2}*/
typedef user_point_type POINT;  // vertex type = chull<POINT,..>
/*{\Mtypedef instantiates the point class. POINT must be able to represent
points in $d$-space.}*/

/*{\Moperations 2 3}*/

static bool affinely_independent(const array<POINT>& A);
/*{\Mstatic decides whether the points in $A$ are affinely independent.}*/

/*{\Mtext The following Operations are needed if the visualization and
graph modules of LEDA are used. Users can omit them if they don't use
the corresponding operations. }*/

static int orientation(const POINT& p1, const POINT& p2,
                       const POINT& p3);
/*{\Mstatic determines the orientation of the points $p1,p2,p3$
in $2$-space. Implementation \emph{only necessary} if |d2_map| is used.}*/

static point to_d2_point(const POINT& p);
/*{\Mstatic converts the point to a $2d$ LEDA point. Implementation
\emph{only necessary} if |d2_show| is used.}*/

};

#endif // THIS_SHOULD_NEVER_BE_PARSED


#include <CGAL/dd_geo/regl_complex.C>

#if LEP_DDGEO_INCL_ID == 21029
#undef LEDA_ROOT_INCL_ID
#undef LEP_DDGEO_INCL_ID
#include <LEDA/UNDEFINE_NAMES.h>
#endif

#endif // CGAL_DD_GEO_REGL_COMPLEX_H

