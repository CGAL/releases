// ======================================================================
//
// Copyright (c) 1999 The GALIA Consortium
//
// This software and related documentation is part of the
// Computational Geometry Algorithms Library (CGAL).
//
// Every use of CGAL requires a license. Licenses come in three kinds:
//
// - For academic research and teaching purposes, permission to use and
//   copy the software and its documentation is hereby granted free of  
//   charge, provided that
//   (1) it is not a component of a commercial product, and
//   (2) this notice appears in all copies of the software and
//       related documentation.
// - Development licenses grant access to the source code of the library 
//   to develop programs. These programs may be sold to other parties as 
//   executable code. To obtain a development license, please contact
//   the GALIA Consortium (at cgal@cs.uu.nl).
// - Commercialization licenses grant access to the source code and the
//   right to sell development licenses. To obtain a commercialization 
//   license, please contact the GALIA Consortium (at cgal@cs.uu.nl).
//
// This software and documentation is provided "as-is" and without
// warranty of any kind. In no event shall the CGAL Consortium be
// liable for any damage of any kind.
//
// The GALIA Consortium consists of Utrecht University (The Netherlands),
// ETH Zurich (Switzerland), Free University of Berlin (Germany),
// INRIA Sophia-Antipolis (France), Martin-Luther-University Halle-Wittenberg
// (Germany), Max-Planck-Institute Saarbrucken (Germany),
// and Tel-Aviv University (Israel).
//
// ----------------------------------------------------------------------
// 
// release       : CGAL-2.0
// release_date  : 1999, June 03
// 
// source        : 
// file          : include/CGAL/Arithmetic_filter/predicates_on_rtH2.h
// package       : Interval_arithmetic (4.15)
// revision      : 2.1.2
// revision_date :
// author(s)     : Sylvain.Pion
//
// coordinator   : MPI, Saarbruecken
// email         : cgal@cs.uu.nl
//
// ======================================================================


#ifndef CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H
#define CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H

// This file is automatically generated by the script for filtering
// predicates, using Interval arithmetic.

CGAL_BEGIN_NAMESPACE

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Orientation
orientationH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                    
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                    
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Orientation result = orientationH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return orientationH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
leftturnH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = leftturnH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return leftturnH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
rightturnH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = rightturnH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return rightturnH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
collinearH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = collinearH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return collinearH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
}
#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Bounded_side
side_of_bounded_circleH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Bounded_side result = side_of_bounded_circleH2(
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval(),
		shx.interval(),
		shy.interval(),
		shw.interval(),
		thx.interval(),
		thy.interval(),
		thw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return side_of_bounded_circleH2(
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact(),
		shx.exact(),
		shy.exact(),
		shw.exact(),
		thx.exact(),
		thy.exact(),
		thw.exact());
  }
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Oriented_side
side_of_oriented_circleH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Oriented_side result = side_of_oriented_circleH2(
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval(),
		shx.interval(),
		shy.interval(),
		shw.interval(),
		thx.interval(),
		thy.interval(),
		thw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return side_of_oriented_circleH2(
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact(),
		shx.exact(),
		shy.exact(),
		shw.exact(),
		thx.exact(),
		thy.exact(),
		thw.exact());
  }
}
#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Comparison_result
compare_lexicographically_xyH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                                    
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw)
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Comparison_result result = compare_lexicographically_xyH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return compare_lexicographically_xyH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact());
  }
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Comparison_result
compare_xH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                  
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Comparison_result result = compare_xH2(
		phx.interval(),
		phw.interval(),
		qhx.interval(),
		qhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return compare_xH2(
		phx.exact(),
		phw.exact(),
		qhx.exact(),
		qhw.exact());
  }
}

// No compare_yH2; use compare_xH2( py, pw, qy, qw)

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Comparison_result
compare_deltax_deltayH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                             
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                             
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw,
                             
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shw )
  
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>  tbc1 = abs(phx*qhw - qhx*phw) * rhw*shw;
  
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>  tbc2 = abs(rhy*shw - shy*rhw) * phw*qhw;
  return (tbc2 < tbc1) ? LARGER
                       : (tbc1 == tbc2) ? EQUAL : SMALLER;


template <class Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>>
// CGAL_KERNEL_INLINE
bool
collinear_are_ordered_along_lineH2(
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw
                                       )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Comparison_result result = collinear_are_ordered_along_lineH2(
		phx.interval(),
		phw.interval(),
		qhx.interval(),
		qhw.interval(),
		rhy.interval(),
		rhw.interval(),
		shy.interval(),
		shw.interval(),
		phw.interval(),
		s.interval(),
		rhw.interval(),
		q.interval(),
		tbc1.interval(),
		LARGER.interval(),
		tbc2.interval(),
		S.interval(),
		.interval());		CGAL_KERNEL_INLINE.interval(),
		bool.interval(),
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval(),
		.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return collinear_are_ordered_along_lineH2(
		phx.exact(),
		phw.exact(),
		qhx.exact(),
		qhw.exact(),
		rhy.exact(),
		rhw.exact(),
		shy.exact(),
		shw.exact(),
		phw.exact(),
		s.exact(),
		rhw.exact(),
		q.exact(),
		tbc1.exact(),
		LARGER.exact(),
		tbc2.exact(),
		S.exact(),
		.exact());		CGAL_KERNEL_INLINE.exact(),
		bool.exact(),
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact(),
		.exact());
  }
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
collinear_are_strictly_ordered_along_lineH2(
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw)
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = collinear_are_strictly_ordered_along_lineH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return collinear_are_strictly_ordered_along_lineH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
}



CGAL_END_NAMESPACE


#ifdef CGAL_ARITHMETIC_FILTER_H
#include <CGAL/Arithmetic_filter/predicates_on_rtH2.h>
#endif // CGAL_ARITHMETIC_FILTER_H

#endif // CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H
