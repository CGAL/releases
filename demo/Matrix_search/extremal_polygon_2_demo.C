// ============================================================================
//
// Copyright (c) 1999 The GALIA Consortium
//
// This software and related documentation is part of the
// Computational Geometry Algorithms Library (CGAL).
//
// Every use of CGAL requires a license. Licenses come in three kinds:
//
// - For academic research and teaching purposes, permission to use and
//   copy the software and its documentation is hereby granted free of  
//   charge, provided that
//   (1) it is not a component of a commercial product, and
//   (2) this notice appears in all copies of the software and
//       related documentation.
// - Development licenses grant access to the source code of the library 
//   to develop programs. These programs may be sold to other parties as 
//   executable code. To obtain a development license, please contact
//   the GALIA Consortium (at cgal@cs.uu.nl).
// - Commercialization licenses grant access to the source code and the
//   right to sell development licenses. To obtain a commercialization 
//   license, please contact the GALIA Consortium (at cgal@cs.uu.nl).
//
// This software and documentation is provided "as-is" and without
// warranty of any kind. In no event shall the CGAL Consortium be
// liable for any damage of any kind.
//
// The GALIA Consortium consists of Utrecht University (The Netherlands),
// ETH Zurich (Switzerland), Free University of Berlin (Germany),
// INRIA Sophia-Antipolis (France), Martin-Luther-University Halle-Wittenberg
// (Germany), Max-Planck-Institute Saarbrucken (Germany),
// and Tel-Aviv University (Israel).
//
// ----------------------------------------------------------------------
//
// release       : CGAL-2.0
// release_date  : 1999, June 03
//
// file          : extremal_polygon_2_demo.C
// chapter       : $CGAL_Chapter: Geometric Optimisation $
// package       : $CGAL_Package: Matrix_search $
// source        : mon_search.aw
// revision      : $Revision: 1.17 $
// revision_date : $Date: 1999/06/01 14:06:59 $
// author(s)     : Michael Hoffmann
//
// coordinator   : ETH Zurich (Bernd Gaertner)
//
// Demo program: Compute extremal polygons of a convex polygon
// email         : cgal@cs.uu.nl
//
// ======================================================================

#ifndef CGAL_CARTESIAN_H
#include <CGAL/Cartesian.h>
#endif // CGAL_CARTESIAN_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H
#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_SQUARED_DISTANCE_2_H
#include <CGAL/squared_distance_2.h>
#endif // CGAL_SQUARED_DISTANCE_2_H
#ifndef CGAL_DISTANCE_PREDICATES_2_H
#include <CGAL/distance_predicates_2.h>
#endif // CGAL_DISTANCE_PREDICATES_2_H
#ifndef CGAL_CONVEX_HULL_2_H
#include <CGAL/convex_hull_2.h>
#endif // CGAL_CONVEX_HULL_2_H
#ifndef CGAL_CIRCULATOR_H
#include <CGAL/circulator.h>
#endif // CGAL_CIRCULATOR_H
#ifndef CGAL_EXTREMAL_POLYGON_2_H
#include <CGAL/extremal_polygon_2.h>
#endif // CGAL_EXTREMAL_POLYGON_2_H
#ifndef CGAL_POINT_GENERATORS_2_H
#include <CGAL/point_generators_2.h>
#endif // CGAL_POINT_GENERATORS_2_H
#ifndef CGAL_RANDOM_CONVEX_SET_2_H
#include <CGAL/random_convex_set_2.h>
#endif // CGAL_RANDOM_CONVEX_SET_2_H
#ifndef CGAL_IO_LEDA_WINDOW_H
#include <CGAL/IO/leda_window.h>
#endif // CGAL_IO_LEDA_WINDOW_H
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>

using CGAL::cgalize;
using CGAL::has_smaller_dist_to_point;
using CGAL::RED;
using std::back_inserter;
using std::copy;
using std::max;

using std::vector;
using CGAL::Cartesian;
using CGAL::Random_access_circulator_from_container;
using CGAL::convex_hull_points_2;
using CGAL::squared_distance;
using CGAL::maximum_area_inscribed_k_gon;
using CGAL::maximum_perimeter_inscribed_k_gon;
using CGAL::Random_points_in_square_2;
using CGAL::Creator_uniform_2;
using CGAL::random_convex_set_2;

typedef double                                    FT;
typedef Cartesian< FT >                           RepClass;
typedef CGAL::Point_2< RepClass >                 Point;
typedef CGAL::Segment_2< RepClass >               Segment;
typedef vector< Point >                           PointCont;
typedef PointCont::iterator                       PointIter;
typedef vector< PointIter >                       PointIterCont;
typedef vector< PointIter >::iterator             PointIterIter;
typedef RepClass::FT                              FT;
typedef PointCont                                 Polygon;
typedef PointCont::iterator                       Vertex_iterator;
typedef Random_access_circulator_from_container< Polygon >
  Vertex_circulator;
typedef PointCont::const_iterator                 Vertex_const_iterator;
typedef vector< Vertex_iterator >                 Vertex_iteratorCont;
typedef Vertex_iteratorCont::iterator             Vertex_iteratorIter;

#ifdef EXTREMAL_POLYGON_MEASURE
#ifndef CGAL_PROTECT_CTIME
#include <ctime>
#define CGAL_PROTECT_CTIME
#endif
static time_t Measure;
static long long int measure;
#define MEASURE(comm) \
  Measure = clock(); \
  comm; \
  measure = \
    (long long int)((float)(clock() - Measure) * 1000 / CLOCKS_PER_SEC); \
    cout << "[time: " << measure << " msec]" << endl;
#else
#define MEASURE(comm) comm
#endif
void
wait_for_button_release( leda_window& W)
{
  // wait until mouse button is released
  double x, y;
  int v;
  do {}
  while ( W.read_event( v, x, y) != button_release_event);
}

int
main()
{
  leda_window W( 650, 650);
  int k( 3);
  W.int_item( "k", k, 2, 12, "#vertices of polygon to inscribe");
  int n( 3);
  W.int_item( "n", n, "#vertices of polygon");
  int compute_mode( 0);
  W.choice_item( "criterion",
                 compute_mode,
                 "Determine the criterion to maximize.",
                 3,
                 "Area",
                 "Perimeter",
                 "Both");
  int compute_button(
    W.button( "Compute",
              "Compute largest inscribed k-gon"));
  int generate_button(
    W.button( "Generate",
              "Generate random convex polygon"));
  int help_button(
    W.button( "Help",
              "Explain the program and its mouse interaction."));
  int quit_button(
    W.button( "End",
              "Quit Program"));
  cgalize( W);
  W.display();
  W.init( -1.5, 1.5, -1.5);

  PointCont points;
  Polygon p;
  bool polygon_changed( false);

  for (;;) {
    if (polygon_changed) {
      // compute convex hull:
      PointCont ch_points;
      convex_hull_points_2(points.begin(),
                           points.end(),
                           back_inserter(ch_points));
    
      // replace points by ch_points:
      points.erase(points.begin(), points.end());
      points.insert(points.begin(), ch_points.begin(), ch_points.end());
    
      // construct polygon and data structure for point location:
      p.erase(p.begin(), p.end());
      copy(points.begin(), points.end(), back_inserter(p));
    
      polygon_changed = false;
    } // if ( polygon_changed)
    
    // show polygon:
    W.clear();
    if ( !p.empty()) {
      Vertex_const_iterator i( p.begin());
      for (;;) {
        W << RED << *i;
        W.set_fg_color( leda_blue);
        if ( (i+1) == p.end()) {
          W << Segment( *i, *(p.begin()));
          break;
        }
        else {
          W << Segment( *i, *(i+1));
          ++i;
        }
      } // for (;;)
    } // if ( !p.empty())
    
    char vertices_message[80];
    int num( points.size());
    sprintf( vertices_message,
             "Polygon has %d vertices.",
             num);
    W.message( vertices_message);
    
    

    if ( compute_mode != 1) {
      // compute maximum area inscribed k-gon:
      k = max( 3, k);
      PointCont k_gon;
      if ( p.size() >= 3) {
        MEASURE(maximum_area_inscribed_k_gon(
          p.begin(),
          p.end(),
          k,
          back_inserter( k_gon));)
        W.set_fg_color( leda_green);
        if ( !p.empty()) {
          PointIter i( k_gon.begin());
          while ( ++i != k_gon.end())
            W << Segment( *(i-1), *i);
          W << Segment( *--i, *(k_gon.begin()));
        } // if ( !p.empty())
      } // if ( p.size() >= 3)
    } // if ( compute_mode != 1)
    if ( compute_mode != 0) {
      // compute maximum perimeter inscribed k-gon:
      PointCont k_gon;
#ifndef CGAL_CFG_NO_MEMBER_TEMPLATES
      MEASURE(maximum_perimeter_inscribed_k_gon(
        Vertex_circulator( &p),
        Vertex_circulator( &p),
        k,
        back_inserter( k_gon));)
#else
      MEASURE(maximum_perimeter_inscribed_k_gon(
        p.begin(),
        p.end(),
        k,
        back_inserter( k_gon));)
#endif
      W.set_fg_color( leda_orange);
      if ( !p.empty()) {
        PointIter i( k_gon.begin());
        while ( ++i != k_gon.end())
          W << Segment( *(i-1), *i);
        W << Segment( *--i, *(k_gon.begin()));
      } // if ( !p.empty())
    } // if ( compute_mode != 0)

    // wait for input:
    int input;
    for (;;) {
      double x( 0), y( 0);
      input = W.get_mouse( x, y);
      if ( input == MOUSE_BUTTON( 2)) {
        // move point
        
        // find nearest vertex
        Point sp(x, y);
        PointIter nearest = points.begin();
        PointIter k = nearest;
        while (++k != points.end())
          if (has_smaller_dist_to_point(sp, *k, *nearest))
            nearest = k;
        
        // test for snapping:
        if ( squared_distance( *nearest, Point( x, y)) < FT( 0.05)) {
          int v( 0);
          drawing_mode old_drawing_mode( W.set_mode( leda_xor_mode));
          leda_color old_color( W.set_color( leda_grey1));
          x = (*nearest).x();
          y = (*nearest).y();
          do {
            if ( nearest == points.begin()) {
              W.draw_segment( (*(points.end() - 1)).x(),
                              (*(points.end() - 1)).y(),
                              (*nearest).x(),
                              (*nearest).y());
              if ( points.size() > 2)
                W.draw_segment( (*(points.end() - 1)).x(),
                                (*(points.end() - 1)).y(),
                                x,
                                y);
            }
            else {
              W.draw_segment( (*(nearest - 1)).x(),
                              (*(nearest - 1)).y(),
                              (*nearest).x(),
                              (*nearest).y());
              if ( points.size() > 2)
                W.draw_segment( (*(nearest - 1)).x(),
                                (*(nearest - 1)).y(),
                                x,
                                y);
            }
            if ( nearest == (points.end() - 1)) {
              W.draw_segment( (*(points.begin())).x(),
                              (*(points.begin())).y(),
                              (*nearest).x(),
                              (*nearest).y());
              if ( points.size() > 2)
                W.draw_segment( (*(points.begin())).x(),
                                (*(points.begin())).y(),
                                x,
                                y);
            }
            else {
              W.draw_segment( (*(nearest + 1)).x(),
                              (*(nearest + 1)).y(),
                              (*nearest).x(),
                              (*nearest).y());
              if ( points.size() > 2)
                W.draw_segment( (*(nearest + 1)).x(),
                                (*(nearest + 1)).y(),
                                x,
                                y);
            }
        
            // set new point:
            *nearest = Point( x, y);
        
          } while ( W.read_event( v, x, y) != button_release_event);
        
        
          // restore parameters of W:
          W.set_mode( old_drawing_mode);
          W.set_color( old_color);
        
          polygon_changed = true;
          break;
        }
      }
      else if ( input == MOUSE_BUTTON( 3)) {
        // delete point
        
        // find nearest vertex
        Point sp(x, y);
        PointIter nearest = points.begin();
        PointIter k = nearest;
        while (++k != points.end())
          if (has_smaller_dist_to_point(sp, *k, *nearest))
            nearest = k;
        
        // test for snapping:
        if (squared_distance(*nearest, Point(x, y)) < FT(0.05)) {
          points.erase(nearest);
          polygon_changed = true;
          break;
        }    
      }
      else if ( input == help_button) {
        // display help text
        W.del_messages();
        W.message( "CGAL MONOTONE MATRIX SEARCH TEST");
        W.message( "");
        W.message( "compute maximal inscribed k-gon of a convex polygon");
        W.message( "(maximal with respect to either area or perimeter)");
    
        W.message( "");
        W.message( "");
        W.message( "Mouse Input:");
        W.message( "");
        W.message( " <left mouse button>      -  insert vertex");
        W.message( " <middle mouse button> -  move vertex");
        W.message( " <right mouse button>     -  delete vertex");
      }
      else if ( input == quit_button)
        // quit program
        return 0;
      else if ( input == generate_button) {
        // generate random convex polygon with n vertices
        typedef Random_points_in_square_2<
          Point,
          Creator_uniform_2< FT, Point >
        >
        Point_generator;
        
        points.erase( points.begin(), points.end());
        n = max( n, 3);
        random_convex_set_2( n, back_inserter( points), Point_generator( 1));
        
        polygon_changed = true;
        break;
      }
      else if ( input == compute_button)
        // recompute largest inscribing k-gon
        break;
      else if ( input == MOUSE_BUTTON( 1)) {
        // insert point:
        points.push_back( Point( x, y));
        polygon_changed = true;
        break;
      }
    } // for (;;)
  } // for (;;)
} // int main()


// ----------------------------------------------------------------------------
// ** EOF
// ----------------------------------------------------------------------------

