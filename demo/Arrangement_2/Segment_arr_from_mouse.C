//constructs a segment arrangement from CGAL window.
// We use the leda traits (therefore we are using leda functions).

#include <CGAL/config.h> // needed for the LONGNAME flag

#ifdef CGAL_CFG_NO_LONGNAME_PROBLEM
// Define shorter names to please linker (g++/egcs)
#define Arrangement_2 Ar
#define Arr_leda_segment_exact_traits Alset
#define Arr_2_default_dcel A2d
#define In_place_list_iterator IPLI
#define Arr_2_vertex_base Avb
#define Arr_2_halfedge_base Ahb
#define Arr_2_face_base Afb
#define Point_2 pT
#define Segment_2 sT
#define Topological_map TpM
#define _List_iterator Lit
#define Halfedge hE
#define Forward_circulator_tag Fct
#endif

#include <CGAL/basic.h>

#ifndef CGAL_USE_LEDA
int main(int argc, char* argv[])
{

  std::cout << "Sorry, this demo needs LEDA for visualisation.";
  std::cout << std::endl;

  return 0;
}

#else

#include <CGAL/IO/Window_stream.h>
#include <CGAL/Arr_leda_segment_exact_traits.h>
#include <CGAL/Arr_2_bases.h>
#include <CGAL/Arr_2_default_dcel.h>
#include <CGAL/Arrangement_2.h>

#include <CGAL/IO/Window_stream.h>

#include <vector>

typedef CGAL::Arr_leda_segment_exact_traits         Traits;

typedef Traits::Point                                  Point;
typedef Traits::X_curve                                X_curve;

typedef CGAL::Arr_base_node<X_curve>   Base_node;
typedef CGAL::Arr_2_default_dcel<Traits> Dcel;

typedef CGAL::Arrangement_2<Dcel,Traits,Base_node > Arr_2;

//I had to add these in global namespace for the program to compile
CGAL::Window_stream& operator<<(CGAL::Window_stream& os,
                          const Point& p)
{
  //return os << leda_point(p.xcoordD(),p.ycoordD());
  return os << p.to_point();
}

CGAL::Window_stream& operator<<(CGAL::Window_stream& os,
                          const X_curve &c)
{
  //  return os << leda_segment(c.xcoord1D(),c.ycoord1D(),c.xcoord2D(),c.ycoord2D());
  return os << c.to_segment();
}

// global variables are used so that the redraw function for the LEDA window
// can be defined to draw information found in these variables.
static Arr_2 arr;
static CGAL::Window_stream W(400, 400, "CGAL - Segment Arrangement Demo");


CGAL_BEGIN_NAMESPACE

Window_stream& operator<<(Window_stream& os,
                          Arr_2 &A)
{
   Arr_2::Halfedge_iterator it = A.halfedges_begin();

   os << BLUE;

    while(it != A.halfedges_end()){

      os << (*it).curve();
      ++it; ++it;

    }

    os << GREEN;
    Arr_2::Vertex_iterator vit = A.vertices_begin();
    while(vit!=A.vertices_end()) {
      os << (*vit).point();
      ++vit;
    }

    os.set_flush( 1 );
    os.flush();

    return os;
}

CGAL_END_NAMESPACE

// redraw function for the LEDA window. used automatically when window reappears
void redraw(CGAL::Window_stream * wp) 
{ wp->start_buffering();
  wp->clear();
  // draw arragnement
  *wp << arr;
  wp->flush_buffer();
  wp->stop_buffering();
}


int main()
{
  double x0=-400,x1=400,y0=-400;

  W.init(x0,x1,y0);
  W.set_redraw(redraw);
  W.set_mode(leda_src_mode);
  W.set_node_width(3);
  W.button("finish",10);
  W.display();

  //read input from window
  std::cout << "left button to start and end the segment\n";
  std::cout << "clicking close to a vertex, assumes the location is at the vertex"
       << std::endl;

  std::vector<Point> cv1;

  Point pnt;
  bool begin=true;

  for (;;) {
    double x, y;
    int b = W.get_mouse(x,y);
    if (b==10) break;
    pnt = Point(x,y);
  
    if (b == MOUSE_BUTTON(1))
      {
        
        for(Arr_2::Vertex_iterator vi = arr.vertices_begin();
            vi != arr.vertices_end(); ++vi) {
          //we are using the leda sqr_dist func
          if ( pnt.sqr_dist(vi->point()) < ((x1-x0)/50)*((x1-x0)/50) )
            pnt=vi->point();
        }
        
        cv1.push_back(pnt);
        W << CGAL::BLACK;
        W << pnt;
        W << CGAL::GREEN;
        
        if (!begin) {
          arr.insert(X_curve(cv1[0],cv1[1]));
          cv1.clear();
          W << arr;
        }
        begin=!begin;
      }

  }

  
  W << arr;
   
  //LOCATION
  std::cout << "\nEnter a point with left button." << std::endl;
  W << CGAL::RED;

  Point p;

  Arr_2::Halfedge_handle e;
  
  for (; ; ) {

    double x,y;
    int b=W.read_mouse(x,y);
    if (b==10) break;
    else
      p=Point(x,y);

    W << arr;
    
    Arr_2::Locate_type lt;
    e = arr.locate(p,lt);

    //color the face on the screen
    Arr_2::Face_handle f=e->face();
    if (f->does_outer_ccb_exist()) {
      Arr_2::Ccb_halfedge_circulator cc=f->outer_ccb();
      do {
        W << cc->curve();
      } while (++cc != f->outer_ccb());
      
    }
    
    Arr_2::Holes_iterator hit=f->holes_begin(),eit=f->holes_end();
    for (;hit!=eit; ++hit) {
      Arr_2::Ccb_halfedge_circulator cc=*hit; 
      do {
        W << cc->curve();
      } while (++cc != *hit);

    }      
  }


  return 0;  
}

#endif // CGAL_USE_LEDA
