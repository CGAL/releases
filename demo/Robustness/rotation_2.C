// ============================================================================
//
// Copyright (c) 1999 The CGAL Consortium

// This software and related documentation is part of the Computational
// Geometry Algorithms Library (CGAL).
// This software and documentation is provided "as-is" and without warranty
// of any kind. In no event shall the CGAL Consortium be liable for any
// damage of any kind. 
//
// Every use of CGAL requires a license. 
//
// Academic research and teaching license
// - For academic research and teaching purposes, permission to use and copy
//   the software and its documentation is hereby granted free of charge,
//   provided that it is not a component of a commercial product, and this
//   notice appears in all copies of the software and related documentation. 
//
// Commercial licenses
// - A commercial license is available through Algorithmic Solutions, who also
//   markets LEDA (http://www.algorithmic-solutions.de). 
// - Commercial users may apply for an evaluation license by writing to
//   Algorithmic Solutions (contact@algorithmic-solutions.com). 
//
// The CGAL Consortium consists of Utrecht University (The Netherlands),
// ETH Zurich (Switzerland), Free University of Berlin (Germany),
// INRIA Sophia-Antipolis (France), Martin-Luther-University Halle-Wittenberg
// (Germany), Max-Planck-Institute Saarbrucken (Germany), RISC Linz (Austria),
// and Tel-Aviv University (Israel).
//
// ----------------------------------------------------------------------
// 
// release       : CGAL-2.2
// release_date  : 2000, September 30
// 
// source        : rotation.fw
// file          : demo/Robustness/rotation_2.C
// revision      : 1.5
// revision_date : 20 Sep 2000 
// author(s)     : Stefan Schirra
//
//
// coordinator   : MPI, Saarbruecken  (<Stefan.Schirra>)
// email         : contact@cgal.org
// www           : http://www.cgal.org
//
// ======================================================================
 

#include <CGAL/basic.h>
#ifndef CGAL_USE_LEDA
int main() { std::cout << "\nSorry, this demo needs LEDA\n"; return 0; }
#else
#include <CGAL/Homogeneous.h>
#include <CGAL/Cartesian.h>
#include <CGAL/Gmpz.h>
#include <cmath>
#include <vector>
#include <algorithm>
#include <CGAL/Point_2.h>
#include <CGAL/Direction_2.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Aff_transformation_2.h>
#include <CGAL/IO/leda_window.h>
#include <CGAL/IO/Ostream_iterator.h>
#include <CGAL/leda_real.h>
#include <CGAL/kernel_to_kernel.h>

typedef CGAL::Cartesian<double>           CartesianDouble;
typedef CGAL::Point_2<CartesianDouble>    Point;
typedef CGAL::Direction_2<CartesianDouble>     Direction;
typedef std::vector<Point>                Vector;
typedef CGAL::Homogeneous<CGAL::Gmpz>     HomogeneousInteger;
typedef CGAL::Cartesian<leda_real>        CartesianLedaReal;


int
main()
{
  Vector L;
  
  L.push_back( Point(6,0));
  L.push_back( Point(4,0));
  L.push_back( Point(2,0));
  L.push_back( Point(0,0));
  L.push_back( Point(3,0));
  L.push_back( Point(-4,0));
  L.push_back( Point(-2,0));
  L.push_back( Point(7,0));
  
  Vector C;
  
  C.push_back( Point(0,5));
  C.push_back( Point(3,4));
  C.push_back( Point(4,3));
  C.push_back( Point(5,0));
  // C.push_back( Point(-3,4));
  C.push_back( Point(-4,3));
  C.push_back( Point(-5,0));
  // C.push_back( Point(-3,-4));
  // C.push_back( Point(-4,-3));
  C.push_back( Point(0,-5));
  // C.push_back( Point(3,-4));
  C.push_back( Point(4,-3));
  
  
  typedef leda_window  CGAL_Stream;
  CGAL_Stream W( 950, 550);
  CGAL_Stream W1( 400, 400);
  CGAL_Stream W2( 400, 400);
  CGAL::cgalize(W);
  CGAL::cgalize(W1);
  CGAL::cgalize(W2);
  
  W.init( 0, 950, 0);
  W1.init(-8, 8, -8);
  W2.init(-8, 8, -8);
  W.display();
  W1.display(W,50,50);
  W2.display(W,500,50);
  
  W1.set_fg_color(leda_green2);
  std::copy( L.begin(), L.end(),
             CGAL::Ostream_iterator< Point, CGAL_Stream>( W1));
  W2 << CGAL::RED;
  std::copy( C.begin(), C.end(),
             CGAL::Ostream_iterator< Point, CGAL_Stream>( W2));

  Direction  dir = Direction( 7, 4);
  double alpha =  CGAL_CLIB_STD::atan( 7.0/4.0);

  CartesianDouble::Aff_transformation_2   rotate =
      CartesianDouble::Aff_transformation_2( CGAL::ROTATION,
                                             CGAL_CLIB_STD::sin( alpha),
                                             CGAL_CLIB_STD::cos( alpha));


  Vector LR;
  Vector CR;
  std::transform( L.begin(), L.end(), std::back_inserter(LR), rotate);
  std::transform( C.begin(), C.end(), std::back_inserter(CR), rotate);
  W1 << CGAL::GREEN;
  std::copy( LR.begin(), LR.end(),
             CGAL::Ostream_iterator< Point, CGAL_Stream>( W1));
  W2 << CGAL::ORANGE;
  std::copy( CR.begin(), CR.end(),
             CGAL::Ostream_iterator< Point, CGAL_Stream>( W2));

  
  int n = 0;
  int s = 0;
  leda_string str;
  leda_string trailer = leda_string("of all collinearity tests return true");
  
  typedef Vector::iterator   Iterator;
  Iterator i,j,k;
  for( i = L.begin(); i != L.end(); ++i)
      for( j = L.begin(); j != L.end(); ++j)
          for( k = L.begin(); k != L.end(); ++k)
          {
              if ( CGAL::collinear( *i, *j, *k) ) ++s;
              ++n;
          }
  str = leda_string("Before rotation, %2.2f%% ", 100.0* s/n );
  str += trailer;
  W.draw_ctext(250,60, str);
  
  
  n = 0;
  s = 0;
  for( i = LR.begin(); i != LR.end(); ++i)
      for( j = LR.begin(); j != LR.end(); ++j)
          for( k = LR.begin(); k != LR.end(); ++k)
          {
              if ( CGAL::collinear( *i, *j, *k) ) ++s;
              ++n;
          }
  str = leda_string("After rotation, only %2.2f%% ", 100.0* s/n );
  str += trailer;
  W.draw_ctext(250,40, str);
  
  
  Vector D;
  D.push_back( L.front());
  Point o = Point( CGAL::ORIGIN);
  CartesianDouble::Less_distance_to_point_2 less =
      CartesianDouble().less_distance_to_point_2_object(o);
  for ( i = CR.begin(); i != CR.end(); ++i)
  {
    bool new_distance = true;
    for ( j = D.begin(); j != D.end(); ++j)
    { if ( !( less( *i, *j))||( less( *j, *i)) ) new_distance = false; }
    if ( new_distance ) { D.push_back( *i); }
  }
  
  str = leda_string("%d different distances",
                    std::distance( D.begin(), D.end() ));
  W.draw_ctext(700,50,str);
  

  W.read_mouse();

  return 0;
}
#endif // USE_LEDA
