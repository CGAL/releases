#!/usr/local/bin/perl5
#
# Copyright (c) 1998-1999 The CGAL Consortium
#
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
#
# This script takes as STDIN "predicates_on_ftC2.h" or equivalent.
# It produces as STDOUT "Arithmetic_filter/predicates_on_ftC2.h" or equivalent.
#
# It is not supposed to be universal, and it can be considered a quick and
# dirty hack.  But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too (but the job can be done by hand if you
# don't have many to do).
#
# See the CGAL documentation:
# Support Library, Number Types, CGAL_Filtered_exact.
#

$in_header=1;
$in_def=0;
$in_decl=0;
$after_template=0;
$result_type="";
@args=();

while (<>)
{
  if (/^}$/) {
    $in_def=0;
    next;
  }
  next if ($in_def);
  if (/^{$/) {
    $after_template=0;
    $in_decl=0;
    $in_def=1;
    if (($result_type ne "CGAL_Sign") &&
        ($result_type ne "bool") &&
        ($result_type ne "CGAL_Comparison_result") &&
        ($result_type ne "CGAL_Orientation") &&
        ($result_type ne "CGAL_Oriented_side") &&
        ($result_type ne "CGAL_Bounded_side"))
      {print STDERR "Warning: $result_type is unknown\n"; }
    print
"{ // This is the default filter (specialisation).\n
  typedef CGAL_Interval_nt_advanced IA;\n
  $result_type result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = $function_name(
";
    foreach (@args) {
      print "\t\tCGAL_convert_to<IA>($_.value)";
      if ($_ ne $last_arg) { print ",\n"; }
      else { print ");"; }
    }
    print "
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = $function_name(
";
    foreach (@args) {
      print "\t\tCGAL_convert_to<ET>($_.value)";
      if ($_ ne $last_arg) { print ",\n"; }
      else { print ");"; }
    }
    print "
  }
  return result;
}
";
    # print "args: @args\n" ;
    @args=();
    next;
  }

  if ($after_template)
  {
    s/(CGAL_KERNEL_.*INLINE)/\/\/ $1/; # Comment the INLINE line.
    s/inline/\/\/ inline/;             # Comment the INLINE line.
    if ( /\(/ ) { $in_decl=1; }
    if (! $in_decl) {
      if (! (/INLINE/ || /inline/)) {
        $result_type = $_;
        chop($result_type);
        # print "RESULT_TYPE = $result_type\n";
      }
    }
    if ($in_decl)
    {
      @a = split /[,\)]/; # Stores the arguments names in @args.
      foreach (@a) {
	s/^.*\(//;
        next if /^$/;
        /(\w+)\s*$/;
        push(@args, $1);
        $last_arg=$1;
      }
      s/,[\s]*/,\n\t/g; # Split to make the lines < 80 characters.
      s/[RF]T/CGAL_Filtered_exact<CT,ET>/g;
    }
    if (/\(/) {
      /([a-zA-Z_]\w*)\s*\(/;
      $function_name=$1;
      # print "Function name: $function_name\n";
    }
  }
  if (/template/) { $after_template = 1; }
  s/template\s*<\s*class\s*[RF]T\s*>/template < class CT, class ET >/;

  if ($in_header)
  {
    s/\/\/ release[\s]*:.*/\/\/ release       :/g;
    s/\/\/ release_date[\s]*:.*/\/\/ release_date  :/g;
    if (/\/\/ file[\s]*: (.*)/)
      { $new_source_name= $1; s/CGAL/CGAL\/Arithmetic_filter/g; }
    s/\/\/ package[\s]*:.*/\/\/ package       : Interval_arithmetic/g;
    s/\/\/ source[\s]*:.*/\/\/ source        : $new_source_name/g;
    s/\/\/ author\(s\)[\s]*:.*/\/\/ author(s)     : Sylvain.Pion\@sophia.inria.fr/g;
    # s/\/\/ revision[\s]*:.*/\/\/ revision      :/g;
    s/\/\/ revision_date[\s]*:.*/\/\/ revision_date :/g;


    if (/ifndef[\s]*CGAL_(.*_H)/)
    {
      $in_header=0;
      $old_protect_name = $1;
    }
  }

  if (! $in_header)
  { s/$old_protect_name/ARITHMETIC_FILTER_$old_protect_name/g; }

  print $_;

  if (/define[\s]*CGAL_ARITHMETIC_FILTER_$old_protect_name/)
  {
    print "
// This file is automatically generated with the script for filtering
// predicates, using Interval arithmetic.

#include <CGAL/Interval_arithmetic.h>\n";
  }
}
