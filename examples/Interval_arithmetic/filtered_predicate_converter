#!/usr/local/bin/perl5
#
# Copyright (c) 1998-1999 The CGAL Consortium
#
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
#
# This script takes as STDIN "predicates_on_ftC2.h" or equivalent.
# It produces as STDOUT "Arithmetic_filter/predicates_on_ftC2.h" or equivalent.
#
# It is not supposed to be universal, and it can be considered a quick and
# dirty hack.  But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too (but the job can be done by hand if you
# don't have many to do).
#
# See the CGAL documentation:
# Support Library, Number Types, Filtered_exact.
#

$in_header=1;
$in_def=0;
$in_decl=0;
$after_template=0;
$result_type="";
@args=();

while (<>)
{
  if (/^}$/) {
    $in_def=0;
    next;
  }
  next if ($in_def);
  if (/^{/) {
    $after_template=0;
    $in_decl=0;
    $in_def=1;
    if (($result_type ne "Sign") &&
        ($result_type ne "bool") &&
        ($result_type ne "Comparison_result") &&
        ($result_type ne "Orientation") &&
        ($result_type ne "Oriented_side") &&
        ($result_type ne "Bounded_side"))
      {print STDERR "Warning: $result_type is unknown\n"; }
    print
"{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    $result_type result = $function_name(
";
    foreach (@args) {
      print "\t\t$_.interval()";
      if ($_ ne $last_arg) { print ",\n"; }
      else { print ");"; }
    }
    print "
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return $function_name(
";
    foreach (@args) {
      print "\t\t$_.exact()";
      if ($_ ne $last_arg) { print ",\n"; }
      else { print ");"; }
    }
    print "
  }
}
";
  # MipsPro complains about the following assertion at the end, so it's
  # removed: CGAL_assertion(false);
    # print "args: @args\n" ;
    @args=();
    next;
  }

  if ($after_template)
  {
    s/(CGAL_KERNEL_.*INLINE)/\/\/ $1/; # Comment the INLINE line.
    s/inline/\/\/ inline/;             # Comment the INLINE line.
    if ( /\(/ ) { $in_decl=1; }
    if (! $in_decl) {
      if (! (/INLINE/ || /inline/)) {
        $result_type = $_;
        chop($result_type);
        # print "RESULT_TYPE = $result_type\n";
      }
    }
    if ($in_decl)
    {
      @a = split /[,\)]/; # Stores the arguments names in @args.
      foreach (@a) {
	s/^.*\(//;
        next if /^$/;
        /(\w+)\s*$/;
        push(@args, $1);
        $last_arg=$1;
      }
      s/const/\n    const/g;  # Split lines.
      s/[RF]T/Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>/g;
    }
    if (/\(/) {
      /([a-zA-Z_]\w*)\s*\(/;
      $function_name=$1;
      # print "Function name: $function_name\n";
    }
  }
  if (/template/) { $after_template = 1; }
  s/template\s*<\s*class\s*[RF]T\s*>/#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION\ntemplate < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >\n#endif/;

  if ($in_header)
  {
    s/\/\/ release[\s]*:.*/\/\/ release       :/g;
    s/\/\/ release_date[\s]*:.*/\/\/ release_date  :/g;
    if (/\/\/ file[\s]*: (.*)/)
      { $new_source_name= $1; s/CGAL/CGAL\/Arithmetic_filter/g; }
    s/\/\/ package[\s]*:.*/\/\/ package       : Interval_arithmetic/g;
    s/\/\/ source[\s]*:.*/\/\/ source        : $new_source_name/g;
    s/\/\/ author\(s\)[\s]*:.*/\/\/ author(s)     : Sylvain.Pion\@sophia.inria.fr/g;
    # s/\/\/ revision[\s]*:.*/\/\/ revision      :/g;
    s/\/\/ revision_date[\s]*:.*/\/\/ revision_date :/g;


    if (/ifndef[\s]*CGAL_(.*_H)/)
    {
      $in_header=0;
      $old_protect_name = $1;
    }
  }

  if (! $in_header)
  { s/$old_protect_name/ARITHMETIC_FILTER_$old_protect_name/g; }

  print $_;

  if (/define[\s]*CGAL_ARITHMETIC_FILTER_$old_protect_name/)
  {
    print "
// This file is automatically generated by the script for filtering
// predicates, using Interval arithmetic.\n";
  }
}
