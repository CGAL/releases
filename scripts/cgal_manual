#! /bin/bash

# ============================================================================
# Copyright (c) 2004  Max-Planck-Institute Saarbruecken (Germany), 
# All rights reserved.
#
# This file is part of CGAL (www.cgal.org); you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; version 2.1 of the License.
# See the file LICENSE.LGPL distributed with CGAL.
#
# Licensees holding a valid commercial license may use this file in
# accordance with the commercial license agreement provided with the software.
#
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# $Source: /CVSROOT/CGAL/Packages/Manual/scripts/cgal_manual,v $
# $Revision: 1.22 $ $Date: 2004/11/24 11:58:30 $
# $Name:  $
#
# Author(s)     : Lutz Kettner
#
# ============================================================================
# 
# Specification: cgal_manual
# --------------------------
# 
# It is called in a ./doc_tex/ directory of a CGAL Package or internal release.
# 
# This script is the driver program for creating CGAL manuals. It makes
# use of LaTeX, PDFLaTeX, BiBTeX, makeindex, latex_to_html, and other
# tools to create the PostScript, PDF, and HTML manuals for individual 
# CVS Packages as well as custom Modules. It encodes the conventions of
# how CGAL manuals are organized and how the general purpose tools need
# to be called to create the manuals. We specify these conventions here
# briefly. See the developers manual for more details.
# Both documentations need to be kept synchronized!
#
# - CVS Package: 
# 
#     Development unit in CGAL hosted on our CVS server. A package has a 
#     fixed directory directory structure. Let's assume the package is 
#     called 'Geom', then the documentation must reside in a directory
#     ./doc_tex/ withing the package Geom. Here, individual subdirectories, 
#     typically ./Geom/ and ./Geom_ref/, contain the user and the reference 
#     manual respectively. The individual subdirectories contain a main.tex 
#     that contains the manual chapter, possibly several and possibly using 
#     several other input files, but all included with relative paths
#     from the ./doc_tex/ directory, where the tools and this script will
#     run.
#        In general, all individual subdirectories that contain a main.tex
#     are processed. ./doc_tex/*/main.tex and ./doc_tex/*_ref/main.tex are
#     assumed to form corresponding user and reference manual entries in the 
#     table of contents.
#        The main.tex files are not stand-alone LaTeX files. They are
#     chapters, i.e., do not contain \begin{document} etc. This script 
#     provides the necessary LaTeX wrapper file.
#
# - Modules:
# 
#     Presentation unit of modularity towards the user, assembled from
#     CVS packages. For a module of name 'Algo' it is assumed that in the
#     ./doc_tex/ directory exists the necessary LaTeX driver file Algo.tex .
#     This driver is a complete LaTeX file incl. \begin{document} and 
#     such. It can in itself then include the various chapters from 
#     packages.
# 
# This script can create individual package documentation given the name of
# the individual subdirectories in ./doc_tex/. It creates module 
# documentations given the name of the module LaTeX driver file.
# 
# The default is to create package manuals for all ./*/main.tex files,
# where ./*/main.tex and corresponding ./*_ref/main.tex are kept in 
# one manual., and for all *_[Mm]anual.tex files for modules.
# 
# This script can be used in three different environments of CGAL sources.
# It decides automatically in which situation it is and adapts the necessary
# search paths for style files and bibliographies.
# 
# - 1. CGAL Internal Release
# 
#     The style and bibliography files are in ./Manual/. Nothing needs to 
#     be done, since style files and bibliography files are prefixed 
#     with the relative ./Manual/ path.
# 
# - 2. Individual CGAL Packages + CGAL Package 'Manual'
# 
#     The style and bibliography files are in ../../Manual/doc_tex/Manual/.
#     The search paths get the ../../Manual/doc_tex/ path prepended.
# 
# - 3. All other environments
# 
#     The style and bibliography files need to be installed properly
#     from the CVS package Manual, such that the tools can find them, for
#     example through the search paths defined in the environment variables 
#     TEXINPUTS, BIBINPUTS, and LATEX_CONV_INPUTS. Recall that the style
#     and bibliography files are prefixed with './Manual/', so the
#     Manual subdirectory needs to be found in the search paths.
#
# This script properly adds entries in TEXINPUTS, BIBINPUTS, and 
# LATEX_CONV_INPUTS so that bib and style files are found. It also 
# adds ../examples:../demo to access the example source codes.
#
#
# When the -testsuite option is used the script will copy all the manuals
# and logfiles to $TestSuiteResultPath/CGAL-$CgalVersion/ and creates an
# HTML summary page index.html in that subdirectory. The latest result
# is also always accessible at $TestSuiteResultPath/LAST/index.html .
#    Futhermore, the script will cleanup old results. For the most recent
# number $TestSuiteFullHistory of test suites the full results including
# the manuals are kept. Older test suites will have their manuals deleted
# to save space. In total only $TestSuiteHistory many test suites are kept.
#    The history of test suites is managed in a shift-register like fashion
# using files in $TestSuiteResultPath of defined names History.<i> that 
# contain the name of the i-th test suite subdirectory. The 1st is the 
# most recent test suite and corresponds to the 'last' directory.
#    If the test suite is repeated for the same internal release number,
# the new results will overwrite the old results.
# ============================================================================

shopt -s nullglob

# =====================================================================
# Begin of Configuration Section: ...
# =====================================================================

Latex="latex"
# idea, not finished: if $Latex --help | grep file-line-error-style
PdfLatex="pdflatex"
Bibtex="bibtex -terse"
MakeIndex="makeindex -q"
DvipsA4="dvips -q -D 600 -t a4 -P pdf -G0"
Gzip="gzip"
GnuTar="tar"
LatexToHtml="latex_to_html"
Sendmail=mail

ResourceFile="$HOME/.cgalmanualrc"

#---------------------------------------------------------------------#
# Global variables, default initialization
#---------------------------------------------------------------------#

# Selects the different output formats supported
MakePS=1
MakePDF=1
MakeHTML=1

# Selects that only the LaTeX wrapper files for packages are created
MakeWrapperOnly=0

# Selects if the results are collected and formatted for the test-suite
# result pages on the web and copies them there
MakeTestSuiteResult=0

# Number of lines in the result table before an intermediate table header
# is written for better overview.
TestSuiteTableHeightMax=12

# Counter counting the lines written the the testsuite result tables
TestSuiteTableHeight=0

# The corresponding address in the file space for copying the 
# test-suite result pages. Needs to be in the file system, because
# not only are pages copied, but the script manages also a clever 
# history of up to $TestSuiteHistory many test-suite results and
# deletes older ones.
TestSuiteResultPath="/www/pub/www.cgal.org/Members/Manual_test"

# Number of older test-suite results kept. Test-suite results beyond this 
# number are deleted.
TestSuiteHistory=8

# Number of older test-suites for which the full results will be kept. Older
# test suites will have their manuals removed to save space.
TestSuiteFullHistory=3

# Email address to send the end-of-testsuite announcement to. If this 
# variable is empty, no email will be send.
TestSuiteResultEmail="cgal-develop-l@postino.mpi-sb.mpg.de"

# The url prefix of the result web page
TestSuiteResultUrl="http://www.cgal.org/Members/Manual_test"

# =====================================================================
# ... End of Configuration Section.
# =====================================================================

# Determines if we currently make a Module or Package manual.
# Only one is set to 1.
MakeModule=0
MakePackage=0

# Name of this script, without leading path
ProgName=${0##*/}

# We keep some statistics for the protocol
TotalStartTime=$SECONDS
Date="`date '+%d %b %Y'`"
Time="`date '+%T %Z'`"

# Try to determine the CGAL version (works only for internal/external releases)
# Otherwise use date.
if [ -r version.tex ]; then
    CgalVersion="`cat version.tex | grep '\\cgalversion[{]' | sed 's/[}]$//' | sed 's/.*[{]//'`"
else
    CgalVersion=`echo ${Date} | sed 's/ /_/g'`
fi

# Selects no console output except error messages
Quiet=0

# Selects no console output at all, not even error messages
RealQuiet=0

# Selects detailed console output, includes the logfile output
Verbose=0

# By default, the log file will be deleted at the end if there were no errors.
# With $KeepLog one can keep the log in any case. With $NoLog it will
# be deleted in any case.
KeepLog=0
NoLog=0

# Selects to keep the summary lines of the console output also in a sumary file
Sum=0

# Read the resource file
ReturnStatus=0
if [ -r $ResourceFile ] ; then
  source $ResourceFile
fi
if [ $ReturnStatus -ne 0 ] ; then
  exit $ReturnStatus
fi

# Color changing control sequences. Makes protocols more readable.
# There is a translation to HTML format in the corresponding code below.
BlueColor=""
BoldColor=""
OkColor=""
ErrorColor=""
WarnColor=""
ResetColor=""
if [ -t 2 ] ; then # is stderr connected to a terminal
  case "$TERM" in
    xterm* | vt100* | console* ) # terminals believed to have color capability
      BlueColor='[1m[34m'    # blue boldface
      BoldColor='[1m'          # boldface
      OkColor='[32m'           # green
      ErrorColor='[1m[31m'   # red boldface
      WarnColor='[35m'         # magenta
      ResetColor='[30m[00m'  # black, reset attribute
      ;;
  esac
fi


#---------------------------------------------------------------------#
# version
#---------------------------------------------------------------------#

version_no() {
    echo '$Revision: 1.22 $' | sed 's/[$]Revision: //' | sed 's/ [$]//g'
}

version_date() {
    echo '$Date: 2004/11/24 11:58:30 $' | sed 's/[$]Date: //' | \
        sed 's/ [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [$]//'
}

version() {
    echo "${BoldColor}${ProgName}:${ResetColor} ${BlueColor}Revision `version_no` [`version_date`]"\
        "   (c) Lutz Kettner${ResetColor}"  1>&2
}

#---------------------------------------------------------------------#
# usage
#---------------------------------------------------------------------#

usage() {
    version
    cat  1>&2 <<EOF
${BoldColor}Usage: ${ProgName} [<options>] [<module-files...>] [<package-dirs...>]${ResetColor}
    Creates CGAL manuals from CGAL packages or modules. It should be called in
    the ./doc_tex/ directory of a CGAL internal release or CVS checkout.
       ${BoldColor}CGAL packages${ResetColor} are given as a subdirectory that contains a main.tex file;
    a wrapper file that includes main.tex is automatically generated and 
    deleted at the end. Use -wrapper to create a wrapper file permanently.
       ${BoldColor}CGAL modules${ResetColor} are given as an explict LaTeX file, e.g., generated with 
    -wrapper.
       The results are the specified manuals in the corresponding ../doc_ps,
    ../doc_pdf, and ../doc_html directories. A logfile .cgallog is created
    with a logfile summary from the individual logfiles .log, .blg, .ilg, .plg,
    and .hlg. The logfiles are kept in case of warnings and error messages.
       The screen output reports the progress and result status of each
    module (abbrev. as Mod) and package (abbrev. as Pck) and each manual type.
${BoldColor}Options:${ResetColor}
    ${BoldColor}-ps${ResetColor}                 PostScript manuals.
    ${BoldColor}-pdf${ResetColor}                PDF manuals.
    ${BoldColor}-html${ResetColor}               HTML manuals (incl. a LaTeX run).
    ${BoldColor}-wrapper${ResetColor}            creates the LaTeX wrapper files only.
    ${BoldColor}-testsuite${ResetColor}          runs testsuite, installs results and sends email. Use
                        only after reading the config section of this script.
    ${BoldColor}-h${ResetColor}                  help (this text).
    ${BoldColor}-V${ResetColor}                  version.
    ${BoldColor}-v${ResetColor}                  verbose: repeats logfiles on stderr.
    ${BoldColor}-k${ResetColor}                  keep logfiles (default: delete after a clean run).
    ${BoldColor}-n${ResetColor}                  no logfile: delete logfiles always.
    ${BoldColor}-s${ResetColor}                  create a summary logfile .sum .
    ${BoldColor}-quiet${ResetColor}              no progress messages.
    ${BoldColor}-realquiet${ResetColor}          suppresses also error messages.
EOF
}


#---------------------------------------------------------------------#
# summary <strings> ....
#     - writes '<strings> ...' in a single line to stdout and the $LogFile
#     - if <string> is '-n' then the line break is suppressed.
#     - if $Quiet is set the output to stdout gets suppressed
#     - We keep an (accumulated) copy of all output done with -n.
#       We use that in the error() function if the -q (quiet) switch 
#       was used to actually print what was not printed so far.
#---------------------------------------------------------------------#

NBuffer=""

update_nbuffer() {
  if [ "$1" == "-n" ] ; then
    shift
    NBuffer="$NBuffer""$*"
  else
    NBuffer=""
  fi
}

pad_nbuffer() {
  # output '. . . . ' pattern up to column $1 taking NBuffer into account
  # make length even first
  declare -i len=$1-${#NBuffer}
  declare -i even="$len%2"
  if [ $even -ne 0 ] ; then
    echo -n " "
    len=$len-1
  fi
  while [ $len -gt 0 ] ;
  do
    echo -n ". "
    len=$len-2
  done
}

summary() {
  update_nbuffer "$@"
  if [ $Verbose -eq 0 ] ; then
    if [ $Quiet -eq 0 ] ; then
      echo "$@"
    fi
  fi
  echo "$@" | sed 's/[[][^m]*m//g;' >> $LogFile
}

#---------------------------------------------------------------------#
# error <strings> ....
#     - writes '<strings> ...' in a single line to stdout and the $LogFile
#     - if <string> is '-n' then the line break is suppressed
#     - if $RealQuiet is set the output to stdout gets suppressed
#     - works together with summary to not loose stuff from NBuffer 
#       where output used the -n flag.
#---------------------------------------------------------------------#

error() {
  if [ $RealQuiet -eq 0 ] ; then
    if [ $Verbose -eq 0 ] ; then
      if [ $Quiet -eq 1 ] ; then
        echo -n "$NBuffer"
      fi
      echo "$@"
    fi
  fi
  echo "$@" | sed 's/[[][^m]*m//g;' >> $LogFile
  NBuffer=""
}

#---------------------------------------------------------------------#
# log <strings> ....
#     - writes '<strings> ...' in a single line to the $TmpLogFile
#     - if <string> is '-n' then the line break is suppressed
#     - if $Verbose is set it echos the output also to stdout
#---------------------------------------------------------------------#

log() {
  if [ $Verbose -eq 1 ] ; then
    echo "$@"
  fi
  echo "$@" >> $TmpLogFile
}

#---------------------------------------------------------------------#
# log_divider <string>
#     - writes '--------------- <strings> ---' to log file
#     - formatted to 78 columns
#---------------------------------------------------------------------#

log_divider() {
  Pad=""
  Aux="$*"
  declare -i len=51-${#Aux}
  while [ $len -gt 0 ] ;
  do
    Pad="-$Pad"
    len=$len-1
  done
  log "------------------------- $* $Pad"
}

#---------------------------------------------------------------------#
# print_time <start-time> <end-time>
#     - <start-time> and <end-time> are in seconds
#     - format printed is hh:mm:ss
#---------------------------------------------------------------------#

print_time() {
  declare -i DiffTime=$2-$1
  declare -i Hours="$DiffTime/3600"
  declare -i Minutes="($DiffTime/60)%60"
  declare -i Seconds="$DiffTime%60"
  printf "%02d:%02d:%02d" $Hours $Minutes $Seconds
}

#---------------------------------------------------------------------#
# is_in_list <name> <list...>
#     - Returns 0 if <name> is contained in <list...> and 1 otherwise
#---------------------------------------------------------------------#

is_in_list() {
    N=$1
    shift
    for f in $@ ; do
        if [[ $N == $f ]]; then return 0; fi
    done
    return 1
}

#---------------------------------------------------------------------#
# find_in_search_path <name> <search-path>
#     - searches for <name> in all directories listed in the
#       colon separated <search-path> starting at ${CurrentDir}
#     - Echos the first path that contains <name>, otherwise nothing.
#---------------------------------------------------------------------#

find_in_search_path() {
    search_paths="`echo $2 | sed 's/:/ /g'`"
    for p in ${search_paths} ; do
        if [[ "$p" != "" && -r ${CurrentDir}/$p/$1 ]]; then
            echo -n $p
            return
        fi
    done
}

#---------------------------------------------------------------------#
# create_wrapper <rootname> [<package-ref-name>]
#     - Writes LaTeX wrapper file <rootname>.tex for CGAL package
#     - CGAL package has name <rootname>, an optional second argument
#       gives the name of a reference manual part put side-by-side
#       in the table of contents.
#---------------------------------------------------------------------#

create_wrapper() {
    cat <<EOF
% +------------------------------------------------------------------------+
% | $1.tex
% | LaTeX Wrapper File for CGAL User and Reference Manual
% | Automatically generated by 'cgal_manual' for CGAL Packages
% +------------------------------------------------------------------------+

\documentclass{book}
\usepackage{Manual/cgal_manual}

\makeindex
EOF
    if [ $# -ne 1 ]; then
        echo ""
        echo "% Make the table of contents use two columns"
        echo "\lcHtml{\lcTwoColumnToc}"
    fi
    cat <<EOF

\begin{document}

EOF
    echo "\\cgaltitlepage{$1 Package}" | sed 's/_/\\_/g'
    cat <<EOF

\cleardoublepage
\pagenumbering{roman}
\setcounter{page}{1}
\ifthenelse{\boolean{useminitoc}}{\lcTex{\dominitoc}}{}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{page}{1}

\cgalchapters{
EOF
    if [ $# -eq 1 ]; then
        if [[ $1 == *_ref ]]; then
            echo "    %\entryleft{\part{Reference Manual}}"
            echo "    \lcTex{\entryleft{\listofrefpages}}"
        else
            echo "    %\entryleft{\part{User Manual}}"
        fi
        echo "    \packageleft{$1}"
    else
        echo "    %\entryleftright{\part{User Manual}}{\part{Reference Manual}}"
        echo "    \lcTex{\entryright{\listofrefpages}}"
        echo "    \packageleftright{$1}{$2}"
    fi
    cat <<EOF
}
\bibliographystyle{alpha}
\bibliography{Manual/cgal_manual,Manual/geom}

\printindex

\end{document}
EOF
}

#---------------------------------------------------------------------#
# report_latex <wrapper-rootname>
#     - Reports summary of error messages and warnings from LaTeX, BibTeX,
#       and makeindex log files.
#---------------------------------------------------------------------#

report_latex() {
    echo ""
    echo "Summary LaTeX"
    echo "-------------"
    echo "For the full logfile see $1.log"
    if [ $MakePackage -eq 1 ]; then
        echo "Since this is a CGAL Package manual, one can probably ignore "
        echo "warnings about undefined references or missing header files."
    fi
    egrep -i '((error)|(^[!]))' $1.log | grep -v "operatorerror"
    grep -i warn $1.log 
    if [ $MakeTestSuiteResult -eq 1 ]; then mv $1.log testsuite/$1.log.txt ; fi
    if [ -r $1.blg ]; then 
        echo ""
        echo "Summary BibTeX"
        echo "--------------"
        echo "For the full logfile see $1.blg"
        grep -i error $1.blg
        grep 'I found no \\citation commands' $1.blg
        grep -i warn $1.blg | grep -v 'warning[$]'
        if [ $MakeTestSuiteResult -eq 1 ]; then 
            mv $1.blg testsuite/$1.blg.txt
        fi
    fi
    if [ -r $1.ilg ]; then 
        echo ""
        echo "Summary makeindex"
        echo "-----------------"
        echo "For the full logfile see $1.ilg"
        egrep -i '((error)|(reject))' $1.ilg 
        grep -i warn $1.ilg
        if [ $MakeTestSuiteResult -eq 1 ]; then
            mv $1.ilg testsuite/$1.ilg.txt
        fi
    fi
    echo ""
    return
}

#---------------------------------------------------------------------#
# cleanup_latex <wrapper-rootname>
#     - Removes all temporaries, called after LaTeX and PDFLaTeX
#---------------------------------------------------------------------#

cleanup_latex() {
    rm -f $1.toc $1.mtc* $1.idx $1.ind $1.dvi $1.inc $1.out $1.ref
    if [ $MakeHTML -eq 0 ] ; then 
        rm -f $1.aux $1.bbl
    fi
    # in case the log was not asked for, delete it
    if [[ $NoLog -eq 1 || ( $KeepLog -eq 0 && 
                   ( $RetCode -eq 0 ||  $RetCode -eq 5 )) ]] ; then
      rm -f $1.log $1.blg $1.ilg
    fi
    return
}

#---------------------------------------------------------------------#
# check_latex_warn <wrapper-rootname>
#     - Checks if latex logfile contains valid warnings
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_latex_warn() {
    if [ $MakePackage -eq 0 ]; then
        if egrep -v "((Rerun to get cross-references right)|(warning[$]))" \
            $1.log | grep -i warn > /dev/null ; then
            return 0
        fi
    else # for CGAL Packages, also ignore warnings of undef. references
        if egrep -v "((Rerun to get cross-references right)|(warning[$])|(LaTeX Warning: Reference)|(undefined references))" $1.log | grep -i warn > /dev/null ; then
            return 0
        fi
    fi
    return 1
}

#---------------------------------------------------------------------#
# check_bibtex_warn <wrapper-rootname>
#     - Checks if bibtex logfile contains valid warnings
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_bibtex_warn() {
    if grep -v "warning[$]" $1.blg | grep -i warn > /dev/null ; then
        return 0
    fi
    return 1
}

#---------------------------------------------------------------------#
# check_bibtex_empty <wrapper-rootname>
#     - Checks if bibtex logfile contains the empty bibliography
#       error message and no other error message.
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_bibtex_empty() {
    if grep 'I found no \\citation commands' $1.blg > /dev/null ; then
        if grep 'There was 1 error message' $1.blg > /dev/null ; then
            return 0
        fi
    fi
    return 1
}

#---------------------------------------------------------------------#
# check_index_warn <wrapper-rootname>
#     - Checks if makeindex logfile contains valid warnings
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_index_warn() {
    if grep -v "lines written, 0 warnings" $1.ilg \
        | grep -i warn > /dev/null ; then
        return 0
    fi
    return 1
}

#---------------------------------------------------------------------#
# testsuite_entry <exit-code> <log-filename>
#     - writes a single <td> cell in HTML report table to stdout
#     - reports exit-code results: 0 = ok, 1 = error, 2 = warning, 3 = n.a.
#---------------------------------------------------------------------#

SP="&nbsp;&nbsp;&nbsp;&nbsp;"

testsuite_entry() {
  if [ $1 -eq 0 ]; then
    echo "  <td align=\"center\" class=\"ok\"><a href=\"$2\">${SP}y${SP}</a></td>"
  elif [ $1 -eq 1 ]; then
    echo "  <td align=\"center\" class=\"error\"><a href=\"$2\">${SP}n${SP}</a></td>"
  elif [ $1 -eq 2 ]; then
    echo "  <td align=\"center\" class=\"warning\"><a href=\"$2\">${SP}w${SP}</a></td>"
  elif [ $1 -eq 5 ]; then
    echo "  <td align=\"center\" class=\"ok\"><a href=\"$2\">${SP}h${SP}</a></td>"
  else
    echo "  <td align=\"center\" class=\"void\">-</td>"
  fi
}


#---------------------------------------------------------------------#
# run_latex <wrapper-rootname>
#     - Runs LaTeX, either brief for HTML, or full for stable PS
#     - Includes BiBTeX and makeindex if needed.
#     - Returns in $RetCode: 1 = error, 2 = warning, 5 = expected warning
#     - Prints logfile summary result in stdout
#---------------------------------------------------------------------#

run_latex() {
    # codes memorized for the different passes:
    # 0 = ok, 1 = error, 2 = warning, 3 = n.a.
    LatexExit=0
    BibtexExit=4
    IndexExit=4
    RetCode=0 # total return code
    # first run
    $Latex --interaction batchmode $1
    if [ $? -ne 0 ]; then LatexExit=1 ; fi
    # see if we need BiBTeX and run it
    if grep '[\\]bibdata'  $1.aux > /dev/null ; then
        if $Bibtex $1 ; then BibtexExit=0 ; else BibtexExit=1 ; fi
        # Check for documents that have a bibliography entry, 
        # but no citations. Don't create an empty bibliograpy then.
        if check_bibtex_empty $1 ; then
            rm -f $1.bbl
            BibtexExit=0
        else
            # Run LaTeX to get citations into the auxfile.
            $Latex --interaction batchmode $1
            if [ $? -ne 0 ]; then LatexExit=1 ; fi
        fi
    fi
    # see if we need full LaTeX results, or if suffices what we have so far
    if [ ${MakePS} -eq 1 ] ; then
        # Make sure that there is at least one rerun if makeindex is requested
        if [ -r $1.idx ]; then
            if ${MakeIndex} $1.idx; then IndexExit=0 ; else IndexExit=1 ; fi
            $Latex --interaction batchmode $1
            if [ $? -ne 0 ]; then LatexExit=1 ; fi
        fi
        # Run LaTeX until their is no rerun necessary anymore
        while grep "Rerun to get cross-references right" $1.log > /dev/null; do
            # Run makeindex as well if requested
            if [ -r $1.idx ]; then
              if ${MakeIndex} $1.idx; then IndexExit=0 ; else IndexExit=1 ; fi
            fi
            $Latex --interaction batchmode $1
            if [ $? -ne 0 ]; then LatexExit=1 ; fi
        done
        if [ -r $1.dvi ]; then
            if ! ${DvipsA4} $1 -o $1.ps ; then RetCode=1; fi
        fi
        if [ -r $1.ps ]; then
            if ! ${Gzip} $1.ps ; then RetCode=1; fi
        fi
        if [ $MakeTestSuiteResult -eq 1 ]; then 
            mv $1.ps.gz testsuite
        else
            if [ ! -d ../doc_ps ]; then mkdir ../doc_ps; fi
            if [ ! -d ../doc_ps ]; then
                echo "ERROR: Something is wrong, I cannot create directory '../doc_ps' ."
                RetCode=1
            else
                mv $1.ps.gz ../doc_ps
            fi
        fi
    fi
    # check for include files that don't exist
    if [ -r $1.inc ]; then 
        for f in `cat $1.inc | sort | uniq` ; do
          if [ ! -r ../include/$f ]; then
            echo "WARNING: Include file '$f' does not exist!" >> $1.log
            if [ ! $LatexExit  -eq 1 ]; then LatexExit=2; fi
          fi
        done
    fi
    if [ $LatexExit  -eq 0 ]; then
        if check_latex_warn  $1 ; then LatexExit=2;  fi
    fi
    if [ $IndexExit  -eq 0 ]; then
        if check_index_warn  $1 ; then IndexExit=2;  fi
    fi
    if [ $BibtexExit -eq 0 ]; then
        if check_bibtex_warn $1 ; then BibtexExit=2; fi
    fi
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        testsuite_entry $LatexExit  $1.log.txt >  testsuite/index_row
        testsuite_entry $BibtexExit $1.blg.txt >> testsuite/index_row
        testsuite_entry $IndexExit  $1.ilg.txt >> testsuite/index_row
        if [ ${MakePDF} -eq 0 ] ; then
            # one empty entry for PdfLaTeX run
            testsuite_entry 4  $1.pdflg.txt >> testsuite/index_row
        fi
    fi
    if [ $RetCode -eq 0 ] ; then
      if [[ $LatexExit -eq 1 || $BibtexExit -eq 1 || $IndexExit -eq 1 ]]; then
          RetCode=1
      fi
    fi
    if [ $RetCode -eq 0 ] ; then
      if [[ $LatexExit -eq 2 || $BibtexExit -eq 2 || $IndexExit -eq 2 ]]; then
          RetCode=2
      fi
    fi
    # Special handling if LaTeX is only needed as preparation for the 
    # HTML manual, since we see 'undefined...' messages that we can ignore.
    if [[ ${MakePS} -eq 0 && $LatexExit -eq 2 ]]; then
        LatexExit=5
        if [ $RetCode -eq 2 ] ; then
            RetCode=5
        fi 
    fi
    report_latex $1
    if [ ${MakePDF} -eq 0 ] ; then 
        cleanup_latex $1
    else
        rm -f $1.aux
    fi
    return $RetCode
}

#---------------------------------------------------------------------#
# report_pdflatex <wrapper-rootname>
#     - Reports summary of error messages and warnings from LaTeX
#       and makeindex log files.
#---------------------------------------------------------------------#

report_pdflatex() {
    echo ""
    echo "Summary PdfLaTeX"
    echo "----------------"
    echo "For the full logfile see $1.pdflg"
    if [ $MakePackage -eq 1 ]; then
        echo "Since this is a CGAL Package manual, one can probably ignore "
        echo "warnings about undefined references."
    fi
    egrep -i '((error)|(^[!]))' $1.log | grep -v "operatorerror"
    grep -i warn $1.log 
    if [ $MakeTestSuiteResult -eq 1 ]; then mv $1.log testsuite/$1.pdflg.txt ; fi
    if [[ ${MakePS} -eq 0 && -r $1.blg ]]; then 
        echo ""
        echo "Summary BibTeX"
        echo "--------------"
        echo "For the full logfile see $1.blg"
        grep -i error $1.blg
        grep 'I found no \\citation commands' $1.blg
        grep -i warn $1.blg | grep -v 'warning[$]'
        if [ $MakeTestSuiteResult -eq 1 ]; then 
            mv $1.blg testsuite/$1.blg.txt
        fi
    fi
    if [ -r $1.ilg ]; then 
        echo ""
        echo "Summary makeindex"
        echo "-----------------"
        if [ ${MakePS} -eq 0 ]; then 
            echo "For the full logfile see $1.ilg"
            egrep -i '((error)|(reject))' $1.ilg 
            grep -i warn $1.ilg
            if [ $MakeTestSuiteResult -eq 1 ]; then
                mv $1.ilg testsuite/$1.ilg.txt
            fi
        else
            echo "For the full logfile see $1.ilg from the regular LaTeX run"
            egrep -i '((error)|(reject))' $1.ilg 
            grep -i warn $1.ilg
        fi
    fi
    echo ""
    return
}

#---------------------------------------------------------------------#
# run_pdflatex <wrapper-rootname>
#     - Runs PdfLaTeX for stable PDF
#     - Includes makeindex if needed.
#     - BiBTeX was already done (if necessary) in run_latex
#     - Returns in $RetCode: 1 = error, 2 = warning
#     - Prints logfile summary result in stdout
#     - The LaTeX logfile *.log from the previous run_latex run
#       has been saved temporarily by the calling function
#---------------------------------------------------------------------#

run_pdflatex() {
    # codes memorized for the different passes:
    # 0 = ok, 1 = error, 2 = warning, 3 = n.a.
    LatexExit=0
    BibtexExit=4
    IndexExit=4
    RetCode=0 # total return code
    # first run
    $PdfLatex --interaction batchmode $1
    if [ $? -ne 0 ]; then LatexExit=1 ; fi
    # see if we need BiBTeX and run it
    if [ ${MakePS} -eq 0 ] ; then
        if grep '[\\]bibdata'  $1.aux > /dev/null ; then
            if $Bibtex $1 ; then BibtexExit=0 ; else BibtexExit=1 ; fi
            # Check for documents that have a bibliography entry, 
            # but no citations. Don't create an empty bibliography then.
            if check_bibtex_empty $1 ; then
                rm -f $1.bbl
                BibtexExit=0
            else
                # Run LaTeX to get citations into the auxfile.
                $PdfLatex --interaction batchmode $1
                if [ $? -ne 0 ]; then LatexExit=1 ; fi
            fi
        fi
    fi
    # Make sure that there is at least one rerun if makeindex is requested
    if [ -r $1.idx ]; then
        if ${MakeIndex} $1.idx; then IndexExit=0 ; else IndexExit=1 ; fi
        $PdfLatex --interaction batchmode $1
        if [ $? -ne 0 ]; then LatexExit=1 ; fi
    fi
    # Run LaTeX until their is no rerun necessary anymore
    while grep "Rerun to get cross-references right" $1.log > /dev/null; do
        # Run makeindex as well if requested
        if [ -r $1.idx ]; then
          if ${MakeIndex} $1.idx; then IndexExit=0 ; else IndexExit=1 ; fi
        fi
        $PdfLatex --interaction batchmode $1
        if [ $? -ne 0 ]; then LatexExit=1 ; fi
    done
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        mv $1.pdf testsuite
    else
        if [ ! -d ../doc_pdf ]; then mkdir ../doc_pdf; fi
        if [ ! -d ../doc_pdf ]; then
            echo "ERROR: Something is wrong, I cannot create directory '../doc_pdf' ."
            RetCode=1
        else
            mv $1.pdf ../doc_pdf
        fi
    fi
    if [ $LatexExit  -eq 0 ]; then
        if check_latex_warn  $1 ; then LatexExit=2;  fi
    fi
    if [ $BibtexExit -eq 0 ]; then
        if check_bibtex_warn $1 ; then BibtexExit=2; fi
    fi
    if [ $IndexExit  -eq 0 ]; then
        if check_index_warn  $1 ; then IndexExit=2;  fi
    fi
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        # Report bibtex and index errors here only if regular LaTeX was not run
        if [ ${MakePS} -eq 0 ] ; then
            # one empty entry for LaTeX run
            testsuite_entry 4           $1.log.txt > testsuite/index_row
            testsuite_entry $BibtexExit $1.blg.txt >> testsuite/index_row
            testsuite_entry $IndexExit  $1.ilg.txt >> testsuite/index_row
        fi
        testsuite_entry $LatexExit  $1.pdflg.txt >> testsuite/index_row
    fi
    if [ ${MakePS} -eq 1 ] ; then
        # do error and warn reporting restricted to PdfLaTeX    
        if [ $RetCode -eq 0 ] ; then
          if [[ $LatexExit -eq 1 ]]; then
              RetCode=1
          fi
        fi
        if [ $RetCode -eq 0 ] ; then
          if [[ $LatexExit -eq 2 ]]; then
              RetCode=2
          fi
        fi
    else
        # do full error and warn reporting for PdfLaTeX, BibTeX, make_index
      if [ $RetCode -eq 0 ] ; then
       if [[ $LatexExit -eq 1 || $BibtexExit -eq 1 || $IndexExit -eq 1 ]]; then
           RetCode=1
       fi
      fi
      if [ $RetCode -eq 0 ] ; then
       if [[ $LatexExit -eq 2 || $BibtexExit -eq 2 || $IndexExit -eq 2 ]]; then
           RetCode=2
       fi
      fi
    fi
    report_pdflatex $1
    cleanup_latex $1
    return $RetCode
}

#---------------------------------------------------------------------#
# report_html <wrapper-rootname>
#     - Reports summary of error messages and warnings from HTML conversion
#---------------------------------------------------------------------#

report_html() {
    echo ""
    echo "Summary LaTeX_to_HTML"
    echo "---------------------"
    echo "For the full logfile see $1.hlg"
    grep -i error $1.hlg 
    grep -i rejected $1.hlg 
    grep -i warn $1.hlg 
    echo ""
    return
}

#---------------------------------------------------------------------#
# cleanup_html <wrapper-rootname>
#     - Removes all temporaries
#---------------------------------------------------------------------#

cleanup_html() {
    rm -f $1.ref $1.aux $1.bbl
    # in case the log was not asked for, delete it
    if [[ $NoLog -eq 1 || ( $KeepLog -eq 0 && $RetCode -eq 0 ) ]] ; then
      rm -f $1.hlg
    fi
    return
}

#---------------------------------------------------------------------#
# run_html <wrapper-rootname>
#     - Runs LaTeX_to_HTML
#     - Returns in $RetCode: 1 = error, 2 = warning
#     - Prints logfile summary result in stdout
#---------------------------------------------------------------------#

run_html() {
    RetCode=0
    ${LatexToHtml} -nocolor -V # list version number in summary    
    # first run
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        ${LatexToHtml} -quiet -o testsuite/$1 $1
        cd testsuite
        ${GnuTar} czf $1.tgz $1
        cd ..
    else
        ${LatexToHtml} -quiet -o ../doc_html/$1 $1
    fi
    if [ $? -ne 0 ]; then
        RetCode=1
        report_html $1
        cleanup_html $1
        return $RetCode
    fi
    if [ $RetCode -eq 0 ] ; then
        if grep -v 'lines written' $1.hlg | \
            grep -i warn > /dev/null ; then RetCode=2; fi
    fi
    report_html $1
    cleanup_html $1
    return $RetCode
}

#---------------------------------------------------------------------#
# try_command <description> <command ...>
#     - executes command and logs output of stdout and stderr in $TmpLogFile
#     - includes execution timing in output
#     - if $Verbose is set, it also echos the output to stdout
#     - Return codes of <command ...> are also returned and $ExitCode set
#         1 = error, 2 = warning, 5 = expected warning in HTML preparation
#---------------------------------------------------------------------#

try_command() {
  ExitCode=0
  local StartTime=$SECONDS
  local Text="$1"
  shift
  summary -n "$Text "
  log_divider "start $Text"
  rm -f $TmpLogFile.2
  if [ $Verbose -eq 1 ] ; then
    { 
      # I need to pass the exitcode through the pipe and set $ExitCode.
      # That does not work easily with a pipe and I just use a file instead.
      eval "$@" 2>&1
      echo $? > $TmpLogFile.3
      cat $TmpLogFile.3
    } | tee $TmpLogFile.2
    ExitCode=`cat $TmpLogFile.3`
    rm -f $TmpLogFile.3
  else
    eval "$@" > $TmpLogFile.2  2>&1
    ExitCode=$?
  fi
  local EndTime=$SECONDS
  cat $TmpLogFile.2 >> $TmpLogFile
  rm -f $TmpLogFile.2
  log_divider "end $Text"

  # padding up to column 54
  if [ $ExitCode -eq 1 ] ; then
    error "`pad_nbuffer 54`[${ErrorColor}ERROR${ResetColor}]  time = `print_time $StartTime $EndTime`"
  elif [ $ExitCode -eq 2 ] ; then
    error "`pad_nbuffer 54`[${WarnColor}WARNG${ResetColor}]  time = `print_time $StartTime $EndTime`"
  elif [ $ExitCode -eq 5 ] ; then
    error "`pad_nbuffer 54` [${OkColor}html${ResetColor}]  time = `print_time $StartTime $EndTime`"
  else
    summary "`pad_nbuffer 54`.  [${OkColor}ok${ResetColor}]  time = `print_time $StartTime $EndTime`"
  fi
  return $ExitCode
}


#---------------------------------------------------------------------#
# is_module <name>
#     - returns 0 if <name> is name of a CGAL Module, and 1 otherwise
#---------------------------------------------------------------------#

is_module () {
    if [ -r $1.tex ]; then return 0; fi
    if [ -d $1 ]; then return 1; fi
    return 0
}

#---------------------------------------------------------------------#
# make_manual <package or module name> [<package_ref name>]
#     - Manages the logfiles
#     - Creates all selected output formats
#     - For packages with user and reference manual, the second optional
#       argument is used to give the reference manual directory.
#---------------------------------------------------------------------#

make_manual() {
    ReturnStatus=0

    if [ $MakeWrapperOnly -eq 1 ]; then 
        if [ -r $1.tex ]; then
            echo "${ErrorColor}ERROR${ResetColor}: Wrapper file '$1.tex' exists already." 1>&2
            LastFailedWrapper=$1
            GlobalReturnStatus=1
            return 1
        fi
        # test for the case that a wrapper for Mod was created and now
        # a wrapper for Mod and Mod_ref is requested. Avoid creating
        # a wrapper Mod_ref.tex.
        if [ "$1" == "${LastFailedWrapper}_ref" ]; then
            return 1
        fi
        LastFailedWrapper=""
        create_wrapper $@ > $1.tex
        if [ ! -r $1.tex ]; then
            echo "${ErrorColor}ERROR${ResetColor}: Something went wrong creating '${1}.tex'." 1>&2
            GlobalReturnStatus=1
            return 1
        fi
        return 0; 
    fi

    #---------------------------------------------------------------------#
    # decide between Module and Package
    MakeName="Err"
    if is_module $1 ; then
        MakeName="Mod"
        MakeModule=1
        MakePackage=0
        if [ -r $1.tex ]; then 
            WrapperName=$1.tex
        else
            WrapperName=$1
        fi
    elif [[ -d $1 && -r $1/main.tex ]]; then
        MakeName="Pck"
        MakeModule=0
        MakePackage=1
        WrapperName=$1.tex
        create_wrapper $@ > ${WrapperName}
    else
        echo "" 1>&2
        echo "${ErrorColor}ERROR${ResetColor}: '$1' is neither a CGAL Package nor Module." 1>&2
        echo "" 1>&2
        GlobalReturnStatus=1
        return 1
    fi
    # Fail safe check against unexpected problems (file system full etc.)
    if [ ! -r ${WrapperName} ]; then
        echo "" 1>&2
        echo "${ErrorColor}ERROR${ResetColor}: Something went wrong creating '${WrapperName}'." 1>&2
        echo "" 1>&2
        GlobalReturnStatus=1
        return 1
    fi

    #---------------------------------------------------------------------#
    # Prepare logfiles
    WrapperRootName=${WrapperName%.*}
    LogFile=${WrapperRootName}.cgallog
    TmpLogFile=$LogFile.tmp
    TmpOutFile=$LogFile.cout

    rm -f $LogFile
    touch $LogFile

    #---------------------------------------------------------------------#
    # run LaTeX, either brief or full, 
    # skip only if no PS output but PDF output is selected
    if [[ ${MakePS} -eq 1 ||  ${MakePDF} -eq 0 ]]; then
      try_command "${MakeName} ${WrapperRootName} LaTeX" run_latex ${WrapperRootName}
      if [ $ExitCode -ne 0 ] ; then ReturnStatus=$ExitCode; fi
    fi


    #---------------------------------------------------------------------#
    # run PDFLaTeX
    PdfExit=3
    if [ ${MakePDF} -eq 1 ]; then
      if [[ -r ${WrapperRootName}.log ]] ; then 
        mv ${WrapperRootName}.log ${WrapperRootName}.texlg
      fi
      try_command "${MakeName} ${WrapperRootName} PDF  " run_pdflatex ${WrapperRootName}
      PdfExit=$ExitCode
      if [[ -r ${WrapperRootName}.log ]] ; then 
        mv ${WrapperRootName}.log ${WrapperRootName}.pdflg
      fi
      if [[ -r ${WrapperRootName}.texlg ]] ; then 
        mv ${WrapperRootName}.texlg ${WrapperRootName}.log
      fi
      if [[ $ExitCode -ne 0 && ${ReturnStatus} -ne 1 ]]; then
          ReturnStatus=$ExitCode ; 
      fi
    fi

    #---------------------------------------------------------------------#
    # run LaTeX_to_HTML
    HtmlExit=3
    if [ ${MakeHTML} -eq 1 ]; then
      try_command "${MakeName} ${WrapperRootName} HTML " run_html ${WrapperRootName}
      HtmlExit=$ExitCode
      if [[ $ExitCode -ne 0 && ${ReturnStatus} -ne 1 ]]; then
          ReturnStatus=$ExitCode ; 
      fi
      if [ $MakeTestSuiteResult -eq 1 ]; then 
          mv ${WrapperRootName}.hlg testsuite/${WrapperRootName}.hlg.txt
      fi
    fi
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        testsuite_entry $HtmlExit ${WrapperRootName}.hlg.txt >> testsuite/index_row
    fi

    #---------------------------------------------------------------------#
    # remove wrapper file if it is a CGAL package
    if [ ${MakePackage} -eq 1 ]; then rm ${WrapperName}; fi

    #---------------------------------------------------------------------#
    # echo summary in verbose mode and provide summary file
    rm -f $SumFile

    if [[ $Verbose -eq 1 && -r $LogFile ]] ; then cat $LogFile; fi

    if [[ $Sum -eq 1 && -r $LogFile ]] ; then cat $LogFile > $SumFile; fi

    #---------------------------------------------------------------------#
    # collect logfile

    echo "" >> $LogFile
    if [ -r $TmpLogFile ] ; then 
        cat $TmpLogFile >> $LogFile
    fi
    rm -f $TmpLogFile
    echo "==============================================================================" >> $LogFile

    mv $LogFile $TmpLogFile
    TotalEndTime=$SECONDS

    echo "==============================================================================" > $LogFile
    echo "$0 $CommandLineArgs" >> $LogFile
    echo "Date: $Date,   Time: $Time"  >> $LogFile
    echo "Pwd : `pwd`"  >> $LogFile
    echo "Time: `print_time $TotalStartTime $TotalEndTime` total runtime." >> $LogFile
    echo "" >> $LogFile
    cat $TmpLogFile >> $LogFile
    rm -f $TmpLogFile

    #---------------------------------------------------------------------#
    # report testsuite results
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        mv $LogFile testsuite/${LogFile}.txt
        testsuite_middle_header
        echo "<tr>" >> testsuite/index.html
        echo "  <td align=\"left\" class=\"name\">${WrapperRootName}</td>" >> testsuite/index.html
        if [ $ReturnStatus -eq 2 ]; then
            echo "  <td align=\"center\" class=\"warning\"><a href=\"${LogFile}.txt\">&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;&nbsp;&nbsp;&nbsp;</a></td>" >> testsuite/index.html
        elif [ $ReturnStatus -eq 0 ]; then
            echo "  <td align=\"center\" class=\"ok\"><a href=\"${LogFile}.txt\">&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;</a></td>" >> testsuite/index.html
        else
            echo "  <td align=\"center\" class=\"error\"><a href=\"${LogFile}.txt\">&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;</a></td>" >> testsuite/index.html
        fi
        cat testsuite/index_row >> testsuite/index.html
        rm testsuite/index_row
        echo "  <td align=\"center\" class=\"manual\"><a href=\"${WrapperRootName}.ps.gz\">PS</a></td>" >> testsuite/index.html
        echo "  <td align=\"center\" class=\"manual\"><a href=\"${WrapperRootName}.pdf\">PDF</a></td>" >> testsuite/index.html
        echo "  <td align=\"center\" class=\"manual\"><a href=\"${WrapperRootName}/contents.html\">HTML</a></td>" >> testsuite/index.html
        echo "  <td align=\"center\" class=\"manual\"><a href=\"${WrapperRootName}.tgz\">tgz</a></td>" >> testsuite/index.html
        echo "</tr>" >> testsuite/index.html
    fi

    #---------------------------------------------------------------------#    
    # in case the log was not asked for, delete it
    if [ $NoLog -eq 1 ] ; then rm -f $LogFile ; fi

    # in case there was no error and the option to keep the log is not set,
    # delete the log
    if [[ $KeepLog -eq 0 && $ReturnStatus -eq 0 ]] ; then rm -f $LogFile ; fi
    if [[ $KeepLog -eq 0 && $ReturnStatus -eq 5 ]] ; then rm -f $LogFile ; fi

    if [[ $ReturnStatus -ne 0 && ${GlobalReturnStatus} -ne 1 ]]; then
        GlobalReturnStatus=$ReturnStatus; 
    fi
    return $ReturnStatus
}

#---------------------------------------------------------------------#
# testsuite_begin
#     - Creates 'testsuite' subdir
#     - Starts index.html until first table (Modules)
#     - Creates CSS file
#---------------------------------------------------------------------#

testsuite_begin () {
    TestSuiteTableHeight=0
    if [ ! -d testsuite ]; then mkdir testsuite ; fi
    cat > testsuite/testresult.css <<EOF
BODY {background-image:url(http://www.cgal.org/images/cgal-bg2.gif);
color:black}

P {
width: 80ex
}

.contact { font-family:arial,sans-serif; font-size:10pt}

TABLE.result {background-color: white}

TD.ok {background-color: rgb(50%,100%,50%)}
TD.warning {background-color: rgb(100%,100%,50%)}
TD.error {background-color: rgb(100%,50%,50%)}

TH.ok {background-color: rgb(50%,100%,50%)}
TH.warning {background-color: rgb(100%,100%,50%)}
TH.error {background-color: rgb(100%,50%,50%)}


TD.void A {font-size:large; text-decoration: none}
TD.name A {font-size:large; text-decoration: none}

TD.manual A {font-size:large; text-decoration: none}
TD.manual A:link {color: rgb(0%,0%,100%)}
TD.manual A:visited {color: rgb(0%,80%,100%)}

TD.ok A {font-size:large; text-decoration: none}
TD.ok A:link {color: rgb(0%,0%,100%)}
TD.ok A:visited {color: rgb(0%,80%,100%)}

TD.warning A {font-size:large; text-decoration: none}
TD.warning A:link {color: rgb(0%,0%,100%)}
TD.warning A:visited {color: rgb(80%,80%,100%)}

TD.error A {font-size: large; text-decoration: none}
TD.error A:link {color: rgb(0%,0%,100%)}
TD.error A:visited {color: rgb(80%,0%,100%)}
EOF
    cat > testsuite/index.html <<EOF
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head><title>CGAL Manual Test-Suite Results</title>
<link href="testresult.css" rel="stylesheet"></head>
<body>

<h1>CGAL-${CgalVersion} Manual Test-Suite Results</h1>

<p><b>Program Test-Suite:</b> [<a href="https://www-sop.inria.fr/geometrica/CGAL/Members/testsuite/">All Releases</a>]<br>
<b>Older Manual Tests: </b>
EOF
    declare -i count=1
    declare -i lastcount=${TestSuiteHistory}
    if [ -d ${TestSuiteResultPath}/CGAL-${CgalVersion} ]; then
        count=2
        lastcount=${lastcount}+1
    fi
    while [ $count -lt ${lastcount} ] ; do
        if [ -r ${TestSuiteResultPath}/History.${count} ]; then
          subdir=`cat ${TestSuiteResultPath}/History.${count}`
          echo "    [<a href=\"../${subdir}/index.html\">${subdir#CGAL-}</a>]"\
                >> testsuite/index.html 
        fi
        count=$count+1
    done
    cat  >> testsuite/index.html <<EOF
</p>

<p>This page shows the results of creating the manuals for
CGAL-${CgalVersion}.  Each Module and each CGAL Package is tested for
problems with LaTeX, BibTeX, makeindex, PdfLaTeX, and latex_to_html
conversions. The success of the conversions and the logfiles are
accessible in the tables below. A 'y' means no blatant errors
occurred, which may be loosely interpreted as 'success', a 'w' means
there was a warning, a 'n' means 'failure', and a '-' means that this part 
was not applicable to this manual. A click on the letter
gives the corresponding logfiles. The first column contains a 
<b>summary logfile</b> for a quick overview. </p>

<p><b>The tools are currently under development, please report all
problems to Lutz Kettner and Peter Hachenberger.</b></p>

<ul>
   <li> Due to the separate testing of each package, some references in the 
        LaTeX manual may remain unresolved by the individual package 
        tests. Thus undefined references are not reported as 'w' for packages. 
        Please check the log files, for example, the summary log file, for
        undefined references in packages yourself. For Modules, undefined 
        references are reported as 'w'.</b><p>
   </li><li> <b>The detection of errors is not (yet) exact.  Please check the
        log files even when a 'y' appears and suggests that everything is 
        OK.</b><p>
   </li><li> Suggestions for improving the summary are also welcome.<p>
</li></ul>
<p></p>

<h2>Module Manual Test-Suite for CGAL-${CgalVersion}</h2>

<table cellpadding="5" cellspacing="2" border="1">
<tr align="center">
  <td rowspan="2" align="left"><b>Module</b></td>
  <td colspan="6" align="center"><b>Click to see Logfile</b></td>
  <td colspan="4" align="center"><b>Manuals</b></td>
</tr>
<tr align="center">
  <td><b>Sum-<br>mary</b></td>
  <td><b>La-<br>TeX</b></td>
  <td><b>Bib-<br>TeX</b></td>
  <td><b>make_-<br>index</b></td>
  <td><b>Pdf-<br>LaTeX</b></td>
  <td><b>latex_-<br>to_html</b></td>
  <td><b>PS</b></td>
  <td><b>PDF</b></td>
  <td><b>HTML</b></td>
  <td><b>HTML<br>tgz</b></td>
</tr>
EOF
}

#---------------------------------------------------------------------#
# testsuite_middle
#     - Continues index.html from first (Modules) to second table (Packages)
#---------------------------------------------------------------------#

testsuite_middle () {
    TestSuiteTableHeight=0
    cat >> testsuite/index.html <<EOF
</table>
<p></p>


<h2>Package Manual Test-Suite for CGAL-${CgalVersion}</h2>

<table cellpadding="5" cellspacing="2" border="1">
<tr align="center">
  <td rowspan="2" align="left"><b>Package</b></td>
  <td colspan="6" align="center"><b>Click to see Logfile</b></td>
  <td colspan="4" align="center"><b>Manuals</b></td>
</tr>
<tr align="center">
  <td><b>Sum-<br>mary</b></td>
  <td><b>La-<br>TeX</b></td>
  <td><b>Bib-<br>TeX</b></td>
  <td><b>make_-<br>index</b></td>
  <td><b>Pdf-<br>LaTeX</b></td>
  <td><b>latex_-<br>to_html</b></td>
  <td><b>PS</b></td>
  <td><b>PDF</b></td>
  <td><b>HTML</b></td>
  <td><b>HTML<br>tgz</b></td>
</tr>
EOF
}

#---------------------------------------------------------------------#
# testsuite_middle_header
#     - Writes an intermediate table header if enough packages/modules
#       have been tested
#       
#---------------------------------------------------------------------#

testsuite_middle_header () {
  if [ $TestSuiteTableHeight -ne $TestSuiteTableHeightMax ] ; then
      declare -i TestSuiteTableHeightIncr="$TestSuiteTableHeight+1"
      TestSuiteTableHeight=$TestSuiteTableHeightIncr
  else
      TestSuiteTableHeight=0
      # write intermediate table header for better overview
      cat >> testsuite/index.html <<EOF
<tr align="center">
  <td>&nbsp;</td>
  <td><b>Sum-<br>mary</b></td>
  <td><b>La-<br>TeX</b></td>
  <td><b>Bib-<br>TeX</b></td>
  <td><b>make_-<br>index</b></td>
  <td><b>Pdf-<br>LaTeX</b></td>
  <td><b>latex_-<br>to_html</b></td>
  <td><b>PS</b></td>
  <td><b>PDF</b></td>
  <td><b>HTML</b></td>
  <td><b>HTML<br>tgz</b></td>
</tr>
EOF
  fi
}

#---------------------------------------------------------------------#
# testsuite_end
#     - Creates 'testsuite' subdir
#     - Finishes index.html after second table (Packages)
#     - Moves everything to the testsuite target directory
#       (logfiles, PostScript and HTML results are already copied)
#---------------------------------------------------------------------#

testsuite_end () {
    cat >> testsuite/index.html <<EOF
</table>
<hr>

<div class="contact">
Last modified on <!--#echo var="LAST_MODIFIED" -->.
See <a href="http://www.cgal.org/">http://www.cgal.org/</a> and 
<a HREF="mailto:infoATcgal.org" subject="Mail from cgal.org web page">info at cgal dot org</a>
</div>
</body></html>
EOF
    if [ ! -d ${TestSuiteResultPath} ]; then
        echo "${ErrorColor}ERROR${ResetColor}: The directory '${TestSuiteResultPath}' for the testsuite results does not exist." 1>&2
        GlobalReturnStatus=1
    else

        # When the -testsuite option is used the script will copy all
        # the manuals and logfiles to
        # $TestSuiteResultPath/CGAL-$CgalVersion/ and creates an HTML
        # summary page index.html in that subdirectory. The latest
        # results is also always accessible at
        # $TestSuiteResultPath/last/index.html .  
        #    Futhermore, the script will cleanup old results. For the
        # most recent number $TestSuiteFullHistory of test suites the
        # full results including the manuals are kept. Older test
        # suites will have their manuals deleted to save space. Int
        # total only $TestSuiteHistory many test suites are kept.  
        #    The history of test suites is managed in a shift register
        # like fashion using files in $TestSuiteResultPath of defined
        # names History.<i> that contain the name of the i-th test
        # suite subdirectory. The 1st is the most recent test suite
        # and corresponds to the 'last' directory.
        #    If the test suite is repeated for the same internal 
        # release number, the new results will overwrite the old results.
        pushd ${TestSuiteResultPath} > /dev/null
        Target=CGAL-${CgalVersion}
        if [ ! -d ${Target} ]; then
            # do all the shifting only if test suite is new
            declare -i count=${TestSuiteHistory}
            if [ -r History.${count} ]; then
                subdir=`cat History.${count}`
                if [ -d $subdir ]; then \rm -fr $subdir ; fi
                \rm -f History.${count}
            fi
            while [ $count -gt 1 ] ; do
                oldcount=$count
                count=$count-1
                if [ -r History.${count} ]; then
                    subdir=`cat History.${count}`
                    if [[ ${oldcount} -gt ${TestSuiteFullHistory} && \
                            -d $subdir ]]; then 
                        \rm -f $subdir/*.ps.gz ; 
                        for f in ${subdir}/* ; do
                            if [ -d $f ]; then \rm -fr $f ; fi 
                        done
                        # also eliminate dead links in index.html to doc.
                        \mv ${subdir}/index.html ${subdir}/bak
                        \cat ${subdir}/bak | sed 's/\(class=\"manual\">\).*\(<\/td>\)/\1 -- \2/g' > ${subdir}/index.html
                    fi
                    \mv History.${count} History.${oldcount}
                fi
            done
            echo -n "${Target}" > History.1
            \mkdir ${Target}
            if [ -h LAST ]; then \rm -f LAST ; fi
            \ln -s ${Target} LAST
        fi
        popd  > /dev/null
        cp -r testsuite/* ${TestSuiteResultPath}/${Target}
        rm -r testsuite
        # send email notification
        if [ "${TestSuiteResultEmail}" != "" ]; then
            # Use this line on Sun Solaris systems
            # printf "Subject: [automatic] New manual test results ${Target}\n\n\n${TestSuiteResultUrl}/${Target}\n" | ${Sendmail} ${TestSuiteResultEmail}
            # use this line on Linux systems
            printf "\n${TestSuiteResultUrl}/${Target}\n" | ${Sendmail} -s "[automatic] New manual test results ${Target}" ${TestSuiteResultEmail}            
        fi
    fi
}

#_____________________________________________________________________.
#=====================================================================#
#                                                                     #
# main: read resource file and initialize globals                     #
#                                                                     #
#_____________________________________________________________________#
#=====================================================================#

# Selects the different output formats supported. If any option is
# given, reset all Make<format>'s and set them explicitly only.
SetMakePS=0
SetMakePDF=0
SetMakeHTML=0
Parameters=""

while [ $# -gt 0 ] ; do
  case "$1" in
    -h | --help) 
        usage
        exit 0
        ;;
    -V | --version)
        version
        exit 0
        ;;
    -ps) SetMakePS=1
        ;;
    -pdf) SetMakePDF=1
        ;;
    -html) SetMakeHTML=1
        ;;
    -wrapper) MakeWrapperOnly=1
        ;;
    -testsuite)
        MakeTestSuiteResult=1
        ;;
    -k) KeepLog=1
        NoLog=0
        ;;
    -n) NoLog=1
        KeepLog=0
        ;;
    -q) Quiet=1
        ;;
    -qq) RealQuiet=1
        Quiet=1
        ;;
    -s) Sum=1 ;;
    -v) Verbose=1 ;;
    -*) echo "${ErrorColor}ERROR${ResetColor}: Unknow option '$1'." 1>&2
        usage
        exit 2
        ;;
    *)  Parameters="${Parameters} `echo $1 | sed 's/[/]$//'`"
        # a trailing / (typical for directories) was removed
        if [[ ! -r $1 && ! -d $1 && ! -r $1.tex ]]; then
            echo "${ErrorColor}ERROR${ResetColor}: '$1' must be a Module (tex-file) or Package (directory)." 1>&2
            usage
            exit 2
        fi
        ;;
  esac
  shift
done

# Selects the different output formats supported. If any option is
# given, reset all Make<format>'s and set them explicitly only.
if [[ ${SetMakePS} -eq 1 || ${SetMakePDF} -eq 1 || ${SetMakeHTML} -eq 1 ]]; then
  MakePS=${SetMakePS}
  MakePDF=${SetMakePDF}
  MakeHTML=${SetMakeHTML}
fi
if [ $MakeTestSuiteResult -eq 1 ]; then
  NoLog=0
  KeepLog=1
fi

# Prepare TEXINPUTS and LATEX_CONV_INPUTS
if [ -r Manual/cgal_manual.sty ]; then # case 1: internal release
  export TEXINPUTS=".:../examples:../demo:${TEXINPUTS}"
  export LATEX_CONV_INPUTS=".:../examples:../demo:${LATEX_CONV_INPUTS}"
elif [ -r ../../Manual/doc_tex/Manual/cgal_manual.sty ]; then # case 2: package
  export TEXINPUTS=".:../../Manual/doc_tex:../examples:../demo:${TEXINPUTS}"
  export LATEX_CONV_INPUTS=".:../../Manual/doc_tex:../examples:../demo:${LATEX_CONV_INPUTS}"
else
  export TEXINPUTS=".:../examples:../demo:${TEXINPUTS}"
  export LATEX_CONV_INPUTS=".:../examples:../demo:${LATEX_CONV_INPUTS}"
  # case 3: all others, need to be checked if it is already in searchpath
  if [ "`find_in_search_path Manual/cgal_manual.sty ${TEXINPUTS}`" == "" ]; then
      echo "${ErrorColor}ERROR${ResetColor}: Could not find Manual/cgal_manual.sty in "'$TEXINPUTS'" search path." 1>&2
  fi
  if [ "`find_in_search_path Manual/cgal_manual.sty ${LATEX_CONV_INPUTS}`" == "" ]; then
      echo "${ErrorColor}ERROR${ResetColor}: Could not find Manual/cgal_manual.sty in "'$LATEX_CONV_INPUTS'" search path." 1>&2
  fi
fi

# Prepare BIBINPUTS
if [ -r Manual/cgal_manual.bib ]; then # case 1: internal release
  export BIBINPUTS=".:${BIBINPUTS}"
elif [ -r ../../Manual/doc_tex/Manual/cgal_manual.bib ]; then # case 2: package
  export BIBINPUTS="../../Manual/doc_tex:${BIBINPUTS}"
else
  # case 3: all others, need to be checked if it is already in searchpath
  if [ "`find_in_search_path Manual/cgal_manual.bib ${BIBINPUTS}`" == "" ]; then
      echo "${ErrorColor}ERROR${ResetColor}: Could not find Manual/cgal_manual.bib in "'$BIBINPUTS'" search path." 1>&2
  fi
fi

GlobalReturnStatus=0
if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_begin ; fi
if [[ "$Parameters" == "" ]]; then
    # no arguments, make Module manuals first
    for m in *[Mm]anual.tex ; do
        make_manual $m
    done
    if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_middle ; fi

    # make Package manuals second
    ManRefList=""
    for m in * ; do
        if [[ -d $m && -r $m/main.tex ]]; then  # it's a package
            # make sure that Manual and Manual_ref are matched up
            if [[ -d ${m}_ref && -r ${m}_ref/main.tex ]]; then
                ManRefList="$ManRefList ${m}_ref"
                make_manual $m ${m}_ref
            elif ! is_in_list $m $ManRefList ; then 
                # check that we did not handle it already as ${m}_ref
                make_manual $m
            fi
        fi
    done
else
    # make manuals given explicitly in the argumentlist
    # make Module manuals first
    for m in ${Parameters} ; do
        if is_module $m ; then
            make_manual $m
        fi
    done
    if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_middle ; fi

    # make Package manuals second
    ManRefList=""
    for m in ${Parameters} ; do
        if ! is_module $m ; then
            # make sure that Manual and Manual_ref are matched up
            if is_in_list ${m}_ref ${Parameters} ; then 
                ManRefList="$ManRefList ${m}_ref"
                make_manual $m ${m}_ref
            elif ! is_in_list $m $ManRefList ; then
                # check that we did not handle it already as ${m}_ref
                make_manual $m
            fi
        fi
    done
fi
if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_end ; fi
exit $GlobalReturnStatus
