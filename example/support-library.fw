\documentclass[]{article}
\usepackage{amssymb}
\usepackage{fw-latex}
\usepackage{cgal}

\textwidth=6in
\textheight=8.9in
\oddsidemargin=0.25in
\evensidemargin=0.25in
\topmargin=-0.5in
\begin{document}

@p typesetter = tex
@p no_doc_header

@!@p maximum_output_line_length = 120
@!@p maximum_input_line_length = 120

\title{\bf The CGAL Support Library\\
           IO streams}
\author{Andreas Fabri}
\date{}
\maketitle

@A@<Introduction@>

\cgal\ is a library for geometric algorithms. For the purpose of
illustrating algorithms it is useful to dump a result in a Postscript
file, and to include this in the documentation of the algorithm. When
you are debugging geometry code it is useful to make a graphical trace
of what happens, or to have an interactive tool that allows to input
objects.  The support library of \cgal\ contains tools for that, or
interfaces to tools that already exist. For the moment you can get raw
output in {\sc Ascii} format and interactive input/output to a 2d
window system from \leda. We support input and output to {\em
geomview}, a 3d visualization tool developed at the {\em Geometry
Center}, Minneapolis.

This document is intended as a kind of tutorial, illustrating
what you can do with the different \cgal\ stream classes. It does
not replace the manual.

@A@<Output in ASCII format@>

If you insert an object from the \cgal\ kernel in a \CC\ ostream, that
is `{\tt cout}' or `{\tt fstream}', using the ouptput operator `\opout' it
will be pretty printed.  This typically looks as follows:
`{\tt Point\_2(34.0634, 20.0000)}'.

In order to get that functionality, you have to include the following
headerfile:  {\tt \#include $<$CGAL/IO/ostream\_2.h$>$}. It is important
that this file is included after that all header files of geometric
objects are included.



@A@<I/O with the Window Stream@>

The \leda\ library has an entire X11 based window system. We derived
the class `{\tt CGAL\_Window\_stream}' from the \leda\ class `{\tt window}',
and tailored it for the needs of the \cgal\ user.

In the next sections you will see an example program that makes
use of this stream class for input as well as for output.

@B@<Header Files@>

All header files for classes from the \cgal\ library are in a directory
{\tt CGAL/}.  This has a further subdirectory {\tt CGAL/IO/} regrouping all
header files concerning input and output streams.

The file {\tt Window\_stream.h} does not include any header file
concerning geometric classes. You have to include them before.
The reason to do so is that we want to minimize the header files
read at compile time.

@$@<header files@>==@{@-
#include <CGAL/Cartesian.h>
#include <iostream.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Line_2.h>
#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/IO/Window_stream.h>
@}

@B@<Typedefs Make Your Life Easier@>

Class names in \cgal\ are pretty long. They are prefixed to avoid
name clashes, they have the dimension encoded in the name and are
templated. This gives you a lot of flexibility. As long as you do not
use several number types or even representation classes at the same time
it is practical to define new types with the {\tt typedef} from \CC.

@$@<typedefs@>==@{@-

typedef double coord_type;
typedef CGAL_Point_2< CGAL_Cartesian<coord_type> > Point;
typedef CGAL_Vector_2< CGAL_Cartesian<coord_type> > Vector;
typedef CGAL_Direction_2< CGAL_Cartesian<coord_type> > Direction;

typedef CGAL_Segment_2< CGAL_Cartesian<coord_type> > Segment;
typedef CGAL_Line_2< CGAL_Cartesian<coord_type> > Line;
typedef CGAL_Ray_2< CGAL_Cartesian<coord_type> > Ray;

typedef CGAL_Iso_rectangle_2< CGAL_Cartesian<coord_type> > Iso_rectangle;

typedef CGAL_Bbox_2 Bbox;
@}


@B@<Declaration and Initilization of a Window@>

You first define a window. The parameters are the size of the
{\em physical window} in pixels. Before you perform the first real input
or output operations on the window you have to initialize it, by telling
the window how large your {\em logical window} is. The parameters are
the minimal and maximal $x$-coordinates and the minimal $y$-coordinate.
The maximal $y$-coordinate depends on these three parameters. The function
{\tt init(..)} can also be called with a bounding box as argument.

@$@<declaration and initilization of a window@>==@{@-

  CGAL_Window_stream W(400, 200);

  W.init(-20.0, 20.0, -10.0);

@}

@B@<Examples for Output@>

You know how to print on `{\tt cout}' using the operator `\opout'. For
window streams it works just the same. Whatever geometric object you
have, you can insert it in the stream, which means to draw them on the
window. We can draw a coordinate system as follows:

@$@<examples for output@>==@{@-
  {
    int i;
    W << CGAL_RED;
    W << Line(Point(0.0, 0.0), Direction(1.0, 0.0));
    W << Line(Point(0.0, 0.0), Direction(0.0, 1.0));
    for(i = -35; i<=35; i+=5){
      W << Segment(Point(double(i), 0.2),
                   Point(double(i), -0.3));
    }
    for(i = -5; i<=5; i+=5){
      W << Segment(Point(-0.2, double(i)),
                   Point(0.2, double(i)));
    }
  }
@}

@B@<Examples for Input@>

It will not surprise you that input makes use of the input operator
`\opin'. The objects are echoed, that is when you get input the object
is drawn on your screen.

In the following example we get input for a line and iso-oriented
rectangles. The same is possible for the other objects defined in the
kernel of \cgal. We further draw a bounding box in the example: It is
drawn with dotted lines.

@$@<examples for input@>==@{@-
  {
    W << CGAL_BLACK;
    Line line;
    W >> line;

    Iso_rectangle iso_r1, iso_r2;

    W >> iso_r1;
    W >> iso_r2;
    W << iso_r1.bbox() + iso_r2.bbox();
  }
@}

@C@<Examples for Colors@>

   \cgal\ provides a class {\tt CGAL\_Color} which is constructed with
three integers between 0 and 255 for the red green and blue
component. These color objects can also be inserted in a window
stream. For some colors we have predefined constants, so that you
don't have to think about how to compose them.

When you insert a color in a stream the next objects are drawn in
this color, up to the next insertion of a color.

@$@<examples for colors@>==@{@-

  Segment segment;
  for(int count = 0; count < 10; count++){
    W << CGAL_BLUE ;

    W >> segment ;

    W << CGAL_GREEN  << segment.start() ;
    W << CGAL_ORANGE << segment.end() ;
    Line line = segment.supporting_line().perpendicular(segment.start()) ;
    W << CGAL_VIOLET << line ;
    W << segment.bbox() ;

  }
@}

@B@<Putting it Together@>

In the directory where you found this documentation you should find a
a \CC\ source file called {\it io2window.C}.

@O@<io2window.C@>==@{@-

@<header files@>

@<typedefs@>

int main()
{
  @<declaration and initilization of a window@>

  @<examples for output@>

  @<examples for input@>

  @<examples for colors@>

  char c;
  cout << " Type any character to continue: " << endl;
  cin >> c;
  cout << " done" << endl;

  return 1;
}
@}

To compile it, type `{\it gmake io2window}'. Type `{\it io2window}' to run
it. You should have a look at the makefile to see which \leda\ libraries
have to be linked with a module when you use the class
`{\tt CGAL\_Window\_stream}'.


@i io2geomview.fw



\end{document}
