
%*******************************************************************************
%*                    START OF AUTOMATICALLY GENERATED TEX FILE                *
%*******************************************************************************
%*                                                                             *
%* This TeX file was automatically generated by the FunnelWeb preprocessor.    *
%* You can typeset this file to produce printed documentation by running it    *
%* through the TeX typesetter using a command such as:                         *
%*    latex thisfilename                                                       *
%* (the standard TeX header was not included, due to the presence of a         *
%*  `@p no_doc_header' pragma in the original FunnelWeb source file.           *
%*  It is hence assumed that the FunnelWeb code was in the form of a LaTeX     *
%*  file starting with a line of the form                                      *
%*    \documentstyle[fw-latex,...]{...}                                        *
%*  If not, don't blame FunnelWeb for the resulting TeX or LaTeX errors ...    *
%*  The file `fw-latex.sty' can be found at the ftp archive noted below.)      *
%* The resultant file thisfilename.dvi can be printed using a command such as: *
%*    lpr -Pcslw -d thisfilename.dvi                                           *
%*                                                                             *
%* FunnelWeb is a preprocessor that allows programmers to weave programs and   *
%* their documentation together in a single document. The FunnelWeb program    *
%* analyses such documents producing both program files and typeset            *
%* documentation such as this TeX file.                                        *
%* FunnelWeb was created by Ross Williams.                                     *
%*                                                                             *
%* For more information on FunnelWeb look in the following FTP archive:        *
%*    Machine  : sirius.itd.adelaide.edu.au [IP=129.127.40.3].                 *
%*    Directory: ~pub/funnelweb/                                               *
%*               (or some other appropriately named directory).                *
%* or email Ross Williams at ross@spam.adelaide.edu.au                         *
%*     (Tony Coates at coates@physics.uq.oz.au for pragma `no_doc_header') *
%*                                                                             *
%*******************************************************************************


\documentclass[]{article}
\usepackage{amssymb}
\usepackage{fw-latex}
\usepackage{cgal}

\textwidth=6in
\textheight=8.9in
\oddsidemargin=0.25in
\evensidemargin=0.25in
\topmargin=-0.5in
\begin{document}



\title{\bf The CGAL Support Library\\
           IO streams}
\author{Andreas Fabri}
\date{}
\maketitle

\fwseca{1}{Introduction}

\cgal\ is a library for geometric algorithms. For the purpose of
illustrating algorithms it is useful to dump a result in a Postscript
file, and to include this in the documentation of the algorithm. When
you are debugging geometry code it is useful to make a graphical trace
of what happens, or to have an interactive tool that allows to input
objects.  The support library of \cgal\ contains tools for that, or
interfaces to tools that already exist. For the moment you can get raw
output in {\sc Ascii} format and interactive input/output to a 2d
window system from \leda. We support input and output to {\em
geomview}, a 3d visualization tool developed at the {\em Geometry
Center}, Minneapolis.

This document is intended as a kind of tutorial, illustrating
what you can do with the different \cgal\ stream classes. It does
not replace the manual.

\fwseca{2}{Output in ASCII format}

If you insert an object from the \cgal\ kernel in a \CC\ ostream, that
is `{\tt cout}' or `{\tt fstream}', using the ouptput operator `\opout' it
will be pretty printed.  This typically looks as follows:
`{\tt Point\_2(34.0634, 20.0000)}'.

In order to get that functionality, you have to include the following
headerfile:  {\tt \#include $<$CGAL/IO/ostream\_2.h$>$}. It is important
that this file is included after that all header files of geometric
objects are included.



\fwseca{3}{I/O with the Window Stream}

The \leda\ library has an entire X11 based window system. We derived
the class `{\tt CGAL\_Window\_stream}' from the \leda\ class `{\tt window}',
and tailored it for the needs of the \cgal\ user.

In the next sections you will see an example program that makes
use of this stream class for input as well as for output.

\fwsecb{3.1}{Header Files}

All header files for classes from the \cgal\ library are in a directory
{\tt CGAL/}.  This has a further subdirectory {\tt CGAL/IO/} regrouping all
header files concerning input and output streams.

The file {\tt Window\_stream.h} does not include any header file
concerning geometric classes. You have to include them before.
The reason to do so is that we want to minimize the header files
read at compile time.

\fwbeginmacro
\fwmacroname{header files}{1}\fwequals \fwodef \fwbtx[#include <CGAL/Cartesian.h>
#include <iostream.h>
#include <CGAL/Ray_2.h>
#include <CGAL/Line_2.h>
#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/IO/Window_stream.h>
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 7.}
\fwendmacronotes
\fwendmacro


\fwsecb{3.2}{Typedefs Make Your Life Easier}

Class names in \cgal\ are pretty long. They are prefixed to avoid
name clashes, they have the dimension encoded in the name and are
templated. This gives you a lot of flexibility. As long as you do not
use several number types or even representation classes at the same time
it is practical to define new types with the {\tt typedef} from \CC.

\fwbeginmacro
\fwmacroname{typedefs}{2}\fwequals \fwodef \fwbtx[
typedef double coord_type;
typedef CGAL_Point_2< CGAL_Cartesian<coord_type> > Point;
typedef CGAL_Vector_2< CGAL_Cartesian<coord_type> > Vector;
typedef CGAL_Direction_2< CGAL_Cartesian<coord_type> > Direction;

typedef CGAL_Segment_2< CGAL_Cartesian<coord_type> > Segment;
typedef CGAL_Line_2< CGAL_Cartesian<coord_type> > Line;
typedef CGAL_Ray_2< CGAL_Cartesian<coord_type> > Ray;

typedef CGAL_Iso_rectangle_2< CGAL_Cartesian<coord_type> > Iso_rectangle;

typedef CGAL_Bbox_2 Bbox;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 7.}
\fwendmacronotes
\fwendmacro



\fwsecb{3.3}{Declaration and Initilization of a Window}

You first define a window. The parameters are the size of the
{\em physical window} in pixels. Before you perform the first real input
or output operations on the window you have to initialize it, by telling
the window how large your {\em logical window} is. The parameters are
the minimal and maximal $x$-coordinates and the minimal $y$-coordinate.
The maximal $y$-coordinate depends on these three parameters. The function
{\tt init(..)} can also be called with a bounding box as argument.

\fwbeginmacro
\fwmacroname{declaration and initilization of a window}{3}\fwequals \fwodef \fwbtx[
  CGAL_Window_stream W(400, 200);

  W.init(-20.0, 20.0, -10.0);

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 7.}
\fwendmacronotes
\fwendmacro


\fwsecb{3.4}{Examples for Output}

You know how to print on `{\tt cout}' using the operator `\opout'. For
window streams it works just the same. Whatever geometric object you
have, you can insert it in the stream, which means to draw them on the
window. We can draw a coordinate system as follows:

\fwbeginmacro
\fwmacroname{examples for output}{4}\fwequals \fwodef \fwbtx[  {
    int i;
    W << CGAL_RED;
    W << Line(Point(0.0, 0.0), Direction(1.0, 0.0));
    W << Line(Point(0.0, 0.0), Direction(0.0, 1.0));
    for(i = -35; i<=35; i+=5){
      W << Segment(Point(double(i), 0.2),
                   Point(double(i), -0.3));
    }
    for(i = -5; i<=5; i+=5){
      W << Segment(Point(-0.2, double(i)),
                   Point(0.2, double(i)));
    }
  }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 7.}
\fwendmacronotes
\fwendmacro


\fwsecb{3.5}{Examples for Input}

It will not surprise you that input makes use of the input operator
`\opin'. The objects are echoed, that is when you get input the object
is drawn on your screen.

In the following example we get input for a line and iso-oriented
rectangles. The same is possible for the other objects defined in the
kernel of \cgal. We further draw a bounding box in the example: It is
drawn with dotted lines.

\fwbeginmacro
\fwmacroname{examples for input}{5}\fwequals \fwodef \fwbtx[  {
    W << CGAL_BLACK;
    Line line;
    W >> line;

    Iso_rectangle iso_r1, iso_r2;

    W >> iso_r1;
    W >> iso_r2;
    W << iso_r1.bbox() + iso_r2.bbox();
  }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 7.}
\fwendmacronotes
\fwendmacro


\fwsecc{3.5.1}{Examples for Colors}

   \cgal\ provides a class {\tt CGAL\_Color} which is constructed with
three integers between 0 and 255 for the red green and blue
component. These color objects can also be inserted in a window
stream. For some colors we have predefined constants, so that you
don't have to think about how to compose them.

When you insert a color in a stream the next objects are drawn in
this color, up to the next insertion of a color.

\fwbeginmacro
\fwmacroname{examples for colors}{6}\fwequals \fwodef \fwbtx[
  Segment segment;
  for(int count = 0; count < 10; count++){
    W << CGAL_BLUE ;

    W >> segment ;

    W << CGAL_GREEN  << segment.start() ;
    W << CGAL_ORANGE << segment.end() ;
    Line line = segment.supporting_line().perpendicular(segment.start()) ;
    W << CGAL_VIOLET << line ;
    W << segment.bbox() ;

  }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 7.}
\fwendmacronotes
\fwendmacro


\fwsecb{3.6}{Putting it Together}

In the directory where you found this documentation you should find a
a \CC\ source file called {\it io2window.C}.

\fwbeginmacro
\fwfilename{io2window.C}{7}\fwequals \fwodef \fwbtx[
]fwetx=%
\fwmacroname{header files}{1}\fwbtx[

]fwetx=%
\fwmacroname{typedefs}{2}\fwbtx[

int main()
{
  ]fwetx=%
\fwmacroname{declaration and initilization of a window}{3}\fwbtx[

  ]fwetx=%
\fwmacroname{examples for output}{4}\fwbtx[

  ]fwetx=%
\fwmacroname{examples for input}{5}\fwbtx[

  ]fwetx=%
\fwmacroname{examples for colors}{6}\fwbtx[

  char c;
  cout << " Type any character to continue: " << endl;
  cin >> c;
  cout << " done" << endl;

  return 1;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


To compile it, type `{\it gmake io2window}'. Type `{\it io2window}' to run
it. You should have a look at the makefile to see which \leda\ libraries
have to be linked with a module when you use the class
`{\tt CGAL\_Window\_stream}'.



\fwseca{4}{I/O with the Geomview Stream}

{\it geomview} is a viewer for three-dimensional objects. We provide
bidirectional commmunication between \cgal\ applications and {\it geomview}.



\fwsecb{4.1}{Declaration and Initialization of a geomview stream}


The parameters are the machine where to run {\it geomview}, e.g., {\it
sophia.inria.fr}, a login name (as you might have another login name on
another machine) and a bounding box. The camera is
positioned such that the bounding box is in the scene. You can draw
outside the bounding box and you can reposition the camera later.

If you do not supply a machine name and a login, it will run on your
local machine. The remote facility is useful if you have a graphics
workstation at hand: run {\it geomview} there while your application
runs on your machine.

\fwbeginmacro
\fwmacroname{declaration and initialization of a geomview stream}{8}\fwequals \fwodef \fwbtx[
  CGAL_geomview_stream geomview(machine, login, Bbox(0,0,0, 1000,1000,100));

]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 12.}
\fwendmacronotes
\fwendmacro


\fwsecb{4.2}{Typedefs for 3D Objects}

As usual we make our life easier by defining new types.

\fwbeginmacro
\fwmacroname{typedefs for 3D objects}{9}\fwequals \fwodef \fwbtx[typedef double coord_type;

typedef CGAL_Point_3< CGAL_Cartesian<coord_type> > Point;
typedef CGAL_Segment_3< CGAL_Cartesian<coord_type> > Segment;

typedef CGAL_Triangle_3< CGAL_Cartesian<coord_type> > Triangle;
typedef CGAL_Tetrahedron_3< CGAL_Cartesian<coord_type> > Tetrahedron;

typedef CGAL_Bbox_3 Bbox;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 12.}
\fwendmacronotes
\fwendmacro


\fwsecb{4.3}{Examples for Output}

No surprise, output also happens via the output operator of \CC; you
simply insert geometric objects in the stream. The operator is so far
defined for points, segments, triangles and tetrahedra. For lines and
rays we still have to write the clipping routines.


\fwbeginmacro
\fwmacroname{examples for geomview output}{10}\fwequals \fwodef \fwbtx[
void output_fct(CGAL_geomview_stream &visualizer)
{
  random_source S(1,999);
  int a,b, c,d, e,f;
  for (int i=0; i<=3; i++) {
    S >> a >> b >> c >> d >> e >> f;

    Point p1(a, b, 100*i),
          p2(c, d, 100*i),
          p3(e, f, 100*i);

    Triangle tr(p1, p2, p3);

    visualizer << tr ;
    visualizer << p1 ;
  }

  Tetrahedron tetrahedron(Point(10, 10, 10),
                          Point(300, 10, 10),
                          Point(150, 150, 10),
                          Point(100, 100, 400));
  visualizer << tetrahedron;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 12.}
\fwendmacronotes
\fwendmacro


\fwsecb{4.4}{Examples for Input}

At the very moment input is only provided for points. As the input is
a point in three-dimensional space, but the screen is flat, we input
points on an object called {\em pickplane}. The pickplane can be
moved around.

\fwbeginmacro
\fwmacroname{examples for geomview input}{11}\fwequals \fwodef \fwbtx[void input_fct(CGAL_geomview_stream &visualizer)
{

  Point p;

  for(int i=0;i<4;i++){
    visualizer >> p;
    visualizer << p;
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 12.}
\fwendmacronotes
\fwendmacro


\fwsecb{4.5}{Putting it Together}

In the directory where you found this documentation you should find a
a \CC\ source file called {\it io2geomview.C}.

\fwbeginmacro
\fwfilename{io2geomview.C}{12}\fwequals \fwodef \fwbtx[#include <CGAL/Cartesian.h>

#include <iostream.h>
#include <LEDA/random.h>

#include <CGAL/IO/geomview.h>

]fwetx=%
\fwmacroname{typedefs for 3D objects}{9}\fwbtx[

]fwetx=%
\fwmacroname{examples for geomview input}{11}\fwbtx[
]fwetx=%
\fwmacroname{examples for geomview output}{10}\fwbtx[

int main(int argc, char **argv)
{
  char  *machine = (argc>1)?argv[1]:NULL;
  char *login = (argc>2)?argv[2]:NULL;

  ]fwetx=%
\fwmacroname{declaration and initialization of a geomview stream}{8}\fwbtx[

  output_fct(geomview);

  input_fct(geomview);


  return 1;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


To compile it, type `{\it gmake io2geomview}'. Type `{\it
io2geomview}' to run it on your machine or type `{\it io2geomview
silicon.inria.fr username}' to run it on a remote machine.
You should have a look at the makefile to see which \leda\ libraries
have to be linked with a module when you use the class
`{\tt CGAL\_Geomview\_stream}'.

\fwsecb{4.6}{Synchronizing the application with geomview}

{\it geomview} has a startup file. It contains  directives which
panels to show right away from the beginning. The last line is
responsible for synchronizing the application with {\it geomview}.

\fwbeginmacro
\fwfilename{.geomview}{13}\fwequals \fwodef \fwbtx[(progn
  (ui-panel tools off {position 450 130 400 400})
  (ui-panel cameras off {position 0 130 400 400})
  (ui-panel geomview on {position 50 2080 200 400})
  )

(set-load-path (/net11/lib/geomview/Geomview-1.5/data))

(backcolor "Camera" 1.0 1.0 1.0)

# the following line is needed if geomview is started inside
# a CGAL application. It is used to synchronize the processes
(echo "started")
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro




\end{document}


%*******************************************************************************
%*                    END OF AUTOMATICALLY GENERATED TEX FILE                  *
%*******************************************************************************

