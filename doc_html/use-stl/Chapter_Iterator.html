<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Iterator.html -->
  <!-- by cc_extract_html, $Revision: 2.7 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Iterator.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<H1>Iterators<A NAME="chapterIterators"></A></H1>
<P>

Iterators are a generalization of pointers that allow a programmer to
work with different data structures (containers) in a uniform manner.
An <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> is the glue that allows to write a single implementation of
an algorithm that will work for data contained in an array, a <A HREF="list.html#Cross_link_anchor_24">list</A> or
some other container - even a container that did not yet exist when the
algorithm was implemented.<P>

An <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> is a concept, not a programming language construct. It can
be seen as a <A HREF="set.html#Cross_link_anchor_27">set</A> of requirements. A type is an <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> if it satisfies
those requirements. So, for instance, a pointer to an element of an
array is an <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>. We will check this later.<P>

Depending on the operations defined for an <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>, there are five
categories: <EM>input, output, forward, bidirectional</EM> and <EM>random access iterators</EM>. We first have to introduce some terminology.<P>

<B>Mutable versus constant:</B>
There is an additional attribute that forward, bidirectional and
random access iterators might have, that is, they can be <EM>mutable</EM>
or <EM>constant</EM> depending on whether the result of the <TT>operator </TT>
\raisebox-1mm* behaves as a reference or as a reference to a constant.<P>

<B>Past-the-end value:</B>
Just as a regular pointer to an array guarantees that there is a
pointer value pointing past the last element of the array, so for any
<A HREF="iterator.html#Cross_link_anchor_1">iterator</A> type there is an <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> value that points past the last
element of a corresponding container. These values are called <EM>past-the-end</EM> values. Values of the <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> for which the <TT>operator</TT>
\raisebox-1mm* is defined are called <EM>dereferenceable</EM>.
The library never assumes that past-the-end values are
dereferenceable.<P>

<B>Reachability</B> An <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> <MATH>j</MATH> is called <EM>reachable</EM> from an
<A HREF="iterator.html#Cross_link_anchor_1">iterator</A> <MATH>i</MATH> if and only if there is a finite sequence of applications
of <I>operator</I><MATH>++</MATH> to <MATH>i</MATH> that makes <MATH>i == j</MATH>. If <MATH>i</MATH> and
<MATH>j</MATH> refer to the same container, then either <MATH>j</MATH> is reachable from
<MATH>i</MATH>, or <MATH>i</MATH> is reachable from <MATH>j</MATH>, or both (<MATH>i == j</MATH>).<P>

<B>Range:</B>
Most of the library's algorithmic templates that operate on data
structures have interfaces that use <EM>ranges</EM>. A range is a <A HREF="pair.html#Cross_link_anchor_0">pair</A> of
iterators that designate the beginning and end of the computation. A
range <MATH>[i, i)</MATH> is an <EM>empty range</EM>; in general, a range
<MATH>[i, j)</MATH> refers to the elements in the data structure
starting with the one pointed to by <MATH>i</MATH> and up to but not including the
one pointed to by <MATH>j</MATH>. Range <MATH>[i, j)</MATH> is valid if and only if <MATH>j</MATH>
is reachable from <MATH>i</MATH>. The result of the application of the
algorithms in the library to invalid ranges is undefined.<P>

As we mentioned in the introduction we are a little bit sloppy in the
presentation of \stl, in order to make it easier to understand. A
class is said to be an <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> if it fulfills a <A HREF="set.html#Cross_link_anchor_27">set</A> of requirements.
In the following sections we do not present the requirements, but we
state properties that are true, if the requirements are fulfilled.
The difference is best seen by an example: we write that the return
value of the test for equality returns a <I>bool</I>, but the
requirement is only that the return value is convertible to <I>bool</I>.<P>

<P><UL><LI>
 Class declaration of <A HREF="iterator.html"><I>iterator</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="iterator.html"><I>iterator</I></A>.</UL>

<P>

<P><UL><LI>
 Class declaration of <A HREF="iterator.html"><I>iterator</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="iterator.html"><I>iterator</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="iterator.html"><I>iterator</I></A>.</UL>

<P>

<P><HR> Next chapter: <A HREF="Chapter_Circulator_stl.html">Circulators</A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Iterator.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
