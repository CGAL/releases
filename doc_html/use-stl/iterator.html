<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Iterator.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>STL in CGAL: iterator</TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Iterator.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_5"></A>

<A NAME="Cross_link_anchor_5"></A>

<P>

<H1> Output Iterator (<I><A HREF="iterator.html#Cross_link_anchor_1">iterator</A></I>)</H1>
<P>

<H3>Definition</H3>A class <I><A HREF="iterator.html#Cross_link_anchor_1">iterator</A></I> that satisfies the
requirements of an output <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> for the value type <I>T</I>,
supports the following operations.
<P>

Algorithms on input iterators should never attempt to pass through the
same <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> twice. They should be single pass algorithms.
<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> it;
        </I></NOBR>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> it (  <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> it1);
        </I></NOBR>
        </TD></TR>
    
    <P>
        </TABLE><!2>

<P>

<H3>Operations</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     it =  <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> it1
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Assignment.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     it ==  <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> it1
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Test for equality: Two iterators are equal if they refer to the
    same item.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     it !=  <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> it1
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Test for inequality. The result is the same as <I>!(it == it1)</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    T&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    * it  
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a reference to the value of the <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>. This operator can
    only be used in order to assign a value to this reference.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    ++ it  
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Prefix increment operation.
    <BR><STRONG>Precondition: </STRONG><I>it</I> is dereferenceable.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     it  ++
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Postfix increment operation. The result is the same as that of
    <I><A HREF="iterator.html#Cross_link_anchor_1">iterator</A> tmp = it; ++it; return tmp;</I>.
    <BR><STRONG>Precondition: </STRONG><I>it</I> is dereferenceable.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Example</H3>The following code fragment reads numbers of the type
<I>double</I> from <I>cin</I> and computes their sum. The <TT>STL</TT>
provides an <I>ostream_iterator</I> that fulfills the output <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>
requirements. As the <A HREF="iterator.html#Cross_link_anchor_1">iterator</A> is a kind of file pointer it should be
clear why only single pass algorithms can be applied on this <A HREF="iterator.html#Cross_link_anchor_1">iterator</A>.
<P>

<PRE>
{
    ostream_iterator&lt;double&gt; it(cout);
    for(int r = 0; r &lt; 10; r++){
        *it = 3.1415 * r * r;
        ++it;
    }
}
</PRE>
<P>

The above code fragment is equivalent to:
<P>

<PRE>
{
    for(int r = 0; r &lt; 10; r++){
        cout &lt;&lt; 3.1415 * r * r;  
    }
}
</PRE>
<P>

The use of output iterators is better illustrated with a function that
can write into arbitrary containers:
<P>

<PRE>
template &lt; class OutputIterator &gt;
void
generator(OutputIterator it)
{
    for(int r = 0; r &lt; 10; r++){
        *it = 3.1415 * r * r;
        ++it;
    }
}
</PRE>
<P>

and here comes its usage.
<P>

<PRE>
{
    ostream_iterator&lt;double&gt; it(cout);
    generator(it);
    double R[10];
    generator(R);
}
</PRE>
<P>

Note that the memory where the function <I>generator</I> writes to must
be allocated. If you want to insert the generated doubles at the end of
a <A HREF="list.html#Cross_link_anchor_24">list</A> you have to use a <I>back_insert_iterator</I>. To explain this
is out of the scope of this introduction to the <TT>STL</TT>. Please
refer to the <TT>STL</TT> reference manuals.
<P>
<HR><B> Return to chapter:</B> <A HREF="Chapter_Iterator.html">Iterators<A NAME="chapterIterators"></A></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Iterator.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
