<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_main.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<H1>Boolean Operations in 2D</H1>
 <A NAME="Bops"></A><P>

<A NAME="Section_1"></A>
<H2>Introduction</H2>
<P>

CGAL provides boolean operations for polytopes in the 2-dimensional
Euclidean space. The functions described in
the next section apply to two simple
polygons. Both boundary and interior are considered as part of a polygon.
Boolean operations on polygons are therefore not limited to operations
on the boundary of the objects.
The functions described in this chapter
allow to perform the purely geometric operations
intersection, union, and difference on two polygons
in the 2-dimensional Euclidean space. They should not be confused with
the regularised operations in the context of solid modeling.<P>

A clear distinction should be made between two sorts of functions
described in this chapter. Some operations perform an intersection
test without computing the actual result of the intersection.
Other operations perform a boolean operation (intersection,
union, or difference): they explicitly compute and return the result
of the boolean operation on two polygons.<P>

Note that particular classes of polytopes are not closed under
boolean operations. For instance, the union of two simple polygons is
not necessarily a simple polygon, or the intersection of two triangles
is not necessarily a triangle.<P>

All functions described below are template functions. Some are
parameterized only by the number type (denoted by <I>R</I>),
others are parameterized with a traits class (denoted by
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A></I>).
Where we use polygons of type
<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> the functions are parameterized by a
number type (denoted by <I>R</I>) and container (denoted by
<I>Container</I>), as it is the case for <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
For more details we refer to the description of <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
In a boolean operations traits
class some types and functions needed for the computation of
boolean operations are defined. We provide a default version of the
traits class for boolean operations, which we describe in detail below.
So the user need not (but can if desired) provide ones own boolean operations
traits class.<P>

Note:
The current version of boolean operations is robust only when exact arithmetic,
for instance <I>CGAL_Cartesian&lt;CGAL_Rational&gt;</I>, is used.
In nearly degenerate configurations, correct results are not guaranteed
when floating point numbers are used.<P>

<P><A NAME="Section_2"></A>
<H2>Boolean Operations on Polygons</H2>
<P>

<H3>Definition</H3>Boolean operations are provided for two simple polygons (for the
definition of simple polygons, see Chapter&nbsp;2.1<P>

).
A triangle and an iso-oriented rectangle clearly are special cases of
simple polygons.<P>

A polygon on which the boolean operations can be performed
can be stored in one of the following CGAL-objects:
<UL>
<LI><I>CGAL_Triangle_2</I>, a 2-dimensional triangle.
<LI><I>CGAL_Iso_rectangle_2</I>, a 2-dimensional iso-oriented rectangle.
<LI><I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>, a 2-dimensional polygon.
It must be simple, but not necessarily convex.
So, non-adjacent edges do not intersect and there are no holes in the polygon.
The vertices of such a polygon must be ordered in counterclockwise
order.
</UL><P>

We consider polygons as being closed and filled objects, i.e. we consider
both its boundary and its interior.
The edge cycle of the polygon will be referred
to explicitly as the polygon boundary.
For boolean operations the distinction between the interior and
the exterior of a polygon is determined by the order of its vertices.<P>

The result of an intersection test is one of the boolean
values <I>true</I> or <I>false</I>.
The result of an intersection, union, or difference can be empty, a single
object, or several objects.
An object can be a point, a segment,
a triangle, an iso-oriented rectangle, a polygon, or a polygon with
one or several holes.<P>

There, where the result cannot be more than one object (in the case of
the intersection of two triangles, and in the case of the
intersection of two iso-rectangles) the corresponding function returns
a possibly empty object. In all other cases the functions return a
possibly empty sequence of objects.<P>

Note that whenever we refer to a
``sequence'' of objects we actually mean a collection of objects
independent of the way in which they are stored. We provide
a mechanism which allows the user to define the type of ``sequence'' in
which the output will be stored (the template
<I>OutputIterator</I>, see further for details).<P>

Vertices of input polygons must be ordered counterclockwise.
Vertices of output polygons are ordered counterclockwise.
However, vertices of polygons representing holes (as part of
the output) are ordered clockwise.
For instance, if the result of a boolean operation is a polygon with some
holes, then this result will be represented as a sequence of polygons,
where the first one
representing the outer boundary of the contour is ordered counterclockwise
and the following ones representing the inner contours (holes) are ordered
clockwise.<P>

For two simple polygons <MATH>A</MATH> and <MATH>B</MATH>, the boolean operations are
defined:
<DL><P>

<LI>[Intersection test] of two polygons (<I>CGAL_do_intersect(A,B)</I>):
This checks if the two polygons <MATH>A</MATH> and <MATH>B</MATH> do intersect without computing
the intersection area.
It returns <I>true</I> if the polygons <MATH>A</MATH> and <MATH>B</MATH> do intersect,
otherwise <I>false</I> will be returned.<P>

<LI>[Intersection] of two polygons (<I>CGAL_intersection(A,B)</I>):
It performs the operation <MATH>C:=A \cap B</MATH> and returns the result <MATH>C</MATH>
as a maybe empty sequence of objects (<I>CGAL_Object</I>),
i.e. a sequence containing objects of type <I>CGAL_Point_2</I>,
<I>CGAL_Segment_2</I>, and <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
When <MATH>A</MATH> and <MATH>B</MATH> are both triangles (<I>CGAL_Triangle_2</I>)
or when <MATH>A</MATH>
and <MATH>B</MATH> are both iso-oriented rectangles
(<I>CGAL_Iso_rectangle</I>) the result can
only be a single object and therefore the intersection will return
a <I>CGAL_Object</I> instead of a sequence of objects.<P>

<LI>[Union] of two polygons ( <I>CGAL_union(A,B)</I>): It
performs the operation <MATH>C:=A \cup B</MATH> and returns the result <MATH>C</MATH> as
a maybe empty sequence of objects (<I>CGAL_Object</I>), i.e. a
sequence containing objects of type <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>. The
first polygon gives the counterclockwise-ordered outer boundary of
the contour of the union and the following polygons (if existing)
define the inner clockwise-ordered contours (the holes). If <MATH>A
    \cap B</MATH> is exactly one point (a vertex of at least one of the two
input polygons), the union returns one non-simple polygon. If <MATH>A
    \cap B</MATH> is empty, then a sequence will be returned consisting of <MATH>A</MATH>
and <MATH>B</MATH> both represented as polygons with counterclockwise ordered
contour.<P>

<LI>[Difference] of two polygons (<I>CGAL_difference(A,B)</I>):
This performs the operation <MATH>C:=A \ interior(B)</MATH> and
returns the result <MATH>C</MATH>
as a maybe empty sequence of objects (<I>CGAL_Object</I>),
i.e. a sequence containing objects of type <I>CGAL_Point_2</I>,
<I>CGAL_Segment_2</I>, and <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
If <MATH>A \cap B</MATH> is empty
then <MATH>A</MATH> will be returned.
If <MATH>A \cap B = A</MATH> (i.e. <MATH>A subset or equal B</MATH>),
then the empty sequence will be returned.
If <MATH>A \cap B = B</MATH> (i.e. <MATH>B subset or equal A</MATH>, that means <MATH>B</MATH> is a
hole of <MATH>A</MATH>),
then a sequence containing (two) objects <MATH>(A,B)</MATH> of type
<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> will be returned, where the second one
represents a hole and has clockwise order.
</DL><P>

<H3>Parameters</H3>The boolean operations described in the following have one or more
template parameters. The number of template parameters as well as the
type of template parameters differs for the different operations.
Here we give a list of all template parameters which might occur
and some explanation of where they stand for.<P>

<BR><STRONG><I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A></I></STRONG><P>

A value for the template parameter <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A></I> is a
boolean operations traits class. We provide a standard boolean
operations traits class for convenience to the user, but the user
can define ones own traits class as well. For more details about
boolean operations traits classes look at the table in the following paragraph
on Types, and in the section on the standard traits class
(<A HREF="CGAL_bops_traits_2.html#B_ops_Predef"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>).<P>

<BR><STRONG><I>R</I></STRONG><P>

This template parameter defines the representation class[<A HREF="#Footnote_1">^1</A>].
Common examples of <I>R</I> are:
<I>CGAL_Cartesian&lt;double&gt;</I>,
<I>CGAL_Homogeneous&lt;float&gt;</I>, or
<I>CGAL_Cartesian&lt;CGAL_Rational&gt;</I>.<P>

<BR><STRONG><I>Container</I></STRONG><P>

The container type <I>Container</I> for a polygon.
The user must pre-instantiate this for instance by
<I>list&lt;CGAL_Point_2&lt;CGAL_Cartesian&lt;CGAL_Rational&gt; &gt; &gt;</I>.<P>

<BR><STRONG><I>OutputIterator</I></STRONG><P>

The type of the iterator pointing to the container in which the output
is stored: <I>OutputIterator</I>. The user must
pre-instantiate this for instance by
<I>list&lt;Object&gt;::const_iterator</I>.<P>

<BR><STRONG><I>ForwardIterator</I></STRONG><P>

The type of the iterator pointing to the container in which the
input is stored: <I>ForwardIterator</I>. The user must
pre-instantiate this for instance by
<I>list&lt;Point&gt;::const_iterator</I>.<P>

In the table below we describe the types which are defined in a
boolean operations treats class. Such a traits class contains the most
important type definitions used in the algorithms. These types can be
changed by the user, if needed. In the first column of the table the
types present in a boolean operations treats class are listed. In the
second column a brief description of the respective types is given,
and in the third column the default value for each of the types in
given as they are defined in the standard boolean operations treats class.
For more details on the standard boolean operations treats class we
refer to Section <A HREF="CGAL_bops_traits_2.html#B_ops_Predef"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.
\begincenter<P>

<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP> \hline
type </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> description </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> standard </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline \hline<P>

<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D point </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I>CGAL_Point_2&lt;R&gt; &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Segment</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D segment </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I>CGAL_Segment_2&lt;R&gt; &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Triangle</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D triangle </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I>CGAL_Triangle_2&lt;R &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Iso_rectangle</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D iso-oriented rectangle </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I>CGAL_Iso_rectangle_2&lt;R &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Container</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> container type for polygon </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I>list&lt;CGAL_Point_2&lt;R&gt; &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D polygon </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>, Container &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
</TD></TR></TABLE>
\endcenter<P>

<H3>Operations</H3><P>

<H3>Operations on 2D Iso rectangles</H3><P>

<I>#include &lt;CGAL/bops_Iso_rectangle_2.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_CGAL_do_intersect6const_CGAL_Iso_rectangle_26R9__A+_const_CGAL_Iso_rectangle_26R9__B9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the iso-oriented rectangles <MATH>A</MATH>
    and <MATH>B</MATH> do intersect.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_intersection6const__CGAL_Iso_rectangle_26R9__A+_const_CGAL_Iso_rectangle_26R9__B+__OutputIterator_object_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B, <BR>
     OutputIterator object_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the intersection of two iso-oriented rectangles and places
    the resulting object of type <I>CGAL_Object</I> in a container of
    the type corresponding to the output iterator (
    <I>OutputIterator</I>) <I>object_it</I> which points to the
    resulting object. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the container. Each object part of the output is either a point (
    <I>CGAL_Point_2</I>), or a segment (<I>CGAL_Segment_2</I>), or an
    iso-oriented rectangle (<I>CGAL_Iso_rectangle_2</I>). In case of an
    empty intersection no objects are put into the output operator.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_union6const_CGAL_Iso_rectangle_26R9___A+_const_CGAL_Iso_rectangle_26R9__B+_OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the union of two iso-oriented rectangles and places all
    resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of type corresponding to the type
    of output iterator (<I>OutputIterator</I>)
    <I>list_of_objects_it</I> which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. The sequence may contain an iso-oriented rectangle (
    <I>CGAL_Iso_rectangle_2</I>), or a simple polygon (
    <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>), or two iso-oriented rectangles (
    <I>CGAL_Iso_rectangle_2</I>, in case <MATH>A \cap B</MATH> is
    empty).
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_difference6const_CGAL_Iso_rectangle_26R9__A+_const_CGAL_Iso_rectangle_26R9__B+__OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the difference (<MATH>A \ B</MATH>) of two iso-oriented
    rectangles and places the resulting objects as <I>CGAL_Object</I>
    in a container of type corresponding to the type of output iterator
    (<I>OutputIterator</I>) <I>list_of_objects_it</I> which points to
    the first object in the sequence. The function returns an output
    iterator (<I>OutputIterator</I>) pointing to the position beyond
    the end of the sequence. Each object is either a simple polygon (
    <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>)</I> or an iso-oriented rectangle (
    <I>CGAL_Iso_rectangle_2</I>). If <MATH>B subset or equal A</MATH>
    no object will be put into the output iterator.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Operations on 2D Triangles</H3><P>

<I>#include &lt;CGAL/bops_Triangle_2.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_CGAL_do_intersect6__const_CGAL_Triangle_26R9__A+__const_CGAL_Triangle_26R9__B9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the triangles <MATH>A</MATH> and
    <MATH>B</MATH> do intersect.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_intersection6_const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B+__OutputIterator_object_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B, <BR>
     OutputIterator object_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the intersection of two triangles and places the resulting
    object of type <I>CGAL_Object</I> in a container of the type
    corresponding to the output iterator (<I>OutputIterator</I>)
    <I>object_it</I> which points to the resulting object. The function
    returns an output iterator (<I>OutputIterator</I>) pointing to the
    position beyond the end of the container. The resulting object is
    either a point (<I>CGAL_Point_2</I>), or a segment (
    <I>CGAL_Segment_2</I>), or a triangle (<I>CGAL_Triangle_2</I>), or
    a convex polygon (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> with
    <I>is_convex() == true</I>). In case of an empty intersection no
    object is put into the output operator.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_union6const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B+_OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the union of two triangles and places all resulting
    objects as a sequence of objects of type <I>CGAL_Object</I> in a
    container of type corresponding to the type of output iterator (
    <I>OutputIterator</I>) <I>list_of_objects_it</I> which points to
    the first object in the sequence. The function returns an output
    iterator (<I>OutputIterator</I>) pointing to the position beyond
    the end of the sequence. The sequence may contain a triangle (
    <I>CGAL_Triangle_2</I>), or a simple polygon (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>
    ), or two triangles (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>, in case
    <MATH>A \cap B</MATH> is empty).
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_difference6const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B+__OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Computes the difference (<MATH>A \ B</MATH>) of two triangles and
    places all resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of type corresponding to the type
    of output iterator (<I>OutputIterator</I>)
    <I>list_of_objects_it</I> which points to the first object in the
    sequence. It returns an output iterator (<I>OutputIterator</I>)
    pointing to position beyond the end of the sequence. Each object in
    the sequence is either a triangle (<I>CGAL_Triangle_2</I>), or a
    simple polygon (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>). If
    <MATH>B subset or equal A</MATH> no object will be put into the
    output iterator.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Operations on 2D Polygons</H3><P>

<I>#include &lt;CGAL/bops_Polygon_2.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class Container&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_CGAL_do_intersect6__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__A+__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__B9;_"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; B)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the polygons <MATH>A</MATH> and
    <MATH>B</MATH> do intersect.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class Container, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_intersection6__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__A+__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__B+___OutputIterator_list_of_objects_it9;_"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the intersection of two simple polygons and places all
    resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of type corresponding to the type
    of output iterator (<I>OutputIterator</I>)
    <I>list_of_objects_it</I> which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. In case of an empty intersection no objects are put
    into the output operator.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class Container, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_union6__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__A+__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__B+__OutputIterator_list_of_objects_it9;_"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the union of two simple polygons and places all resulting
    objects as a sequence of objects of type <I>CGAL_Object</I> in a
    container of type corresponding to the type of output iterator (
    <I>OutputIterator</I>) <I>list_of_objects_it</I> which points to
    the first object in the sequence. The function returns an output
    iterator (<I>OutputIterator</I>) pointing to the position beyond
    the end of the sequence.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class R, class Container, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_difference6__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__A+__const_CGAL_Polygon_26CGAL_Polygon_traits_26R9+Container9__B+___OutputIterator_list_of_objects_it9;_"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A>,Container&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the difference of two simple polygons (<MATH>A \ B</MATH>)
    and places the resulting object as <I>CGAL_Object</I> in a
    container of type corresponding to the type of output iterator (
    <I>OutputIterator</I>) <I>list_of_objects_it</I> which points to
    the first object in the sequence. The function returns an output
    iterator (<I>OutputIterator</I>) pointing to the position beyond
    the end of the sequence. The difference can be empty in which case
    no object will be put in the output iterator.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Operations on 2D Polygons defined by containers</H3><P>

<I>#include &lt;CGAL/bops_Container_Polygon_2.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class ForwardIterator, class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_CGAL_do_intersect6_ForwardIterator_Afirst+_ForwardIterator_Alast+__ForwardIterator_Bfirst+_ForwardIterator_Blast+__Traits__9;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    ForwardIterator Afirst, <BR>
     ForwardIterator Alast, <BR>
     ForwardIterator Bfirst, <BR>
     ForwardIterator Blast, <BR>
     <A HREF="Traits.html#Cross_link_anchor_1">Traits</A> &amp;)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>

with polygon <I>A</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range
<MATH>[Afirst,Alast)</MATH>
and for polygon <I>B</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>.
It returns <I>true</I> if the polygons <MATH>A</MATH> and <MATH>B</MATH> do intersect.
<BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and <MATH>B</MATH> simple polygons, their vertices are in
counterclockwise order.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class ForwardIterator, class OutputIterator, class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_intersection6_ForwardIterator_Afirst+_ForwardIterator_Alast+__ForwardIterator_Bfirst+_ForwardIterator_Blast+__Traits__+___OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    ForwardIterator Afirst, <BR>
     ForwardIterator Alast, <BR>
     ForwardIterator Bfirst, <BR>
     ForwardIterator Blast, <BR>
     <A HREF="Traits.html#Cross_link_anchor_1">Traits</A> &amp;, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>

with polygon <I>A</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range
<MATH>[Afirst,Alast)</MATH>
and with polygon <I>B</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>,
computes the intersection of two simple polygons and places all
resulting objects as a sequence of objects of type <I>CGAL_Object</I>
in a container of type corresponding to the type of
output iterator (<I>OutputIterator</I>)
<I>list_of_objects_it</I> which points to the first object in the
sequence.
The function returns an output iterator (<I>OutputIterator</I>)
pointing to the position beyond the end of the sequence.
In case of an
empty intersection no objects are put into the output operator.
If an object in the sequence to which the output iterator refers is a
polygon, then this polygon is of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> with
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> and container
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Container</I>.
<BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and <MATH>B</MATH> simple polygons, their vertices are in
counterclockwise order.
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class ForwardIterator, class OutputIterator, class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_union6ForwardIterator_Afirst+_ForwardIterator_Alast+__ForwardIterator_Bfirst+_ForwardIterator_Blast+___Traits__+___OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    ForwardIterator Afirst, <BR>
     ForwardIterator Alast, <BR>
     ForwardIterator Bfirst, <BR>
     ForwardIterator Blast, <BR>
     <A HREF="Traits.html#Cross_link_anchor_1">Traits</A> &amp;, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>

with polygon <I>A</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range
<MATH>[Afirst,Alast)</MATH>
and with polygon <I>B</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>.
Computes the union of two simple polygons (<MATH>A \cup B</MATH>) and places all
resulting objects as a sequence of objects of type <I>CGAL_Object</I>
in a container of type corresponding to the type of
output iterator (<I>OutputIterator</I>)
<I>list_of_objects_it</I> which points to the first object in the
sequence.
It returns an output iterator (<I>OutputIterator</I>)
pointing to position beyond the end of the sequence.
If an object in the sequence to which the output iterator refers is a
polygon, then this polygon is of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> with
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> and container
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Container</I>.
<BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and <MATH>B</MATH> simple polygons, their vertices are in
counterclockwise order.
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class ForwardIterator, class OutputIterator, class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_difference6ForwardIterator_Afirst+_ForwardIterator_Alast+__ForwardIterator_Bfirst+_ForwardIterator_Blast+___Traits__+___OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    ForwardIterator Afirst, <BR>
     ForwardIterator Alast, <BR>
     ForwardIterator Bfirst, <BR>
     ForwardIterator Blast, <BR>
     <A HREF="Traits.html#Cross_link_anchor_1">Traits</A> &amp;, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>

with polygon <I>A</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range
<MATH>[Afirst,Alast)</MATH>
and with polygon <I>B</I> of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> defined by the
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>,
computes the difference of two simple polygons (<MATH>A \ B</MATH>) and places
all resulting objects of type <I>CGAL_Object</I> in a container of
type corresponding to the type of
output iterator (<I>OutputIterator</I>) <I>list_of_objects_it</I>
which points to the first object in the
sequence.
The function returns an output iterator (<I>OutputIterator</I>)
pointing to the position beyond the end of the sequence.
The difference can be empty in which case no object will be put
in the output iterator.
If an object in the sequence to which the output iterator refers is a
polygon, then this polygon is of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon</I> with
vertices of type <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> and container
<I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Container</I>.
<BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and <MATH>B</MATH> simple polygons, their vertices are in
counterclockwise order.
<P>

<H3>Example</H3>Principally, Boolean operations work as follows, illustrated by the example
of intersecting two polygons:
<OL><P>

<LI>To use the predefined boolean operations traits class
<I><A HREF="CGAL_bops_traits_2.html#Cross_link_anchor_0">CGAL_bops_traits_2&lt;R&gt;</A></I>,
include the file <I>bops_traits_2.h</I>.
For details see Section <A HREF="CGAL_bops_traits_2.html#B_ops_Predef"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.<P>

<LI>Instantiation of two polygons that can be triangles,
iso oriented rectangles, or simple polygons.
A polygon can be represented as an object (e.g. <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>)
or as a sequence of points held
in a sequence container (e.g. <EM>STL</EM>-list).<P>

<LI>Performing the boolean operation:<P>

<PRE>
  CGAL_intersection(A.begin(), A.end(), B.begin(), B.end(), traits, result);
  CGAL_intersection(A, B, result);
</PRE><P>

<LI>Taking the result of the operation:<P>

The result consists of a sequence of points, segments, and simple
polygons. Hence,
the user has to check what type of element has to be performed for further
computations.<P>

</OL><P>

The full example (depicted in figure <A HREF="Chapter_main.html#fig-example-1"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>)
instantiates two simple polygons and computes their intersection.
Note: here the non-exact (builtin) number type <I>float</I> is used.<P>

\beginfigure[th]
\begincenter
\includegraphicsb-ops-2D-example-1.eps
\captionIntersection example of two simple polygons
(in cartesian coordinates).
<A NAME="fig-example-1"></A>
\endcenter
\endfigure<P>

<PRE>
#include &lt;CGAL/Homogeneous.h&gt;
#include &lt;CGAL/Cartesian.h&gt;
#include &lt;CGAL/basic.h&gt;
#include &lt;iostream.h&gt;
#include &lt;CGAL/bops_Polygon_2.h&gt;

typedef float TestNum;

#ifdef USE_CARTESIAN_COORDINATES
      typedef CGAL_Cartesian&lt;TestNum&gt;        R_type;
#else
      typedef CGAL_Homogeneous&lt;TestNum&gt;      R_type;
#endif

typedef CGAL_Point_2&lt;R_type&gt;                 Point_2;
typedef CGAL_Segment_2&lt;R_type&gt;               Segment_2;

typedef list&lt; Point_2 &gt;                      Container;
typedef <A HREF="../Polygon/CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R_type&gt;</A>        Polygon_traits_2;
typedef <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt; Polygon_traits_2, Container &gt;  Polygon_2;
typedef vector&lt;Point_2&gt;                      Input_container;


int example_intersection(
  const Input_container&amp; container_A,
  const Input_container&amp; container_B
) {
  /* instantiate Polygon A and B with containers */
  Polygon_2 A(container_A.begin(), container_A.end());
  Polygon_2 B(container_B.begin(), container_B.end());

  /* declaration of the result container */
  list&lt;CGAL_Object&gt; result;

  /* performing intersection of A and B */
  CGAL_intersection(A, B, back_inserter(result));
  
  cout &lt;&lt; &quot;result size=&quot; &lt;&lt; result.size() &lt;&lt; endl;

  /* possible results */
  Point_2   point;
  Segment_2 segment;
  Polygon_2 polygon;

  list&lt;CGAL_Object&gt;::const_iterator it;
  for( it= result.begin(); it != result.end(); it++) {
    if( CGAL_assign( polygon, *it) ) {
      cout &lt;&lt; &quot;PGN: &quot; &lt;&lt; polygon &lt;&lt; endl;    /* polygon detected */
    }
    else if( CGAL_assign( segment, *it) ) {
      cout &lt;&lt; &quot;SEG: &quot; &lt;&lt; segment &lt;&lt; endl;    /* segment detected */
    }
    else if( CGAL_assign( point, *it) )  {  
      cout &lt;&lt; &quot;PNT:&quot; &lt;&lt; point &lt;&lt; endl;       /* point detected */
    }
    else {
      cout &lt;&lt; &quot;undefined object &quot; &lt;&lt; endl;   /* nothing detected */
    }
  }
  
  return result.size();
}



int main(void)
{
  Input_container container_A(6), container_B(4);

  container_A[0]= Point_2(2,4); /* description of polygon A */
  container_A[1]= Point_2(0,3);
  container_A[2]= Point_2(1,1);
  container_A[3]= Point_2(2,3);
  container_A[4]= Point_2(3,1);
  container_A[5]= Point_2(4,3);

  container_B[0]= Point_2(0,2); /* description of polygon B */
  container_B[1]= Point_2(0,0);
  container_B[2]= Point_2(5,0);
  container_B[3]= Point_2(5,2);

  example_intersection( container_A, container_B);
  return 0;
}
</PRE><P>

The output of our small example program looks like as follows:<P>

<PRE>
result size=2
PGN: 3 1 1 1 15 20 10 5 20 10 
PGN: 3 25 20 10 3 1 1 35 20 10 
</PRE><P>

Its interpretation says that the result consists of two polygons
with size three (i.e. two triangles)
given by their vertices in homogeneous coordinates and counterclockwise order:
((1,1,1), (15,20,10), (5,20,10)) and ((25,20,10),(3,1,1),(35,20,10)).<P>

From this (full) example can be seen how a boolean operation
could be applied in a safe and practical way.
The following sketch of a more advanced example shows how traits classes
can be used for performing boolean operations.<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR><P>

<PRE>

#include &lt;CGAL/bops_traits_2.h&gt;
#include &lt;CGAL/bops_Polygon_2_container.h&gt;

typedef CGAL_Cartesian&lt;double&gt; R;
typedef <A HREF="CGAL_bops_traits_2.html#Cross_link_anchor_0">CGAL_bops_traits_2&lt;R&gt;</A> <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>;
typedef <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Polygon Polygon;
typedef <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Output_object_container Output_container;

void myFunction() {
  Polygon polygon;
  <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>  traits_class;

  polygon A, B; /* instantiate A and B */
  /* ... */

  Output_container result; 

  /* apply a boolean operation: */
  CGAL_intersection(A.begin(), A.end(), B.begin(), B.end(),
                    traits_class, back_inserter(result));

  /* do something with the result: */
  /* ... */

}
</PRE><P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR><P>

<H3>Implementation</H3>The algorithms for boolean operations of two polygons are (efficient)
specialized methods for specific objects.
Depending on the polygon type we switch internally to the best suited
routines. For instance, for two triangles we switch to a more
efficient algorithm than the general one on polygons.<P>

The memory consumption is <MATH>O(n)</MATH>
(where <MATH>n</MATH> is the whole number of vertices of the input polygons).
The time complexity is <MATH>O(n<SUP>2</SUP>)</MATH> for simple polygons,
and <MATH>O(1)</MATH> for triangles and iso-oriented rectangles.<P>

Note: As mentioned above,
the result is sometimes returned as iterators pointing to
a <I>list&lt;CGAL_Object&gt;</I>, where <I>list</I> is
a <EM>STL list container</EM>, which implements a double
connected list (include file: <I>list.h</I>).<P>

<H3>See Also</H3><I>CGAL_Intersection</I>, <I>CGAL_Polygon</I>, <I>CGAL_Triangle</I>, and
<I>CGAL_Iso_rectangle</I>.<P>

<P><A NAME="Section_3"></A>
<H2>Boolean Operations <A HREF="Traits.html#Cross_link_anchor_1">Traits</A> Class Implementations</H2>
<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_bops_traits_2.html"><I>CGAL_bops_traits_2&lt;R&gt;</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="Traits.html"><I>Traits&lt;R&gt;</I></A>.</UL>

<P>



<P><HR><H3>Footnotes</H3><P>

<OL>
<LI><A NAME="Footnote_1">A detailed description of the representation class can be found in Part 1 of the CGAL-Reference Manual
</OL>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
