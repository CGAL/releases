<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_triangulation.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: Face</TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_triangulation.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_7"></A>

<A NAME="Cross_link_anchor_7"></A>
<H3>Requirements for a Triangulation <A HREF="Face.html#Cross_link_anchor_7">Face</A> <A NAME="I1_SectFaceReq"></A></H3>

<P>

<H3>Definition</H3>A class must fulfill the following requirements in
order that it can be used as a face of a triangulation.
<P>

A face contains pointers to three vertices whose order defines the
counterclockwise order. It further contains three pointers to neighbor
faces.
<P>

The vertices and neighbors are indexed 0,1, and 2. Neighbor
<MATH>i</MATH> lies opposite to vertex i.
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_handle"></A>
<A HREF="Face.html#Cross_link_anchor_7">Face</A>::Vertex_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Handle to vertex type.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Face_handle"></A>
<A HREF="Face.html#Cross_link_anchor_7">Face</A>::Face_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Handle to face type.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3> Creation</H3>
<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

For user defined triangulation algorithms, faces need to be explicitly
constructed and linked to their neighbors.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Face.html#Cross_link_anchor_7">Face</A> f;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a variable <I>f</I> and initializes all vertices and
    neighbors with <I>NULL</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Face.html#Cross_link_anchor_7">Face</A> f ( Vertex_handle v0,  Vertex_handle v1,  Vertex_handle v2);
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a variable <I>f</I>, and initializes the vertices. The
    neighbors are initialized with <I>NULL</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Face.html#Cross_link_anchor_7">Face</A> f ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_handle v0, <BR>
     Vertex_handle v1, <BR>
     Vertex_handle v2, <BR>
     Face_handle n0, <BR>
     Face_handle n1, <BR>
     Face_handle n2);</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a variable <I>f</I>, and initializes the vertices and
    the neighbors.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>

<H3> Setting</H3>
<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.set_vertex ( int i,  Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Set vertex <I>i</I> to be <I>v</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.set_neighbor ( int i,  Face_handle n)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Set neighbor <I>i</I> to be <I>n</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>

<H3> <A HREF="Vertex.html#Cross_link_anchor_6">Vertex</A> Access Functions</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    f.vertex ( int i)
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the vertex <I>i</I> of <I>f</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.index ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the index of vertex <I>v</I> in <I>f</I>.
    <BR><STRONG>Precondition: </STRONG><I>v</I> is a vertex of <I>f</I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.has_vertex ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>true</I> if <I>v</I> is a vertex of <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.has_vertex ( Vertex_handle v,  int&amp; i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>true</I> if <I>v</I> is a vertex of <I>f</I>, and
    computes the index <I>i</I> of the vertex.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Neighbor Access Functions</H3>
<P>

The neighbor with index <I>i</I> is the neighbor which is opposite to
the vertex with index <I>i</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Face_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.neighbor ( int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the neighbor <I>i</I> of <I>f</I>. The result can be
    <I>NULL</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.index ( Face_handle n)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the index of face <I>n</I>.
    <BR><STRONG>Precondition: </STRONG><I>n</I> is a neighbor of
    <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.has_neighbor ( Face_handle n)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>true</I> if <I>n</I> is a neighbor of <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.has_neighbor ( Face_handle n,  int&amp; i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>true</I> if <I>n</I> is a neighbor of <I>f</I>, and
    compute the index <I>i</I> of the neighbor.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Miscellaneous</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    f.ccw ( int i)
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <MATH>i+1</MATH> modulo
    3.<BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    f.cw ( int i)
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <MATH>i+2</MATH> modulo
    3.<BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Face_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    f.handle ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a handle to the face.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    f.insert ( Vertex_handle v)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Splits <I>f</I> in three faces, by modifying <I>f</I> and by
    creating two new faces. <A HREF="Vertex.html#Cross_link_anchor_6">Vertex</A> <I>v</I> becomes vertex 0 of
    <I>f</I>.
        </TD></TR>
        </TABLE><!3>

<P>


<img border=0 src=Three.gif align=center alt="Insertion">

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

It is in your responsibility to keep a triangulation valid, if you use
the advanced operations. Obviously you have to make a triangulation
invalid at times in order to implement higher level algorithms. To help
you in the development of new triangulation classes, CGAL provides a
predicate to verify the validity of the constructed structure. This
function serves mainly for debugging.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    f.is_valid ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>true</I> if the triangle shares two vertices with its
    neighbors, and these neighbors have a correct reciprocal
    neighboring link and coherent orientations. It further checks if
    <I>f</I> is in the adjacency list of each of its three vertices,
    and if the vertices point to the right face if they are on the
    boundary.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>
<HR> <B>Next:</B>  Class declaration of <A HREF="CGAL_Triangulation_vertex.html"><I>CGAL_Triangulation_vertex&lt;P&gt;</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_triangulation.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
