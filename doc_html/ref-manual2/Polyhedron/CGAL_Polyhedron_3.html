<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_polyhedron.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: CGAL_Polyhedron_3<Traits,HDS></TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_polyhedron.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_0"></A>

<A NAME="Cross_link_anchor_0"></A>

<P>

<H1> Polyhedral Surfaces (<I><A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A></I>)</H1>
<P>

<A NAME="sectionPolyhedron"></A>
<P>

<H3>Definition</H3>A polyhedral surface
<I><A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;</I> in three dimensions consists
of vertices <MATH>V</MATH>, edges <MATH>E</MATH>, facets <MATH>F</MATH>
and an incidence relation on them. Each edge is represented by two
halfedges with opposite orientations.
<P>


    <CENTER>
    <A HREF="./halfedge.gif">
        <img src="./halfedge_small.gif" alt="Halfedge Diagram"></A><P>
    </CENTER>

<P>

Vertices represent points in space. Edges are straight line segments
between two endpoints. Facets are planar polygons without holes defined
by the circular sequence of halfedges along their boundary. The
polyhedral surface itself is allowed to have holes. The halfedges along
the boundary of a hole are called <EM>border halfedges</EM> and have no
incident facets. An edge is a <EM>border edge</EM> if one of its
halfedges is a border halfedge. A surface is <EM>closed</EM> if it
contains no border halfedges. A closed surface is a boundary
representation for polyhedrons in three dimensions. The convention is
that the halfedges are oriented counterclockwise around facets as seen
from the outside of the polyhedron. An implication is that the
halfedges are oriented clockwise around the vertices. The notion of the
solid side of a facet as defined by the halfedge orientation extends to
polyhedral surfaces with border edges although they do not define a
closed object. If normal vectors are considered for the facets, normals
point outwards (following the right hand rule).
<P>

One implication of the definition is that the polyhedral surface is
always an orientable and oriented 2-manifold with border edges, i.e.
the neighborhood of each point on the polyhedral surface is either
homeomorphic to a disc or to a half disc, except for vertices where
many holes and surfaces can join. Another implication is that the
smallest representable surface is a triangle (for polyhedral surfaces
with border edges) or a tetrahedron (for polyhedra). Boundary
representations of orientable 2-manifolds are closed under Euler
operations. They are extended with operations that create or close
holes in the surface.
<P>

Other intersections besides the incidence relation are not allowed,
although they are not automatically handled, since self intersections
are not easy to check efficiently.
<I><A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;</I> does only maintain the
combinatorial integrity of the polyhedral surface (using Euler
operations) and does not consider the coordinates of the points or any
geometric information.
<P>

The class <I><A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;</I> can represent
polyhedral surfaces as well as polyhedrons. The interface is designed
in such a way that it is easy to ignore border edges and work only with
polyhedrons.
<P>

The sequence of edges can be ordered in the data structure on request
such that the sequence starts with the non-border edges and ends with
the border edges. Border edges are then itself ordered such that the
halfedge which is incident to the facet came first and the halfedge
incident to the hole came thereafter. This normalization step counts
simultaneously the number of border edges. This number is zero if and
only if the surface is a closed polyhedron. Note that this class does
not maintain this counter during further modifications. There is no
automatic caching done for auxiliary information.
<P>

The class <I><A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;</I> expects a model of
the <I><A HREF="Polyhedron_traits.html#Cross_link_anchor_4">Polyhedron_traits</A></I> concept from
Section&nbsp;<A HREF="Polyhedron_traits.html#sectionPolyTraits"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A> as a first template argument, and
a model of the <I><A HREF="../Halfedge_DS/Halfedge_data_structure.html#Cross_link_anchor_0">Halfedge_data_structure</A></I> concept from
Section&nbsp;<A HREF="../Halfedge_DS/Halfedge_data_structure.html#sectionHds"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A> with the additional requirements from
Section&nbsp;<A HREF="Chapter_polyhedron.html#sectionPolyHds"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A> as a second template argument
<P>

<I>#include &lt;CGAL/Polyhedron_3.h&gt;</I>
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Traits"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    traits class.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Halfedge_data_structure"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::<A HREF="../Halfedge_DS/Halfedge_data_structure.html#Cross_link_anchor_0">Halfedge_data_structure</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    halfedge data structure <I>HDS</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::<A HREF="Vertex.html#Cross_link_anchor_1">Vertex</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    vertex type.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Halfedge"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::<A HREF="Halfedge.html#Cross_link_anchor_2">Halfedge</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    halfedge type.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Facet"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::<A HREF="Facet.html#Cross_link_anchor_3">Facet</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    facet type.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Size"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Size
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    type for size values.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Difference"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Difference
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    type for difference values.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

Types for the (optionally) associated geometry. If the specific item is
not supported the type is <I>void*</I>.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Point"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Point
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    point stored in vertices.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Plane"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Plane
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    plane equation stored in facets.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Normal"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Normal
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    normal vector stored in facets.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

The following handles, iterators and circulators have appropriate
non-mutable counterparts. The mutable types are assignable to their
non-mutable counterparts. Both circulators are assignable to the
<I>Halfedge_iterator</I>. The iterators are assignable to the
respective handle types. Wherever the handles appear in function
parameter lists, the appropriate iterator can be used as well.
<P>

The iterator category is defined through the polyhedron traits class
for all iterators. The circulators are bidirectional if the halfedge in
the polyhedron traits class provides a member function <I>prev()</I>,
otherwise they are of the forward category.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_handle"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Vertex_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    handle to vertex.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Halfedge_handle"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Halfedge_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    handle to halfedge.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Facet_handle"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Facet_handle
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    handle to facet.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_iterator"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Vertex_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over all vertices.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Halfedge_iterator"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Halfedge_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over all halfedges.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Facet_iterator"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Facet_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator over all facets.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Halfedge_around_vertex_circulator"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Halfedge_around_vertex_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    circulator of halfedges around a vertex.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Halfedge_around_facet_circulator"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Halfedge_around_facet_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    circulator of halfedges around a facet.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_iterator_category"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::iterator_category
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    iterator category of all the iterators.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_circulator_category"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::circulator_category
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    circulator category of all the circulators.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt; P (  <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());
        </I></NOBR>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt; P ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Size v, <BR>
     Size h, <BR>
     Size f, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    a polyhedron <I>P</I> with storage reserved for <MATH>v</MATH>
    vertices, <MATH>h</MATH> halfedges, and <MATH>f</MATH> facets. The
    reservation sizes are a hint for optimizing storage allocation.
    <P>
        </TD></TR>
        </TABLE><!2>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.reserve ( Size v,  Size h,  Size f)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    reserve storage for <MATH>v</MATH> vertices, <MATH>h</MATH>
    halfedges, and <MATH>f</MATH> facets. The reservation sizes are a
    hint for optimizing storage allocation. If the <I>capacity</I> is
    already greater than the requested size nothing happens. If the
    <I>capacity</I> changes all iterators and circulators might
    invalidate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.make_tetrahedron ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    a tetrahedron is added to the polyhedral surface. Returns an
    arbitrary halfedge of the tetrahedron.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    P.make_tetrahedron ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p1, <BR>
     Point p2, <BR>
     Point p3, <BR>
     Point p4)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    a tetrahedron is added to the polyhedral surface with its vertices
    initialized with
    <MATH>p<SUB>1</SUB>, p<SUB>2</SUB>, p<SUB>3</SUB></MATH> and
    <MATH>p<SUB>4</SUB></MATH>. Returns that halfedge of the
    tetrahedron which incident vertex is initialized with
    <MATH>p<SUB>1</SUB></MATH>, the incident vertex of the next
    halfedge with <MATH>p<SUB>2</SUB></MATH>, and the vertex thereafter
    with <MATH>p<SUB>3</SUB></MATH>. The remaining fourth vertex is
    initialized with <MATH>p<SUB>4</SUB></MATH>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.make_triangle ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    a triangle with border edges is added to the polyhedral surface.
    Returns an arbitrary, non-border halfedge of the triangle.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.make_triangle (  Point p1,  Point p2,  Point p3)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    a triangle with border edges is added to the polyhedral surface
    with its vertices initialized with
    <MATH>p<SUB>1</SUB>, p<SUB>2</SUB></MATH> and
    <MATH>p<SUB>3</SUB></MATH>. Returns that non-border halfedge of the
    triangle which incident vertex is initialized with
    <MATH>p<SUB>1</SUB></MATH>, the incident vertex of the next
    halfedge with <MATH>p<SUB>2</SUB></MATH>, and the vertex thereafter
    with <MATH>p<SUB>3</SUB></MATH>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Access Member Functions</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.size_of_vertices ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    number of vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.size_of_halfedges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    number of halfedges (incl. border halfedges).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.size_of_facets ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    number of facets.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.capacity_of_vertices ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    space reserved for vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.capacity_of_halfedges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    space reserved for halfedges.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.capacity_of_facets ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    space reserved for facets.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    size_t
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.bytes ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    bytes used for the polyhedron.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    size_t
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.bytes_reserved ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    bytes reserved for the polyhedron.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over all vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.vertices_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    past-the-end iterator and null-handle.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.halfedges_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over all halfedges.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.halfedges_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    past-the-end iterator and null-handle.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Facet_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.facets_begin ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    iterator over all facets (excluding holes).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Facet_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.facets_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    past-the-end iterator and null-handle.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.traits ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the traits class.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Geometric Predicates</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.is_triangle ( Halfedge_const_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I> iff the connected component denoted by <MATH>h</MATH>
    is a triangle.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.is_tetrahedron ( Halfedge_const_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <I>true</I> iff the connected component denoted by <MATH>h</MATH>
    is a tetrahedron.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Euler Operators (Combinatorial Modifications)</H3>
<P>

<A NAME="sectionPolyhedronEuler"></A>
<P>

The following Euler operations modify consistently the combinatorial
structure of the polyhedral surface. The geometry remains unchanged.
<P>


    <CENTER>
    <img src="./euler_facet.gif" alt="Euler Operators: split/join_facet()"><P>
    </CENTER>

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.split_facet ( Halfedge_handle h,  Halfedge_handle g)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    split the facet incident to <I>h</I> and <I>g</I> into two facets
    with a new diagonal between the two vertices denoted by <I>h</I>
    and <I>g</I> respectively. The second (new) facet is a copy of the
    first facet. It returns the new diagonal. The time is proportional
    to the distance from <I>h</I> to <I>g</I> around the facet.
    <BR><STRONG>Precondition: </STRONG><I>h</I> and <I>g</I> are
    incident to the same facet. <I>h != g</I> (no loops).
    <I>h-&gt;next() != g</I> and <I>g-&gt;next() != h</I> (no
    multi-edges).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.join_facet ( Halfedge_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    join the two facets incident to <MATH>h</MATH>. The facet incident
    to <I>h-&gt;opposite()</I> gets removed. Both facets might be
    holes. Returns the predecessor of <MATH>h</MATH> around the facet.
    The invariant <I>join_facet( split_facet( h, g))</I> returns
    <MATH>h</MATH> and keeps the polyhedron unchanged. The time is
    proportional to the size of the facet removed and the time to
    compute <I>h-&gt;prev()</I>. <BR><STRONG>Precondition: </STRONG>
    <I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I> supports removal of facets. The degree of both
    vertices incident to <MATH>h</MATH> is at least three (no
    antennas).
        </TD></TR>
        </TABLE><!3>

<P>


    <CENTER>
    <img src="./euler_vertex.gif" alt="Euler Operator: split/join_vertex()"><P>
    </CENTER>

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.split_vertex ( Halfedge_handle h,  Halfedge_handle g)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    split the vertex incident to <I>h</I> and <I>g</I> into two
    vertices and connects them with a new edge. The second (new) vertex
    is a copy of the first vertex. It returns the new edge. The time is
    proportional to the distance from <I>h</I> to <I>g</I> around the
    vertex. <BR><STRONG>Precondition: </STRONG><I>h</I> and <I>g</I>
    are incident to the same vertex. <I>h != g</I> (no antennas).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.join_vertex ( Halfedge_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    join the two vertices incident to <MATH>h</MATH>. The vertex
    denoted by <I>h-&gt;opposite()</I> gets removed. Returns the
    predecessor of <MATH>h</MATH> around the vertex. The invariant
    <I>join_vertex( split_vertex( h, g))</I> returns <MATH>h</MATH> and
    keeps the polyhedron unchanged. The time is proportional to the
    degree of the vertex removed and the time to compute
    <I>h-&gt;prev()</I>. <BR><STRONG>Precondition: </STRONG>
    <I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I> supports removal of vertices. The size of both facets
    incident to <MATH>h</MATH> is at least four (no multi-edges).
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Euler Operators Modifying Genus</H3>
<P>


    <CENTER>
    <img src="./euler_loop.gif" alt="Euler Operator: split/join_loop()"><P>
    </CENTER>

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    P.split_loop ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Halfedge_handle h, <BR>
     Halfedge_handle i, <BR>
     Halfedge_handle j)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    cut the polyhedron into two parts along the cycle
    <MATH>(h,i,j)</MATH>. Three copies of the vertices, three copies of
    the halfedges, and two new triangles will be created.
    <MATH>h,i,j</MATH> will be incident to the first new triangle. The
    return value will be a halfedge iterator denoting the new halfedge
    of the second new triangle which was <I>h-&gt;opposite()</I>
    beforehand. <BR><STRONG>Precondition: </STRONG><MATH>h,i,j</MATH>
    are distinct, consecutive vertices of the polyhedron and form a
    cycle: i.e. <I>h-&gt;vertex() ==  i-&gt;opposite()-&gt;vertex()</I>
    , ..., <I>j-&gt;vertex() ==  h-&gt;opposite()-&gt;vertex()</I>. The
    six facets incident to <MATH>h,i,j</MATH> are all distinct.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.join_loop ( Halfedge_handle h,  Halfedge_handle g)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    glues the boundary of two facets together. Both facets and the
    vertices of the facet loop <MATH>g</MATH> gets removed. Returns
    <MATH>h</MATH>. The invariant
    <I>join_loop( h, split_loop( h, i, j))</I> returns <MATH>h</MATH>
    and keeps the polyhedron unchanged.
    <BR><STRONG>Precondition: </STRONG><I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I> supports removal
    of vertices and facets. The facets denoted by <MATH>h</MATH> and
    <MATH>g</MATH> are different and have an equal degree
    (i.e.&nbsp;number of edges) <MATH>&gt;=3</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Modifying Facets and Holes</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.make_hole ( Halfedge_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    removes the incident facet of <MATH>h</MATH> and changes all
    halfedges incident to the facet into border edges. Returns
    <MATH>h</MATH>. <BR><STRONG>Precondition: </STRONG><I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I>
    supports removal of facets, and <I>! h.is_border()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.fill_hole ( Halfedge_handle h)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    fills a hole with a newly created facet. Makes all border halfedges
    of the hole denoted by <MATH>h</MATH> incident to the new facet.
    Returns <MATH>h</MATH>. <BR><STRONG>Precondition: </STRONG>
    <I>h.is_border()</I>.
        </TD></TR>
        </TABLE><!3>

<P>


    <CENTER>
    <img src="./add_facet1.gif" 
     alt="Modifying Facets and Holes: add_vertex_and_facet_to_border()"><P>
    </CENTER>

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    P.add_vertex_and_facet_to_border ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Halfedge_handle h, <BR>
     Halfedge_handle g)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    creates a new facet within the hole incident to <MATH>h</MATH> and
    <MATH>g</MATH> by connecting the tip of <MATH>g</MATH> with the tip
    of <MATH>h</MATH> with two new halfedges and a new vertex and
    filling this separated part of the hole with a new facet, such that
    the new facet is incident to <MATH>g</MATH>. Returns the halfedge
    of the new edge that is incident to the new facet and the new
    vertex. <BR><STRONG>Precondition: </STRONG><I>h-&gt;is_border()</I>
    , <I>g-&gt;is_border()</I>, <I>h != g</I>, and <MATH>g</MATH> can
    be reached along the same hole starting with <MATH>h</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>


    <CENTER>
    <img src="./add_facet2.gif" 
     alt="Modifying Facets and Holes: add_facet_to_border()"><P>
    </CENTER>

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_handle
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    P.add_facet_to_border ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Halfedge_handle h, <BR>
     Halfedge_handle g)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    creates a new facet within the hole incident to <MATH>h</MATH> and
    <MATH>g</MATH> by connecting the tip of <MATH>g</MATH> with the tip
    of <MATH>h</MATH> with a new halfedge and filling this separated
    part of the hole with a new facet, such that the new facet is
    incident to <MATH>g</MATH>. Returns the halfedge of the new edge
    that is incident to the new facet.
    <BR><STRONG>Precondition: </STRONG><I>h-&gt;is_border()</I>,
    <I>g-&gt;is_border()</I>, <I>h != g</I>, <I>h-&gt;next() != g</I>,
    and <MATH>g</MATH> can be reached along the same hole starting with
    <MATH>h</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Operations with Border Halfedges</H3>
<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

Halfedges incident to an hole are called <EM>border halfedges</EM>. An
halfedge is a <EM>border edge</EM> if itself or its opposite halfedge
are border halfedges. The only requirement to work with border
halfedges is that the <I><A HREF="Halfedge.html#Cross_link_anchor_2">Halfedge</A></I> class provides a member function
<I>is_border()</I> returning a <I>bool</I>. Usually, the halfedge data
structure supports facets and a <I>NULL</I> facet pointer will indicate
a border halfedge, but this is not the only possibility. The
<I>is_border()</I> predicate divides the edges into two classes, the
border edges and the non-border edges. The following normalization
reorganizes the sequential storage of the edges such that the
non-border edges precedes the border edges, and that for each border
edge the latter one of the two halfedges is a border halfedge (the
first one is a non-border halfedge in conformance with the polyhedral
surface definition). The normalization stores the number of border
halfedges and the halfedge iterator the border edges start at within
the data structure. <A HREF="Halfedge.html#Cross_link_anchor_2">Halfedge</A> insertion or removal and changing the
border status of a halfedge may invalidate these values, which are not
automatically updated.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.normalize_border ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sorts halfedges such that the non-border edges precedes the border
    edges. For each border edge the halfedge iterator will reference
    the halfedge incident to the facet right before the halfedge
    incident to the hole.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.size_of_border_halfedges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    number of border halfedges. <BR><STRONG>Precondition: </STRONG>
    <I>normalize_border()</I> has been called and no halfedge insertion
    or removal and no change in border status of the halfedges have
    occurred since then.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Size
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.size_of_border_edges ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    number of border edges. Since each border edge of a polyhedral
    surface has exactly one border halfedge, this number is equal to
    <I>size_of_border_halfedges()</I>.
    <BR><STRONG>Precondition: </STRONG><I>normalize_border()</I> has
    been called and no halfedge insertion or removal and no change in
    border status of the halfedges have occurred since then.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Halfedge_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.border_halfedges_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    halfedge iterator starting with the border edges. The range [
    <I>halfedges_begin(), border_halfedges_begin()</I>) denotes all
    non-border edges. The range [
    <I>border_halfedges_begin(), halfedges_end()</I>) denotes all
    border edges. <BR><STRONG>Precondition: </STRONG>
    <I>normalize_border()</I> has been called and no halfedge insertion
    or removal and no change in border status of the halfedges have
    occurred since then.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>

<H3> Miscellaneous</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    P.inside_out ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    reverse facet orientation (incl. normal or plane equations).
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.delegate ( Modifier_base&lt;HDS&gt;&amp; m)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    calls the <I>operator()</I> of the modifier <MATH>m</MATH>. See
    <I>CGAL_Modifier_base</I> in the Support Library Manual for a
    description of modifier design and its usage.
    <BR><STRONG>Precondition: </STRONG>The polyhedral surface must be
    valid when the modifier returns from execution.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    P.is_valid ( bool verbose = false,  int level = 0)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the polyhedral surface is combinatorially
    consistent. If <I>verbose</I> is <I>true</I>, statistics are
    printed to <I>cerr</I>. For <I>level == 1</I> the normalization of
    the border edges is checked too. This method checks in particular
    level 3 of <I><A HREF="../Halfedge_DS/CGAL_Halfedge_data_structure_decorator.html#Cross_link_anchor_10">CGAL_Halfedge_data_structure_decorator</A>::is_valid</I>
    from Section&nbsp;<A HREF="../Halfedge_DS/CGAL_Halfedge_data_structure_decorator.html#sectionHdsDecorator"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A> and that each facet is
    at least a triangle and that the incident facets of a non-border
    edge are distinct.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    P.normalized_border_is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     _HDS hds, <BR>
     bool verbose = false)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the border halfedges are in normalized
    representation, which is when enumerating all halfedges with the
    iterator: The non-border edges precedes the border edges and for
    border edges, the second halfedge is the border halfedge. The
    halfedge iterator <I>border_halfedges_begin()</I> denotes the first
    border edge. If <I>verbose</I> is <I>true</I>, statistics are
    printed to <I>cerr</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<H3> Types for Tagging Optional Features</H3>
<P>

The following types are equal to either <I>CGAL_Tag_true</I> or
<I>CGAL_Tag_false</I>, depending on whether the named feature is
supported or not.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_vertex_halfedge"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_vertex_halfedge
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Vertex.html#Cross_link_anchor_1">Vertex</A>::halfedge()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_vertex_point"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_vertex_point
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Vertex.html#Cross_link_anchor_1">Vertex</A>::point()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_halfedge_prev"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_halfedge_prev
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Halfedge.html#Cross_link_anchor_2">Halfedge</A>::prev()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_halfedge_vertex"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_halfedge_vertex
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Halfedge.html#Cross_link_anchor_2">Halfedge</A>::vertex()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_halfedge_facet"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_halfedge_facet
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Halfedge.html#Cross_link_anchor_2">Halfedge</A>::facet()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_facet_halfedge"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_facet_halfedge
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Facet.html#Cross_link_anchor_3">Facet</A>::halfedge()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_facet_plane"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_facet_plane
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Facet.html#Cross_link_anchor_3">Facet</A>::plane()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_facet_normal"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_facet_normal
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <I><A HREF="Facet.html#Cross_link_anchor_3">Facet</A>::normal()</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Supports_removal"></A>
<A HREF="CGAL_Polyhedron_3.html#Cross_link_anchor_0">CGAL_Polyhedron_3</A>&lt;<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>,HDS&gt;::Supports_removal
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    supports the removal of individual elements of a surface.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>
<HR> <B>Next:</B>  Class declaration of <A HREF="Vertex.html"><I>Vertex</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_polyhedron.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
