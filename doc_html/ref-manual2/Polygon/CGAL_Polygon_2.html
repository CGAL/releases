<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_polygon.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: CGAL_Polygon_2<Traits,Container></TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_polygon.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_0"></A>

<A NAME="Cross_link_anchor_0"></A>

<P>

<H1> 2D Polygon (<I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>)</H1>
<P>

<H3>Definition</H3>The class <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> represents a simple
polygon in the two-dimensional Euclidean plane
<MATH><B>E</B><SUB>2</SUB></MATH>. A polygon is called <EM>simple</EM>
if there is no pair of nonconsecutive edges sharing a point (see
[<A HREF="../biblio.html#Biblio_ps-cgi-85">PS85</A>]).
<P>

An object <I>p</I> of the data type <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> is defined by
the sequence of its vertices. A simple polygon <I>p</I> is oriented,
i.e., its boundary has clockwise or counterclockwise orientation. The
side to the left of the boundary is called the positive side and the
side to the right of the boundary is called the negative side. As any
Jordan curve, the boundary of a polygon divides the plane into two open
regions, a bounded one and an unbounded one.
<P>

An object <I>p</I> of <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> is a dynamic data
structure, i.e. vertices can be added and removed. These operations may
destroy the simplicity of the polygon, which is a precondition to most
predicates of polygons.
<P>

The data type <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> is parameterized with two template
parameters: a traits class <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A></I> and a container class
<I>Container</I>. The parameter <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A></I> defines the types and
predicates that are used in the polygon class and the polygon
algorithms. For example <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point_2</I> denotes the type of the
vertices of the polygon. A default polygon traits class
<I><A HREF="CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A></I> is provided (see
Section&nbsp;<A HREF="CGAL_Polygon_traits_2.html#sec:poly_default"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>), where <I>R</I> is a
representation class. The parameter <I>Container</I> specifies the type
of container that is used to store the sequence of vertices of the
polygon, e.g. a list, a vector, a tree, etc. The type <I>Container</I>
should fulfill the requirements of a sequence container given in
[<A HREF="../biblio.html#Biblio_ms-strg-96">MS96</A>]. The value
type of the container should be the same as the point type of the
traits class.
<P>

<EM>Note</EM>: Currently, a polygon declaration looks like
<I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, list&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point_2&gt; &gt;</I>. When
nested templates become available this might be simplified to
<I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, list&gt;</I>.
<P>
<H4>Assertions</H4>

<P>

The polygon code uses infix <I>POLYGON</I> in the assertions, e.g.
defining the compiler flag <I>CGAL_POLYGON_NO_PRECONDITIONS</I>
switches precondition checking off, cf.&nbsp;Section&nbsp;2 of the
Reference Manual Part 0, General Introduction.
<P>
<H4>Changes</H4>

<P>

The most important changes with respect to the previous release are:
<P>

<UL> <LI>There is now a proper traits parameter. It is no longer
possible to use the representation class <I>R</I> parameter for the
template parameter <I><A HREF="Traits.html#Cross_link_anchor_1">Traits</A></I>. Instead the default traits class
<I><A HREF="CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A></I> should be used, or when
appropriate a user defined one.
<P>

<LI>The method <I>append</I> is now called <I>push_back</I>. This was
done to support back insert iterators.
<P>

<LI>The <I>transform</I> method has been removed. It is replaced by a
global <I>transform</I> function.
<P>

<LI>Random access methods have been added. These methods are only
available for random access containers.
<P>

<LI>The window stream output operator has been added.
<P>

<LI>A few bugs have been fixed (in the area computation and the
simplicity test). </UL>
<P>

<H3> Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Traits"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    The traits type.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Container"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Container
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    The container type.
    <P>
        </TD></TR>
        </TABLE><!2>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Typedef_FT"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::FT
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    FT;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Typedef_Point_2"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point_2
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Point_2;
        </I></NOBR>
        </TD>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Typedef_Segment_2"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Segment_2
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    Segment_2;
        </I></NOBR>
        </TD>
    
        </TR>
        </TABLE><!3>

<P>

The following types denote iterators that allow to traverse the
vertices and edges of a polygon. Since it is questionable whether a
polygon should be viewed as a circular or as a linear data structure
both circulators and iterators are defined. The circulators and
iterators with `const' in their name are non-mutable, the others are
mutable. The iterator category is in all cases bidirectional, except
for <I>Vertex_iterator</I> and <I>Vertex_const_iterator</I>, which have
the same iterator category as <I>Container::iterator</I>. <B>N.B.</B>
In fact all of them should have the same iterator category as
<I>Container::iterator</I>. However, due to compiler problems this is
currently not possible. This will be corrected when iterator traits
become available. The consequence of using iterators / circulators with
an incorrect iterator category is that when an STL algorithm is applied
to such a range, the wrong (i.e. inefficient) version of an STL
algorithm may be selected.
<P>

For vertices we define
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_iterator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Vertex_iterator
        </I></NOBR>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_const_iterator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Vertex_const_iterator
        </I></NOBR>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_circulator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Vertex_circulator
        </I></NOBR>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Vertex_const_circulator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Vertex_const_circulator
        </I></NOBR>
        </TD></TR>
    
    <P>
        </TABLE><!2>

<P>

Their value type is <I>Point_2</I>.
<P>

For edges we define
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Edge_const_circulator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Edge_const_circulator
        </I></NOBR>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Edge_const_iterator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;::Edge_const_iterator
        </I></NOBR>
        </TD></TR>
    
    <P>
        </TABLE><!2>

<P>

Their value type is <I>Segment_2</I>.
<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    template &lt;class InputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt; p ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     InputIterator last);</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with vertices from the sequence
    defined by the range <I>[first,last)</I>.
    <BR><STRONG>Precondition: </STRONG>The value type of points in the
    range <I>[first,last)</I> is <I>Point_2</I>.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3> Operations</H3>
<P>

The following operations allow to modify a polygon.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.insert ( Vertex_iterator i,  Point_2 q)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the vertex <I>q</I> before <I>i</I>. The return value
    points to the inserted vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    p.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_iterator i, <BR>
     InputIterator first, <BR>
     InputIterator last)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the vertices in the range <I>[first, last)</I> before
    <I>i</I>. <BR><STRONG>Precondition: </STRONG>The value type of
    points in the range <I>[first,last)</I> is <I>Point_2</I>. Note:
    this method is only available if the compiler supports member
    templates.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.push_back (  Point_2 q)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Has the same semantics as <I>p.insert(p.vertices_end(), q)</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.erase ( Vertex_iterator i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Erases the vertex pointed to by <I>i</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.erase ( Vertex_iterator first,  Vertex_iterator last)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Erases the vertices in the range <I>[first, last)</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.reverse_orientation ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Reverses the orientation of the polygon. The vertex pointed to by
    <I>p.vertices_begin()</I> remains the same.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Traversal of a polygon</H3>
<P>

The following methods of the class <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> return
circulators and iterators that allow to traverse the vertices and
edges.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a mutable iterator that allows to traverse the vertices of
    the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.vertices_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Vertex_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.vertices_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable iterator that allows to traverse the vertices
    of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Vertex_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.vertices_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_circulator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.vertices_circulator ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a mutable circulator that allows to traverse the vertices
    of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Vertex_const_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.vertices_circulator ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable circulator that allows to traverse the
    vertices of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Edge_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.edges_begin ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable iterator that allows to traverse the edges of
    the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Edge_const_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.edges_end ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Edge_const_circulator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.edges_circulator ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable circulator that allows to traverse the edges
    of the polygon <I>p</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Predicates</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.is_simple ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns whether <I>p</I> is a simple polygon.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.is_convex ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns whether <I>p</I> is convex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    CGAL_Orientation
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.orientation ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the orientation of <I>p</I>. If the number of vertices
    <MATH></MATH><I>p.size()</I><MATH> &lt; 3</MATH> then
    <I>CGAL_COLLINEAR</I> is returned.
    <BR><STRONG>Precondition: </STRONG><I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    CGAL_Oriented_side
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.oriented_side (  Point_2 q)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>CGAL_POSITIVE_SIDE</I>, <I>CGAL_NEGATIVE_SIDE</I>, or
    <I>CGAL_ON_ORIENTED_BOUNDARY</I>, depending on where point <I>q</I>
    is. <BR><STRONG>Precondition: </STRONG><I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    CGAL_Bounded_side
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.bounded_side (  Point_2 q)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the symbolic constant <I>CGAL_ON_BOUNDED_SIDE</I>,
    <I>CGAL_ON_BOUNDARY</I> or <I>CGAL_ON_UNBOUNDED_SIDE</I>, depending
    on where point <I>q</I> is. <BR><STRONG>Precondition: </STRONG>
    <I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    CGAL_Bbox_2
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.bbox ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the smallest bounding box containing <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::FT
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.area ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the signed area of the polygon <I>p</I>. This means that
    the area is positive for counter clockwise polygons and negative
    for clockwise polygons.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.left_vertex ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the leftmost vertex of the polygon <I>p</I> with the
    smallest <I>y</I>-coordinate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.right_vertex ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the rightmost vertex of the polygon <I>p</I> with the
    largest <I>y</I>-coordinate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.top_vertex ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns topmost vertex of the polygon <I>p</I> with the largest
    <I>x</I>-coordinate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Vertex_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.bottom_vertex ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the bottommost vertex of the polygon <I>p</I> with the
    smallest <I>x</I>-coordinate.
        </TD></TR>
        </TABLE><!3>

<P>

For convenience we provide the following boolean functions:
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.is_counterclockwise_oriented ()
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.is_clockwise_oriented ()
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.is_collinear_oriented ()
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.has_on_positive_side (  Point_2 q)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.has_on_negative_side (  Point_2 q)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.has_on_boundary (  Point_2 q)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.has_on_bounded_side (  Point_2 q)
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    p.has_on_unbounded_side (  Point_2 q)
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>

<P>

<H3> Random access methods</H3>
<P>

These methods are only available for random access containers.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     Point_2
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.vertex ( int i)
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a (const) reference to the <MATH>i</MATH>-th vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     Point_2
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     p [ int i]
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a (const) reference to the <MATH>i</MATH>-th vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Segment_2
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.edge ( int i)
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a const reference to the <MATH>i</MATH>-th edge.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Miscellaneous</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.size ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the number of vertices of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.is_empty ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <MATH></MATH><I>p.size()</I><MATH> == 0</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     Container
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    p.container ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a const reference to the sequence of vertices of the
    polygon <I>p</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Globally defined operators</H3>
<P>

<I>template &lt;class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, class Container1, class Container2&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_operator==6const_CGAL_Polygon_26Traits+Container19__p1+___const_CGAL_Polygon_26Traits+Container29__p29;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
      <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container1&gt; p1 ==  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container2&gt; p2
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Test for equality: two polygons are equal iff there exists a cyclic
    permutation of the vertices of <I>p2</I> such that they are equal
    to the vertices of <I>p1</I>. Note that the template argument
    <I>Container</I> of <I>p1</I> and <I>p2</I> may be different.
        </TD></TR>
        </TABLE><!3>

<P>

<P>
<I>template &lt;class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, class Container1, class Container2&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_bool_operator!=6const_CGAL_Polygon_26Traits+Container19__p1+___const_CGAL_Polygon_26Traits+Container29__p29;"></A>
bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
      <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container1&gt; p1 !=  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container2&gt; p2
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Test for inequality.
        </TD></TR>
        </TABLE><!3>

<P>

<I>template &lt;class Transformation, class <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, class Container&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Polygon_26Traits+Container9__transform6const_Transformation__t+_const_CGAL_Polygon_26Traits+Container9__p9;"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    transform (  Transformation t,  p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the image of the polygon <I>p</I> under the transformation
    <I>t</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> I/O</H3>
<P>

The I/O operators are defined for <I>iostream</I>, and for the window
stream provided by CGAL. The format for the iostream is an internal
format.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_ostream__operator666ostream__os+_const_CGAL_Polygon_26Traits+_Container9__p9;"></A>
ostream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     ostream&amp; os &lt;&lt;  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, Container&gt; p
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the polygon <I>p</I> into the stream <I>os</I>.
    <BR><STRONG>Precondition: </STRONG>The insert operator is defined
    for class <I>Point_2</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_istream__operator996istream__is+__const_CGAL_Polygon_26Traits+_Container9__p9;"></A>
istream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     istream&amp; is &gt;&gt;  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, Container&gt; p
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Reads a polygon from stream <I>is</I> and assigns it to <I>p</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<I>#include &lt;CGAL/IO/Window_stream.h&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Window_stream__operator666CGAL_Window_stream__W+__const_CGAL_Polygon_26Traits+_Container9__p9;_"></A>
CGAL_Window_stream&amp;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     CGAL_Window_stream&amp; W &lt;&lt;  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>, Container&gt; p
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the triangulation <I>p</I> into the window stream <I>W</I>.
    The insert operator must be defined for <I>Point_2</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Example</H3>The following code fragment creates a polygon and
checks if it is convex.
<P>

<PRE>
#include &lt;CGAL/basic.h&gt;
#include &lt;CGAL/Cartesian.h&gt;
#include &lt;CGAL/Polygon_2.h&gt;
#include &lt;list.h&gt;

typedef CGAL_Cartesian&lt;double&gt; R;
typedef <A HREF="CGAL_Polygon_traits_2.html#Cross_link_anchor_2">CGAL_Polygon_traits_2&lt;R&gt;</A> <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>;
typedef <A HREF="Traits.html#Cross_link_anchor_1">Traits</A>::Point_2 Point;
typedef list&lt;Point&gt; Container;
typedef <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="Traits.html#Cross_link_anchor_1">Traits</A>,Container&gt; Polygon;

#include &lt;iostream.h&gt;

int main()
{
  Polygon p;

  p.push_back(Point(0,0));
  p.push_back(Point(1,0));
  p.push_back(Point(1,1));
  p.push_back(Point(0,1));

  cout &lt;&lt; &quot;The polygon is &quot; &lt;&lt; (p.is_convex() ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;convex.&quot; &lt;&lt; endl;

  return 0;
}
</PRE>
<P>

<H3> Implementation</H3>
<P>

The methods <I>is_simple</I>, <I>is_convex</I>, <I>orientation</I>,
<I>oriented_side</I>, <I>bounded_side</I>, <I>bbox</I>, <I>area</I>,
<I>left_vertex</I>, <I>right_vertex</I>, <I>top_vertex</I> and
<I>bottom_vertex</I> are all implemented using the algorithms on
sequences of 2D points described in section <A HREF="Chapter_polygon.html#sec:poly_algo"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. There
you can find information about which algorithms were used and what
their complexity they have.
<P>
<HR> <B>Next:</B>  Class declaration of <A HREF="Traits.html"><I>Traits</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_polygon.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
