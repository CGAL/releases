<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_main.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: CGAL_Min_ellipse_2<Traits></TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_5"></A>

<A NAME="Cross_link_anchor_5"></A>

<P>

<H2> 2D Smallest Enclosing Ellipse (<I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2</A></I>)</H2>
<P>

<A NAME="sec:min_ellipse_2_spec"></A>
<P>


<P>

<H3>Definition</H3>An object of the class
<I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I> is the unique ellipse of
smallest area enclosing a finite set of points in two-dimensional
euclidean space <MATH><B>E</B><SUB>2</SUB></MATH>. For a point set
<MATH>P</MATH> we denote by <MATH>me(P)</MATH> the smallest ellipse
that contains all points of <MATH>P</MATH>. Note that
<MATH>me(P)</MATH> can be degenerate, i.e.
<MATH>me(P)=</MATH>&Oslash;<MATH></MATH> if
<MATH>P=</MATH>&Oslash;<MATH></MATH>, <MATH>me(P)={p}</MATH> if
<MATH>P={p}</MATH>, and
<MATH>me(P) = { </MATH>(1-l)p + l q | 0 <= l <= 1<MATH> }</MATH> if
<MATH>P={p,q}</MATH>.
<P>

An inclusion-minimal subset <MATH>S</MATH> of <MATH>P</MATH> with
<MATH>me(S)=me(P)</MATH> is called a <EM>support set</EM>, the points
in <MATH>S</MATH> are the <EM>support points</EM>. A support set has
size at most five, and all its points lie on the boundary of
<MATH>me(P)</MATH>. If <MATH>me(P)</MATH> has more than five points on
the boundary, neither the support set nor its size are necessarily
unique.
<P>

The underlying algorithm can cope with all kinds of input, e.g.
<MATH>P</MATH> may be empty or points may occur more than once. The
algorithm computes a support set <MATH>S</MATH> which remains fixed
until the next insert or clear operation.
<P>

<EM>Note:</EM> In this release correct results are only guaranteed if
exact arithmetic is used, see
Section&nbsp;<A HREF="CGAL_Min_ellipse_2_traits_2.html#sec:min_ellipse_2_traits_impl_2D_kernel"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.
<P>

<I>#include &lt;CGAL/Min_ellipse_2.h&gt;</I>
<P>

<H3> <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> Class</H3>
<P>

The template parameter <I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I> is a traits class that defines the
abstract interface between the optimisation algorithm and the
primitives it uses. For example <I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>::Point</I> is a mapping on a
point class. Think of it as 2D points in the Euclidean plane.
<P>

We provide a traits class implementation using the CGAL 2D kernel as
described in
Section&nbsp;<A HREF="CGAL_Min_ellipse_2_traits_2.html#sec:min_ellipse_2_traits_impl_2D_kernel"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>
class adapters to user supplied point classes are available, see
Sections&nbsp;<A HREF="CGAL_Min_ellipse_2_adapterC2.html#sec:min_ellipse_2_traits_adapterC2"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>
and&nbsp;<A HREF="CGAL_Min_ellipse_2_adapterH2.html#sec:min_ellipse_2_traits_adapterH2"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. Customizing own
traits classes for optimisation algorithms can be done according to the
requirements for traits classes listed in
Section&nbsp;<A HREF="requirements_Min_ellipse_2.html"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>
.
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Traits"></A>
<A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A>::<A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>
        </I></NOBR>
        </TD></TR>
    
    <P>
        </TABLE><!2>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Typedef_Point"></A>
typedef <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>::Point
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Point;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Point type.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Typedef_Ellipse"></A>
typedef <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>::Ellipse
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Ellipse;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Ellipse type.
        </TD></TR>
        </TABLE><!3>

<P>

The following types denote iterators that allow to traverse all points
and support points of the smallest enclosing ellipse, resp. The
iterators are non-mutable and their value type is <I>Point</I>. The
iterator category is given in parentheses.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Point_iterator"></A>
<A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A>::Point_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    (bidirectional).
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A NAME="Nested_type_Support_point_iterator"></A>
<A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A>::Support_point_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    (random access).
    <P>
        </TD></TR>
        </TABLE><!2>

<P>


<P>

<H3>Creation</H3>
<P>

A <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I> object can be created from an
arbitrary point set <MATH>P</MATH> and by specialized construction
methods expecting no, one, two, three, four or five points as
arguments. The latter methods can be useful for reconstructing
<MATH>me(P)</MATH> from a given support set <MATH>S</MATH> of
<MATH>P</MATH>.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    template &lt; class InputIterator &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     InputIterator last, <BR>
     bool randomize = false, <BR>
     CGAL_Random&amp; random = CGAL_random, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>mc(P)</MATH> with <MATH>P</MATH> being the set of points in
    the range [<I>first</I>,<I>last</I>). If <I>randomize</I> is
    <I>true</I>, a random permutation of <MATH>P</MATH> is computed in
    advance, using the random numbers generator <I>random</I>. Usually,
    this will not be necessary, however, the algorithm's efficiency
    depends on the order in which the points are processed, and a bad
    order might lead to extremely poor performance (see example below).
    <BR><STRONG>Precondition: </STRONG>The value type of <I>first</I>
    and <I>last</I> is <I>Point</I>.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<EM>Note:</EM> In case a compiler does not support member templates
yet, we provide specialized constructors instead. In the current
release there are constructors for C arrays (using pointers as
iterators), for the STL sequence containers <I>vector&lt;Point&gt;</I>
and <I>list&lt;Point&gt;</I> and for the STL input stream iterator
<I>istream_iterator&lt;Point&gt;</I>.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse (  <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>me(</MATH>&Oslash;<MATH>)</MATH>, the empty set.
    <BR><STRONG>Postcondition: </STRONG><I>min_ellipse</I>
    <I>.is_empty()</I> = <I>true</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>me({p})</MATH>, the set <MATH>{p}</MATH>.
    <BR><STRONG>Postcondition: </STRONG><I>min_ellipse</I>
    <I>.is_degenerate()</I> = <I>true</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p, <BR>
     Point q, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>me({p,q})</MATH>, the set
    <MATH>{ </MATH>(1-l)p + l q | 0 <= l <= 1<MATH> }</MATH>.
    <BR><STRONG>Postcondition: </STRONG><I>min_ellipse</I>
    <I>.is_degenerate()</I> = <I>true</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p1, <BR>
     Point p2, <BR>
     Point p3, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>me({p1,p2,p3})</MATH>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p1, <BR>
     Point p2, <BR>
     Point p3, <BR>
     Point p4, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>me({p1,p2,p3,p4})</MATH>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A> min_ellipse ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p1, <BR>
     Point p2, <BR>
     Point p3, <BR>
     Point p4, <BR>
     Point p5, <BR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits = <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>());</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    creates a variable <I>min_ellipse</I> of type
    <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>. It is initialized to
    <MATH>me({p1,p2,p3,p4,p5})</MATH>.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Access Functions</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.number_of_points ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of points of <I>min_ellipse</I>, i.e.
    <MATH>|P|</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    int
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.number_of_support_points ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the number of support points of <I>min_ellipse</I>, i.e.
    <MATH>|S|</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Point_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.points_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns an iterator referring to the first point of
    <I>min_ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    Point_iterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.points_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Support_point_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.support_points_begin ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns an iterator referring to the first support point of
    <I>min_ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Support_point_iterator
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.support_points_end ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     Point
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.support_point ( int i)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the <I>i</I>-th support point of <I>min_ellipse</I>.
    Between two modifying operations (see below) any call to
    <I>min_ellipse</I><I>.support_point(i)</I> with the same <I>i</I>
    returns the same point.
    <BR><STRONG>Precondition: </STRONG><MATH>0 &lt;=i&lt; </MATH><I>min_ellipse</I><I>.number_of_support_points()</I><MATH></MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     Ellipse
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.ellipse ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns the current ellipse of <I>min_ellipse</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Predicates</H3>By definition, an empty
<I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I> has no boundary and no bounded
side, i.e. its unbounded side equals the whole plane
<MATH><B>E</B><SUB>2</SUB></MATH>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    CGAL_Bounded_side
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.bounded_side (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>CGAL_ON_BOUNDED_SIDE</I>, <I>CGAL_ON_BOUNDARY</I>, or
    <I>CGAL_ON_UNBOUNDED_SIDE</I> iff <I>p</I> lies properly inside, on
    the boundary, or properly outside of <I>min_ellipse</I>, resp.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.has_on_bounded_side (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>p</I> lies properly inside
    <I>min_ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.has_on_boundary (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>p</I> lies on the boundary of
    <I>min_ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.has_on_unbounded_side (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>p</I> lies outside of
    <I>min_ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.is_empty ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>min_ellipse</I> is empty (this implies
    degeneracy).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.is_degenerate ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>min_ellipse</I> is degenerate, i.e. if
    <I>min_ellipse</I> is empty, equal to a single point or equal to a
    segment, equivalently if the number of support points is less than
    3.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Modifiers</H3>New points can be added to an existing
<MATH><I>min_ellipse</I></MATH>, allowing to build <MATH>me(P)</MATH>
incrementally, e.g. if <MATH>P</MATH> is not known in advance. Compared
to the direct creation of <MATH>me(P)</MATH>, this is not much slower,
because the construction method is incremental itself.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.insert (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    inserts <I>p</I> into <I>min_ellipse</I> and recomputes the
    smallest enclosing ellipse.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt; class InputIterator &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    min_ellipse.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     InputIterator last)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    inserts the points in the range [<I>first</I>,<I>last</I>) into
    <I>min_ellipse</I> and recomputes the smallest enclosing ellipse by
    calling <I>insert(p)</I> for each point <I>p</I> in [<I>first</I>,
    <I>last</I>). <BR><STRONG>Precondition: </STRONG>The value type of
    <I>first</I> and <I>last</I> is <I>Point</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<EM>Note:</EM> In case a compiler does not support member templates
yet, we provide specialized <I>insert</I> functions instead. In the
current release there are <I>insert</I> functions for C arrays (using
pointers as iterators), for the STL sequence containers
<I>vector&lt;Point&gt;</I> and <I>list&lt;Point&gt;</I> and for the STL
input stream iterator <I>istream_iterator&lt;Point&gt;</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.clear ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    deletes all points in <I>min_ellipse</I> and sets
    <I>min_ellipse</I> to the empty set.
    <BR><STRONG>Postcondition: </STRONG><I>min_ellipse</I>
    <I>.is_empty()</I> = <I>true</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<H3> Validity Check</H3>
<P>

An object <I>min_ellipse</I> is valid, iff <UL> <LI><I>min_ellipse</I>
contains all points of its defining set <MATH>P</MATH>,
<LI><I>min_ellipse</I> is the smallest ellipse spanned by its support
set <MATH>S</MATH>, and <LI><MATH>S</MATH> is minimal, i.e. no support
point is redundant. </UL> <EM>Note:</EM> In this release only the first
item is considered by the validity check.
<P>

Using the traits class implementation for the CGAL kernel with exact
arithmetic as described in
Section&nbsp;<A HREF="CGAL_Min_ellipse_2_traits_2.html#sec:min_ellipse_2_traits_impl_2D_kernel"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A> guarantees
validity of <I>min_ellipse</I>. The following function is mainly
intended for debugging user supplied traits classes but also for
convincing the anxious user that the traits class implementation is
correct.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    min_ellipse.is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    bool verbose = false, <BR>
     int level = 0)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>min_ellipse</I> contains all points of
    its defining set <MATH>P</MATH>. If <I>verbose</I> is <I>true</I>,
    some messages concerning the performed checks are written to
    standard error stream. The second parameter <I>level</I> is not
    used, we provide it only for consistency with interfaces of other
    classes.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<P>

<H3> Miscellaneous</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
     <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    min_ellipse.traits ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns a const reference to the traits class object.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> I/O</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_ostream__operator_66_6_ostream__os+__const_CGAL_Min_ellipse_26Traits9___min_ellipse9;"></A>
ostream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     ostream&amp; os &lt;&lt;  min_ellipse
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    writes <I>min_ellipse</I> to output stream <I>os</I>.
    <BR><STRONG>Precondition: </STRONG>The output operator is defined
    for <I>Point</I> (and for <I>Ellipse</I>, if pretty printing is
    used).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_istream__operator_99_6_istream__is+__CGAL_Min_ellipse_26Traits9__min_ellipse9;"></A>
istream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     istream&amp; is &gt;&gt;  &amp; min_ellipse
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    reads <I>min_ellipse</I> from input stream <I>is</I>.
    <BR><STRONG>Precondition: </STRONG>The input operator is defined
    for <I>Point</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<I>#include &lt;CGAL/IO/Window_stream.h&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Window_stream___operator_66_6_CGAL_Window_stream__ws+__const_CGAL_Min_ellipse_26Traits9__min_ellipse9;"></A>
CGAL_Window_stream&amp;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     CGAL_Window_stream&amp; ws &lt;&lt;  min_ellipse
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    writes <I>min_ellipse</I> to window stream <I>ws</I>.
    <BR><STRONG>Precondition: </STRONG>The window stream output
    operator is defined for <I>Point</I> and <I>Ellipse</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>See Also</H3><I><A HREF="CGAL_Min_circle_2.html#Cross_link_anchor_0">CGAL_Min_circle_2</A></I> ,
<I><A HREF="CGAL_Min_ellipse_2_traits_2.html#Cross_link_anchor_7">CGAL_Min_ellipse_2_traits_2</A></I> , 
<I><A HREF="CGAL_Min_ellipse_2_adapterC2.html#Cross_link_anchor_8">CGAL_Min_ellipse_2_adapterC2</A></I> ,
<I><A HREF="CGAL_Min_ellipse_2_adapterH2.html#Cross_link_anchor_9">CGAL_Min_ellipse_2_adapterH2</A></I> .
<P>

<H3>Implementation</H3>We implement the algorithm of Welzl, with
move-to-front
heuristic&nbsp;[<A HREF="../biblio.html#Biblio_w-sedbe-91a">Wel91</A>],
using the primitives as described
in&nbsp;[<A HREF="../biblio.html#Biblio_gs-epsee-97">GS97a</A>, <A HREF="../biblio.html#Biblio_gs-seefe-97a">GS97b</A>].
If randomization is chosen, the creation time is almost always linear
in the number of points. Access functions and predicates take constant
time, inserting a point might take up to linear time, but substantially
less than computing the new smallest enclosing ellipse from scratch.
The clear operation and the check for validity each takes linear time.
<P>

<H3>Example</H3>To illustrate the creation of
<I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A></I>and to show that randomization
can be useful in certain cases, we give an example.
<P>

 <PRE>
#include &lt;CGAL/Gmpz.h&gt;
#include &lt;CGAL/Homogeneous.h&gt;
#include &lt;CGAL/Point_2.h&gt;
#include &lt;CGAL/Min_ellipse_2_traits_2.h&gt;
#include &lt;CGAL/Min_ellipse_2.h&gt;

typedef  CGAL_Gmpz                       NT;
typedef  CGAL_Homogeneous&lt;NT&gt;            R;
typedef  CGAL_Point_2&lt;R&gt;                 Point;
typedef  <A HREF="CGAL_Min_ellipse_2_traits_2.html#Cross_link_anchor_7">CGAL_Min_ellipse_2_traits_2&lt;R&gt;</A>  <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>;
typedef  <A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2&lt;Traits&gt;</A>      Min_ellipse;

int main()
{
    int     n = 1000;
    Point*  P = new Point[ n];

    for ( int i = 0; i &lt; n; ++i)
        P[ i] = Point( (i%2 == 0 ? i : -i), 0);
    // (0,0), (-1,0), (2,0), (-3,0), ...

    Min_ellipse  me1( P, P+n);           // very slow
    Min_ellipse  me2( P, P+n, true);     // fast

    delete[] P;
    return( 0);
}
</PRE>

<P>
<HR> <B>Next:</B>  Class declaration of <A HREF="CGAL_Optimisation_ellipse_2.html"><I>CGAL_Optimisation_ellipse_2&lt;R&gt;</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
