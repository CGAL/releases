<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_main.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<P>


  <H2>Requirements of <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> Classes for 2D Smallest Enclosing Ellipse</H2><P>
<P>

<P>

The class template <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2</A></I> is parameterized with a
<I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I> class which defines the abstract interface between the
optimisation algorithm and the primitives it uses. The following
requirements catalog lists the primitives, i.e. types, member
functions etc., that must be defined for a class that can be used to
parameterize <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2</A></I>. A traits class implementation
using the CGAL 2D kernel is available and described in
Section&nbsp;<A HREF="CGAL_Min_ellipse_2_traits_2.html#sec:min_ellipse_2_traits_impl_2D_kernel"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. In addition, we
provide traits class adapters to user supplied point classes, see
Sections&nbsp;<A HREF="CGAL_Min_ellipse_2_adapterC2.html#sec:min_ellipse_2_traits_adapterC2"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>
and&nbsp;<A HREF="CGAL_Min_ellipse_2_adapterH2.html#sec:min_ellipse_2_traits_adapterH2"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. Both, the implementation
and the adapters, can be used as a starting point for customizing own
traits classes, e.g. through derivation and specialization.<P>

<H3><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> Class (<I><A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A></I>)</H3>

<P>

<H3>Definition</H3>A class that satisfies the requirements of a traits
class for <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2</A></I> must provide the following
primitives.
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>::Point
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    The point type must provide default and copy constructor,
    assignment and equality test.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>::Ellipse
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    The ellipse type must fulfill the requirements listed below in the
    next section.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

In addition, if I/O is used, the corresponding I/O operators for
<I>Point</I> and <I>Ellipse</I> have to be provided, see topic <B>I/O
</B> in Section&nbsp;<A HREF="CGAL_Min_ellipse_2.html#sec:min_ellipse_2_spec"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.
<P>

<H3> Variables</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Var_ellipse"></A>
Ellipse
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    ellipse;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    The actual ellipse. This variable is maintained by the algorithm,
    the user should neither access nor modify it directly.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Creation</H3>
<P>

Only default and copy constructor are required. Note that further
constructors can be provided.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    A default constructor.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A> traits (  <A HREF="../Polygon/Traits.html#Cross_link_anchor_1">Traits</A>);
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    A copy constructor.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

<H3>Ellipse Type (<I>Ellipse</I>)</H3>

<P>

<H3>Definition</H3>An object of the class <I>Ellipse</I> is an ellipse
in two-dimensional euclidean plane <MATH><B>E</B><SUB>2</SUB></MATH>.
Its boundary splits the plane into a bounded and an unbounded side. By
definition, an empty <I>Ellipse</I> has no boundary and no bounded
side, i.e. its unbounded side equals the whole plane
<MATH><B>E</B><SUB>2</SUB></MATH>.
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    Ellipse::Point
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Point type.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Creation</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    ellipse.set ()
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sets <I>ellipse</I> to the empty ellipse.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.set (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sets <I>ellipse</I> to the ellipse containing exactly
    <MATH>{</MATH><I>p</I><MATH>}</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.set (  Point p,  Point q)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sets <I>ellipse</I> to the ellipse containing exactly the segment
    <i>pq</i>. The algorithm guarantees that <I>set</I> is never called
    with two equal points.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.set (  Point p,  Point q,  Point r)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sets <I>ellipse</I> to the smallest ellipse through <I>p</I>,
    <I>q</I>,<I>r</I>. The algorithm guarantees that <I>set</I> is
    never called with three collinear points.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.set (  Point p,  Point q,  Point r,  Point s)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sets <I>ellipse</I> to the smallest ellipse through <I>p</I>,
    <I>q</I>,<I>r</I>,<I>s</I>. The algorithm guarantees that this
    ellipse exists.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    void
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    ellipse.set ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p, <BR>
     Point q, <BR>
     Point r, <BR>
     Point s, <BR>
     Point t)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    sets <I>ellipse</I> to the unique conic through <I>p</I>,<I>q</I>,
    <I>r</I>,<I>s</I>,<I>t</I>. The algorithm guarantees that this
    conic is an ellipse.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Predicates</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.has_on_unbounded_side (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>p</I> lies properly outside of
    <I>ellipse</I>.
        </TD></TR>
        </TABLE><!3>

<P>

Each of the following predicates is only needed, if the corresponding
predicate of <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2</A></I> is used.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    CGAL_Bounded_side
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.bounded_side (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>CGAL_ON_BOUNDED_SIDE</I>, <I>CGAL_ON_BOUNDARY</I> or
    <I>CGAL_ON_UNBOUNDED_SIDE</I> iff <I>p</I> lies properly inside, on
    the boundary, or properly outside of <I>ellipse</I>, resp.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.has_on_bounded_side (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>p</I> lies properly inside
    <I>ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.has_on_boundary (  Point p)
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>p</I> lies on the boundary of
    <I>ellipse</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.is_empty ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>ellipse</I> is empty (this implies
    degeneracy).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    bool
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    ellipse.is_degenerate ()
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, iff <I>ellipse</I> is degenerate, i.e. if
    <I>ellipse</I> is empty or equal to a single point.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> I/O</H3>
<P>

The following I/O operators are only needed,  if the corresponding I/O
operators of <I><A HREF="CGAL_Min_ellipse_2.html#Cross_link_anchor_5">CGAL_Min_ellipse_2</A></I> are used.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    ostream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     ostream&amp; os &lt;&lt;  ellipse
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    writes <I>ellipse</I> to output stream <I>os</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    istream&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     istream&amp; is &gt;&gt;  &amp; ellipse
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    reads <I>ellipse</I> from input stream <I>is</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    CGAL_Window_stream&amp;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
     CGAL_Window_stream&amp; ws &lt;&lt;  ellipse
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    writes <I>ellipse</I> to window stream <I>ws</I>.
        </TD></TR>
        </TABLE><!3>
<P>

<HR> <B>Next:</B> <A HREF="computing_maximum_area_inscribed_k_gon.html">Function Declaration of CGAL_maximum_area_inscribed_k_gon</A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
