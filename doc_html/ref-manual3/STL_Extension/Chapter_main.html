<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_main.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<H1>STL Extensions for CGAL</H1>

<A NAME="chapterDataStructures"></A>
<A NAME="chapterStlExtensions"></A>
<BR><BR><P>

CGAL is designed in the spirit of the generic programming paradigm
to work together with the Standard Template Library (STL)
[<A HREF="../biblio.html#Biblio_c-wpdpi-96">C<TT>++</TT>96</A>, <A HREF="../biblio.html#Biblio_ms-strg-96">MS96</A>]. This chapter documents non-geometric
STL-like components that are not provided in the STL standard but
in CGAL: a doubly-connected list managing items in place
(where inserted items are not copied), generic
functions, function objects for projection and creation, classes for
composing function objects and adaptor classes around iterators and
circulators. See also circulators in Chapter&nbsp;<A HREF="../Circulator/Chapter_circulator.html#chapterCirculators"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.<P>

<A NAME="Section_1"></A>
<H2>Doubly-Connected List Managing Items in Place</H2>
<P>

The class <I><A HREF="CGAL_In_place_list.html#Cross_link_anchor_1">CGAL_In_place_list</A>&lt;T,&amp;T::next,&amp;T::prev&gt;</I> manages a
sequence of items in place in a doubly-connected list. Its goals are
the flexible handling of memory management and performance
optimization. The item type is supposed to provide the two necessary
pointers <I>&amp;T::next_link</I> and <I>&amp;T::prev_link</I>. One possibility
to obtain these pointers is to inherit them from the base class
<I><A HREF="CGAL_In_place_list_base.html#Cross_link_anchor_0">CGAL_In_place_list_base&lt;T&gt;</A></I>.<P>

The class <I><A HREF="CGAL_In_place_list.html#Cross_link_anchor_1">CGAL_In_place_list&lt;T&gt;</A></I> is a container and quite
similar to STL containers, with the advantage that it is able to
handle the stored elements by reference instead of copying them. It is
possible to delete an element only knowing its address and no iterator
to it. This simplifies mutually pointered data structures like a
halfedge data structure for planar maps or polyhedral surfaces. The
usual iterators are also available. Another container with this
property of working with pointers to objects is the STL vector (at
least in the current STL implementations).<P>

<H3>Base Classes for List Nodes</H3>
<P>

<H3>Definition</H3>The node base classes provides pointers to build linked
lists. The class <I>CGAL_In_place_sl_list_base&lt;T&gt;</I> provides a pointer
<I>next_link</I> for a single linked list. The class
<I><A HREF="CGAL_In_place_list_base.html#Cross_link_anchor_0">CGAL_In_place_list_base&lt;T&gt;</A></I> provides an additional pointer
<I>prev_link</I> for doubly linked lists. These names conform to
the default parameters used in the template argument lists of the
container classes. The pointers are public members.<P>

<I>#include &lt;CGAL/In_place_list.h&gt;</I><P>

<UL><LI>
 Class declaration of <A HREF="CGAL_In_place_list_base.html"><I>CGAL_In_place_list_base&lt;T&gt;</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_In_place_list.html"><I>CGAL_In_place_list&lt;T,bool&gt;</I></A>.</UL>

<P>

<P><A NAME="Section_2"></A>
<H2>Generic Functions</H2>
<P>

<A NAME="sectionGenericFunctions"></A><P>

<H3>Copy <MATH>n</MATH> Items</H3>

<A NAME="sectionCopyN"></A><P>

<I>CGAL_copy_n()</I> copies <MATH>n</MATH> items from an input iterator to an
output iterator which is useful for possibly infinite sequences of
random geometric objects[<A HREF="#Footnote_1">^1</A>].<P>

<I>#include &lt;CGAL/copy_n.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt;class InputIterator, class Size, class OutputIterator&gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_OutputIterator_CGAL_copy_n6_InputIterator_first+_Size_n+___OutputIterator_result9;"></A>
OutputIterator
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_copy_n ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     Size n, <BR>
     OutputIterator result)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    copies the first <MATH>n</MATH> items from <I>first</I> to
    <I>result</I>. Returns the value of <I>result</I> after inserting
    the <MATH>n</MATH> items.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>See Also</H3><I><A HREF="CGAL_Counting_iterator.html#Cross_link_anchor_22">CGAL_Counting_iterator</A></I>.<P>

<P><A NAME="Section_3"></A>
<H2>Function Objects</H2>
<P>

Two kinds of function objects are provided: Projections and Creators.<P>

<H3>Projection Function Objects</H3>

<A NAME="sectionProjectionFunctionObjects"></A><P>

<H3>Definition</H3>A <EM>projection</EM> function object <MATH>o</MATH> of type <MATH>O</MATH> has an unary parentheses
operator expecting an argument of type <I>O::argument_type</I> as a
reference or constant reference, and returns a reference or constant
reference of type <I>O::result_type</I> respectively.<P>

<I>#include &lt;CGAL/function_objects.h&gt;</I><P>

<H3>Operations</H3>
<A NAME="Index_anchor_2"></A>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    O::result_type&amp;
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    o.operator() ( O::argument_type &amp;) const
        </I></NOBR>
        
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    const O::result_type&amp;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    o.operator() ( const O::argument_type &amp;) const
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>
<P>

<H3>Creation</H3>The following projection function objects are available:<P>


<A NAME="Index_anchor_3"></A>

<A NAME="Cross_link_anchor_2"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_2">CGAL_Identity&lt;Value&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the identity function for projection objects. <I>argument_type</I>
    and <I>result_type</I> are equal to <I>Value</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_4"></A>

<A NAME="Cross_link_anchor_3"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_3">CGAL_Compose</A>&lt;Fct1, Fct2&gt; o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    composes two projections:
    <MATH></MATH><I>Fct1</I><MATH> <TT>o</TT>
      </MATH><I>Fct2</I><MATH> <TT>o</TT> x = </MATH><I>Fct1()( Fct2()(x))</I><MATH></MATH>.
    <I>argument_type</I> is equal to <I>Fct2::argument_type</I>,
    <I>result_type</I> to <I>Fct1::result_type</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_5"></A>

<A NAME="Cross_link_anchor_4"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_4">CGAL_Dereference&lt;Value&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    dereferences a pointer. <I>argument_type</I> is equal to
    <I>Value*</I> and <I>result_type</I> is equal to <I>Value</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_6"></A>

<A NAME="Cross_link_anchor_5"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_5">CGAL_Get_address&lt;Value&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Get the address for a reference. <I>argument_type</I> is equal to
    <I>Value</I> and <I>result_type</I> is equal to <I>Value*</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_7"></A>

<A NAME="Cross_link_anchor_6"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_6">CGAL_Cast_function_object</A>&lt;Arg, Result&gt; o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    applies a C-style type cast to its argument. <I>argument_type</I>
    is equal to <I>Arg</I> and <I>result_type</I> is equal to
    <I>Result</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

The following function objects are provided with respect to the
polyhedral surfaces in the basic library.<P>


<A NAME="Index_anchor_8"></A>

<A NAME="Cross_link_anchor_7"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_7">CGAL_Project_vertex&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>vertex()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> is equal to <I>Node</I> and
    <I>result_type</I> is equal to <I>Node::Vertex</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_9"></A>

<A NAME="Cross_link_anchor_8"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_8">CGAL_Project_facet&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>facet()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> is equal to <I>Node</I> and
    <I>result_type</I> is equal to <I>Node::Facet</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_10"></A>

<A NAME="Cross_link_anchor_9"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_9">CGAL_Project_point&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>point()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> is equal to <I>Node</I> and
    <I>result_type</I> is equal to <I>Node::Point</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_11"></A>

<A NAME="Cross_link_anchor_10"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_10">CGAL_Project_normal&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>normal()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> is equal to <I>Node</I> and
    <I>result_type</I> is equal to <I>Node::Normal</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_12"></A>

<A NAME="Cross_link_anchor_11"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_11">CGAL_Project_plane&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>plane()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> is equal to <I>Node</I> and
    <I>result_type</I> is equal to <I>Node::Plane</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_13"></A>

<A NAME="Cross_link_anchor_12"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_12">CGAL_Project_next&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>next()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> and <I>result_type</I> are equal
    to <I>Node*</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_14"></A>

<A NAME="Cross_link_anchor_13"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_13">CGAL_Project_prev&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member function <I>prev()</I> on an instance of type
    <I>Node</I>. <I>argument_type</I> and <I>result_type</I> are equal
    to <I>Node*</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_15"></A>

<A NAME="Cross_link_anchor_14"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_14">CGAL_Project_next_opposite&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member functions <I>next()-&gt;opposite()</I> on an
    instance of type <I>Node</I>. <I>argument_type</I> and
    <I>result_type</I> are equal to <I>Node*</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_16"></A>

<A NAME="Cross_link_anchor_15"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_15">CGAL_Project_opposite_prev&lt;Node&gt;</A> o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    calls the member functions <I>opposite()-&gt;prev()</I> on an
    instance of type <I>Node</I>. <I>argument_type</I> and
    <I>result_type</I> are equal to <I>Node*</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

<H3>Creator Function Objects</H3>

<A NAME="sectionCreatorFunctionObjects"></A><P>

<H3>Definition</H3>A <EM>creator</EM> function object <MATH>o</MATH> of type <MATH>O</MATH> has a parentheses
operator which acts like a constructor. The operator might expect
arguments and returns an instance of type <I>O::result_type</I>.<P>

<I>#include &lt;CGAL/function_objects.h&gt;</I><P>

<H3>Operations</H3>
<A NAME="Index_anchor_17"></A>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    O::result_type
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    o.operator() ( ...) const
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>
<P>

<H3>Creation</H3>The following creator function objects are available for one to five arguments:<P>


<A NAME="Index_anchor_18"></A>

<A NAME="Cross_link_anchor_16"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_16">CGAL_Creator_1</A>&lt;Arg, Result&gt; o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    applies the constructor <I>Result(Arg)</I>. <I>result_type</I> is
    equal to <I>Result</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

...
<A NAME="Index_anchor_19"></A>

<A NAME="Cross_link_anchor_17"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_17">CGAL_Creator_5</A>&lt;Arg1, Arg2, Arg3, Arg4, Arg5, Result&gt; o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    applies the constructor <I>Result(Arg1, Arg2, Arg3, Arg4, Arg5)</I>
    . <I>result_type</I> is equal to <I>Result</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

The following creator function objects are available for two to nine
arguments (one argument is already captured with <I><A HREF="Chapter_main.html#Cross_link_anchor_16">CGAL_Creator_1</A></I>):<P>


<A NAME="Index_anchor_20"></A>

<A NAME="Cross_link_anchor_18"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_18">CGAL_Creator_uniform_2</A>&lt;Arg, Result&gt; o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    applies the constructor <I>Result(Arg,Arg)</I>. <I>result_type</I>
    is equal to <I>Result</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

...
<A NAME="Index_anchor_21"></A>

<A NAME="Cross_link_anchor_19"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_19">CGAL_Creator_uniform_9</A>&lt;Arg, Result&gt; o;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    applies the constructor for <I>Result</I> with nine arguments of
    type <I>Arg</I>. <I>result_type</I> is equal to <I>Result</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

<H3>See Also</H3><I><A HREF="Chapter_main.html#Cross_link_anchor_24">CGAL_Join_input_iterator_1</A></I> ....<P>

<P><A NAME="Section_4"></A>
<H2>Classes for Composing Function Objects</H2>
<P>

<A NAME="sectionComposeFunctionClasses"></A><P>

Although not mentioned in the ANSI draft(CD2), most STL
implementations provide two global functions for composing function
objects, <I>compose1</I> and <I>compose2</I>, defined in
function.h. Since for both the resulting function is unary, one can
only construct unary function objects in this way. This seems to be
quite a limitation, since many (also STL) algorithms can be
parameterized with binary (e.g. comparison) functions.<P>

In analogy to STL <I>compose1/2</I> we define two functions,
<I>CGAL_compose1_2</I> and <I>CGAL_compose2_2</I>, that can be
used to construct a binary function object via composition.<P>

<UL><LI>
 Class declaration of <A HREF="AdaptableUnaryFunction.html"><I>AdaptableUnaryFunction</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="AdaptableBinaryFunction.html"><I>AdaptableBinaryFunction</I></A>.</UL>

<P>

<H3>Composing Binary into Unary Functions</H3>
<P>

<I>#include &lt;CGAL/function_objects.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt; class Operation1, class Operation2 &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Composition_CGAL_compose1_26_const_Operation1__op1+_const__Operation2__op29;"></A>
Composition
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    CGAL_compose1_2 (  Operation1 op1,  Operation2 op2)
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>
<P>

<I>Operation1</I> must be an adaptable unary function,
<I>Operation2</I> an adaptable binary function and
<I>Operation2::result_type</I> convertible to
<I>Operation1::argument_type</I>. Then <I>CGAL_compose1_2</I>
returns an adaptable binary function object <I>c</I> (of some
complicated type <I>Composition</I>) such that<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Operation1::result_type
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    c ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Operation2::first_argument_type x, <BR>
     Operation2::second_argument_type y)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>
is equal to
<I>Operation1()( Operation2()( x, y)).</I><P>

<H3>Composing Unary into Binary Functions</H3>
<P>

<I>#include &lt;CGAL/function_objects.h&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    template &lt; class Operation1, class Operation2, class  Operation3 &gt;
        </I></NOBR>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I><NOBR>
    <A NAME="Function_Composition_CGAL_compose2_26_const_Operation1__op1+__const_Operation2__op2+_const_Operation3__op39;"></A>
Composition
        </I></NOBR>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_compose2_2 ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Operation1 op1, <BR>
     Operation2 op2, <BR>
     Operation3 op3)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>
<P>

<I>Operation1</I> must be an adaptable binary function,
<I>Operation2</I> and <I>Operation3</I> adaptable unary
functions, <I>Operation2::result_type</I> convertible to
<I>Operation1::first_argument_type</I> and
<I>Operation3::</I><I>result_type</I> convertible to
<I>Operation1::second_argument_type</I>. Then
<I>CGAL_compose2_2</I> returns an adaptable binary function object
<I>c</I> (of some complicated type <I>Composition</I>) such that<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    Operation1::result_type
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    c ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Operation2::first_argument_type x, <BR>
     Operation2::second_argument_type y)</I></TD></TR></TABLE>
    
        </I></NOBR>
        
    
        </TR>
        </TABLE><!3>
is equal to
<I>Operation1()( Operation2()( x), Operation3()( y)).</I><P>

<P><A NAME="Section_5"></A>
<H2>Adaptor Classes around Iterators and Circulators</H2>
<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Counting_iterator.html"><I>CGAL_Counting_iterator&lt;Iterator, Value&gt;</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_N_step_adaptor.html"><I>CGAL_N_step_adaptor&lt;I,int N,Ref,Ptr,Val,Dst,Ctg&gt;</I></A>.</UL>

<P>

<H3>Joining Input Iterator Streams</H3>

<A NAME="sectionJoinInputIterator"></A><P>

<H3>Definition</H3>A join of <MATH>n</MATH> input iterators and a creator function object is again
an input iterator which reads an object from each stream and applies
the creator function object on them whenever it advances.<P>

<I>#include &lt;CGAL/Join_input_iterator.h&gt;</I><P>

<H3>Creation</H3>The following join input iterator objects are available for one to
five iterators:<P>


<A NAME="Index_anchor_26"></A>

<A NAME="Cross_link_anchor_24"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <A HREF="Chapter_main.html#Cross_link_anchor_24">CGAL_Join_input_iterator_1</A>&lt;Iterator, Creator&gt; join ( Iterator i);
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the join of a single iterator <MATH>i</MATH>. Applies
    <I>Creator</I> to each item read from <MATH>i</MATH>.
    <I>value_type</I> is equal to <I>Creator::result_type</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

...
<A NAME="Index_anchor_27"></A>

<A NAME="Cross_link_anchor_25"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Chapter_main.html#Cross_link_anchor_25">CGAL_Join_input_iterator_5</A>&lt;I1, I2, I3, I4, I5, Creator&gt; join ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    I1 i1, <BR>
     I2 i2, <BR>
     I3 i3, <BR>
     I4 i4, <BR>
     I5 i5);</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=30% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the join of five iterators <I>i1</I> to <I>i5</I>. Applies
    <I>Creator</I> with five arguments <I>*i1</I> up to <I>*i5</I>.
    <I>value_type</I> is equal to <I>Creator::</I><I>result_type</I>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

<H3>See Also</H3><I><A HREF="Chapter_main.html#Cross_link_anchor_16">CGAL_Creator_1</A></I> ... and <I><A HREF="Chapter_main.html#Cross_link_anchor_18">CGAL_Creator_uniform_2</A></I> ....<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Inverse_index.html"><I>CGAL_Inverse_index&lt;IC&gt;</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Random_access_adaptor.html"><I>CGAL_Random_access_adaptor&lt;IC,Dist&gt;</I></A>.</UL>

<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Random_access_value_adaptor.html"><I>CGAL_Random_access_value_adaptor&lt;IC,T,Dist&gt;</I></A>.</UL>

<P>



<P><HR><H3>Footnotes</H3><P>

<OL>
<LI><A NAME="Footnote_1">The STL release June 13, 1997, from SGI has a new function  <I>copy_n</I> which is equivalent with <I>CGAL_copy_n</I>.
</OL>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_main.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
