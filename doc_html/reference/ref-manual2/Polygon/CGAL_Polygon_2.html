<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Polygon.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: CGAL_Polygon_2<Traits,Container></TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Polygon.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_0"></A>

<A NAME="Cross_link_anchor_0"></A>

<P>

<H1> 2D Polygon (<I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>)</H1>
<P>

<H3>Definition</H3>The class <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> represents a simple
polygon in the two-dimensional Euclidean plane
<MATH><B>E</B><SUB>2</SUB></MATH>. A polygon is called <EM>simple</EM>
if there is no pair of nonconsecutive edges sharing a point (see
[<A HREF="../biblio.html#Biblio_ps-cgi-85">Preparata &amp; al. 85</A>]).
<P>

An object <I>p</I> of the data type <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> is defined by
the sequence of its vertices. A polygon <I>p</I> is oriented, i.e., its
boundary has clockwise or counterclockwise orientation. We call the
side to the left of the boundary the positive side and the side to the
right of the boundary the negative side. As any Jordan curve, the
boundary of a polygon divides the plane into two open regions, a
bounded one and an unbounded one.
<P>

An object <I>p</I> of <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> is a dynamic data
structure, i.e. vertices can be added and removed. These operations may
destroy the simplicity of the polygon, which is a precondition to all
predicates of polygons.
<P>

The data type <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> is parametrized with two template
parameters: a traits class <I><A HREF="#PolygonTraits">Traits</A></I> and a container class
<I>Container</I>. The most important task of the parameter
<I><A NAME="PolygonTraits">Traits</A></I> is to specify the type of the points stored in the
polygon. The default point type is <I>CGAL_Point_2&lt;<A HREF="#PolygonTraits">Traits</A>&gt;</I>.
The parameter <I>Container</I> specifies the type of container that is
used to store the sequence of vertices of the polygon, e.g. a list, a
vector, a tree, etc. The type <I>Container</I> should fulfill the
requirements of a sequence container given in
[<A HREF="../biblio.html#Biblio_ms-strg-96">Musser &amp; al. 96</A>]. The value
type of the container should be the same as the point type of the
traits class. <B>N.B.</B> Due to compiler problems, the only container
that is currently guaranteed to work correctly is <B>the STL-container
<EM>list</EM>.</B> (To be more specific: the circulators and iterators
that are used to traverse the vertices and edges currently have a fixed
iterator category and a fixed distance type. As a consequence,
sometimes the wrong version of an STL algorithm will be selected. This
problem will be solved in the near future by using iterator traits.)
<P>

<EM>Note</EM>: Currently, a polygon declaration looks like
<I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>, list&lt;<A HREF="#PolygonTraits">Traits</A>::Point&gt; &gt;</I>. When
nested templates become available this might be simplified to
<I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>, list&gt;</I>.
<P>

<H3> Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Traits"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::<A HREF="#PolygonTraits">Traits</A>
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    The traits type.
    <P>
        </TD></TR>
        </TABLE><!2>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Point"></A>
typedef <A HREF="#PolygonTraits">Traits</A>::Point
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Point;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Segment"></A>
typedef <A HREF="#PolygonTraits">Traits</A>::Segment
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Segment;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Triangle"></A>
typedef <A HREF="#PolygonTraits">Traits</A>::Triangle
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Triangle;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    <A NAME="Typedef_Iso_rectangle"></A>
typedef <A HREF="#PolygonTraits">Traits</A>::Iso_rectangle
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Iso_rectangle;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        </TABLE><!3>

<P>

The following types denote iterators that allow to traverse the
vertices and edges of a polygon. Since it is questionable whether a
polygon should be viewed as a circular or as a linear data structure
both circulators and iterators are defined. The circulators and
iterators with `const' in their name are non-mutable, the others are
mutable. The iterator category is in all cases bidirectional, except
for <I>Vertex_iterator</I>, which has the same iterator category as
<I>Container::iterator</I>. N.B. As mentioned before, in fact all of
them should have the same iterator category as
<I>Container::iterator</I>. This will be changed when iterator traits
become available.
<P>

For vertices we define
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex_circulator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::Vertex_circulator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex_const_circulator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::Vertex_const_circulator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex_iterator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::Vertex_iterator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex_const_iterator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::Vertex_const_iterator
        </I>
        </TD></TR>
    
    <P>
        </TABLE><!2>

<P>

Their value type is <I>Point</I>.
<P>

For edges we define
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Edge_const_circulator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::Edge_const_circulator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Edge_const_iterator"></A>
<A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;::Edge_const_iterator
        </I>
        </TD></TR>
    
    <P>
        </TABLE><!2>

<P>

Their value type is <I>Segment</I>.
<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    template &lt;class InputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt; p ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     InputIterator last);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with vertices from the sequence
    defined by the range <I>[first,last)</I>.
    <BR><STRONG>Precondition: </STRONG>The value type of <I>first</I>
    and <I>last</I> is <I>Point</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt; p ( int n);
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with <I>n</I> uninitialized vertices.
    This constructor is supplied for efficiency reasons.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt; p (  Point q);
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with one vertex <I>q</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt; p (  Segment s);
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with two vertices from segment
    <I>s</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt; p (  Triangle t);
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with three vertices from triangle
    <I>t</I>, with the same orientation.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt; p ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Iso_rectangle rectangle r);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a polygon <I>p</I> with four vertices from rectangle
    <I>r</I>, having counterclockwise orientation.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>


<H3> Operations</H3>
<P>

The following operations allow to modify a polygon.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.insert ( Vertex_iterator i,  Point q)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the vertex <I>q</I> before <I>i</I>. The return value
    points to the inserted vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    p.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_iterator i, <BR>
     InputIterator first, <BR>
     InputIterator last)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the vertices in the range <I>[first, last)</I> before
    <I>i</I>. <BR><STRONG>Precondition: </STRONG>The value type of
    <I>first</I> and <I>last</I> is <I>Point</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.append (  Point q)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Has the same semantics as <I>p.insert(p.end(), q)</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.erase ( Vertex_iterator i)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Erases the vertex pointed to by <I>i</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    p.erase ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    Vertex_iterator first, <BR>
     Vertex_iterator last)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Erases the vertices in the range <I>[first, last)</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.reverse_orientation ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Reverses the orientation of the polygon. The vertex pointed to by
    <I>p.vertices_begin()</I> remains the same.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Traversal of a polygon</H3>
<P>

The following methods of the class <I><A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> return
circulators and iterators that allow to traverse the vertices and
edges.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_circulator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.vertices_circulator ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a mutable circulator that allows to traverse the vertices
    of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_const_circulator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.vertices_circulator ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable circulator that allows to traverse the
    vertices of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.vertices_begin ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a mutable iterator that allows to traverse the vertices of
    the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.vertices_end ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_const_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.vertices_begin ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable iterator that allows to traverse the vertices
    of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_const_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.vertices_end ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Edge_const_circulator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.edges_circulator ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable circulator that allows to traverse the edges
    of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Edge_const_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.edges_begin ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a non-mutable iterator that allows to traverse the edges of
    the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Edge_const_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.edges_end ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Predicates</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.is_simple ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns whether <I>p</I> is a simple polygon.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.is_convex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns whether <I>p</I> is convex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    CGAL_Orientation
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.orientation ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the orientation of <I>p</I>. If the number of vertices
    <MATH></MATH><I>p.size()</I><MATH> &lt; 3</MATH> then
    <I>CGAL_COLLINEAR</I> is returned.
    <BR><STRONG>Precondition: </STRONG><I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    CGAL_Oriented_side
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.oriented_side (  Point q)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <I>CGAL_POSITIVE_SIDE</I>, <I>CGAL_NEGATIVE_SIDE</I>, or
    <I>CGAL_ON_ORIENTED_BOUNDARY</I>, depending on where point <I>q</I>
    is. <BR><STRONG>Precondition: </STRONG><I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    CGAL_Bounded_side
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.bounded_side (  Point q)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the symbolic constant <I>CGAL_ON_BOUNDED_SIDE</I>,
    <I>CGAL_ON_BOUNDARY</I> or <I>CGAL_ON_UNBOUNDED_SIDE</I>, depending
    on where point <I>q</I> is. <BR><STRONG>Precondition: </STRONG>
    <I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    CGAL_Bbox_2
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.bbox ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the smallest bounding box containing <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="#PolygonTraits">Traits</A>::FT
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.area ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the area of the polygon <I>p</I>.
    <BR><STRONG>Precondition: </STRONG><I>p.is_simple()</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.left_vertex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the leftmost vertex of the polygon <I>p</I> with the
    smallest <I>y</I>-coordinate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.right_vertex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the rightmost vertex of the polygon <I>p</I> with the
    largest <I>y</I>-coordinate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.top_vertex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns topmost vertex of the polygon <I>p</I> with the largest
    <I>x</I>-coordinate.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.bottom_vertex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the bottommost vertex of the polygon <I>p</I> with the
    smallest <I>x</I>-coordinate.
        </TD></TR>
        </TABLE><!3>

<P>

For convenience we provide the following boolean functions:
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.is_counterclockwise_oriented ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.is_clockwise_oriented ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.is_collinear_oriented ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.has_on_positive_side (  Point q)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.has_on_negative_side (  Point q)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.has_on_boundary (  Point q)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.has_on_bounded_side (  Point q)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    p.has_on_unbounded_side (  Point q)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        </TABLE><!3>

<P>

<H3> Miscellaneous</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.size ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the number of vertices of the polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.is_empty ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <MATH></MATH><I>p.size()</I><MATH> == 0</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
     Container
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    p.container ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a const reference to the sequence of vertices of the
    polygon <I>p</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container&gt;
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    p.transform ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Aff_transformation_2&lt;<A HREF="#PolygonTraits">Traits</A>&gt; t)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the polygon obtained by applying the transformation
    <I>t</I> to the vertices of <I>p</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<I>template &lt;class <A HREF="#PolygonTraits">Traits</A>, class Container1, class Container2&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_bool_operator==6const_CGAL_Polygon_26Traits+Container19__p1+___const_CGAL_Polygon_26Traits+Container29__p29;"></A>
bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
      <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container1&gt; p1 ==  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container2&gt; p2
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Test for equality: two polygons are equal iff there exists a cyclic
    permutation of the vertices of <I>p2</I> such that they are equal
    to the vertices of <I>p1</I>. Note that the template argument
    <I>Container</I> of <I>p1</I> and <I>p2</I> may be different.
        </TD></TR>
        </TABLE><!3>

<P>

<I>template &lt;class <A HREF="#PolygonTraits">Traits</A>, class Container1, class Container2&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_bool_operator!=6const_CGAL_Polygon_26Traits+Container19__p1+___const_CGAL_Polygon_26Traits+Container29__p29;"></A>
bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
      <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container1&gt; p1 !=  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>,Container2&gt; p2
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Test for inequality.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> I/O</H3>
<P>

The I/O operators are defined for <I>iostream</I>, and for the window
stream provided by CGAL. The format for the iostream is an internal
format.
<P>

<I>#include &lt;CGAL/IO/ostream_2.h&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_ostream__operator666ostream__os+_const_CGAL_Polygon_26Traits9__p9;"></A>
ostream&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
     ostream&amp; os &lt;&lt;  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2&lt;Traits&gt;</A> p
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the polygon <I>p</I> into the stream <I>os</I>.
    <BR><STRONG>Precondition: </STRONG>The insert operator is defined
    for class <I>Point</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_istream__operator996istream__is+__const_CGAL_Polygon_26Traits9__p9;"></A>
istream&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
     istream&amp; is &gt;&gt;  <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2&lt;Traits&gt;</A> p
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Reads a polygon from stream <I>is</I> and assigns it to <I>p</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Example</H3>The following code fragment creates a polygon and
checks if it is convex.
<P>

<PRE>

typedef CGAL_Cartesian&lt;double&gt; <A HREF="#PolygonTraits">Traits</A>;
typedef CGAL_Point_2&lt;<A HREF="#PolygonTraits">Traits</A>&gt; Point;
typedef <A HREF="CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#PolygonTraits">Traits</A>, list&lt;Point&gt; &gt; Polygon;

{
  Polygon p;

  while(cin) {
    Point q;
    cin &gt;&gt; q;
    p.append(q);
  }

  cout &lt;&lt; &quot;The polygon you entered is &quot;;
  if (!p.is_convex())
    cout &lt;&lt; &quot;not &quot;;
  cout &lt;&lt; &quot;convex.&quot;;
}

</PRE>
<P>

<H3> Implementation</H3>
<P>

The methods <I>is_simple</I>, <I>is_convex</I>, <I>orientation</I>,
<I>oriented_side</I>, <I>bounded_side</I>, <I>bbox</I>, <I>area</I>,
<I>left_vertex</I>, <I>right_vertex</I>, <I>top_vertex</I> and
<I>bottom_vertex</I> are all implemented using the functions on
sequences of 2D points described below. There you can find information
on the algorithms that were used and their complexity.
<P>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Polygon.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
