<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Bops.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Bops.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<H1>Boolean Operations</H1>
 <A NAME="Bops"></A><P>

<A NAME="Section_1"></A>
<H2>Introduction</H2>

CGAL provides boolean operations for polytopes in the 2-dimensional
Euclidean space. The functions described in
the next section apply to two simple
polygons. Both boundary and interior are considered as part of a polygon.
Boolean operations on polygons are therefore not limited to operations
on the boundary of the objects.
The functions described in this chapter
allow to perform the purely geometric operations
intersection, union, and difference on two polygons
in the 2-dimensional Euclidean space. They should not be confused with
the regularised operations in the context of solid modeling.<P>

A clear distinction should be made between two sorts of functions
described in this chapter. Some operations perform an intersection
test without computing the actual result of the intersection.
Other operations perform a boolean operation (intersection,
union, or difference): they explicitly compute and return the result
of the boolean operation on two polygons.<P>

Note that particular classes of polytopes are not closed under
boolean operations. For instance, the union of two simple polygons is
not necessarily a simple polygon, or the intersection of two triangles
is not necessarily a triangle.<P>

All functions described below are template functions. Some are
parametrized only by the number type (denoted by <I>R</I>),
others are parameterized with a traits class (denoted by
<I><A HREF="#B_ops_Predef">Traits</A></I>).
Where we use polygons of type
<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> the functions are parameterized by a
number type (denoted by <I>R</I>) and container (denoted by
<I>Container</I>), as it is the case for <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
For more details we refer to the description of <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
In a boolean operations traits
class some types and functions needed for the computation of
boolean operations are defined. We provide a default version of the
traits class for boolean operations, which we describe in detail below.
So the user need not (but can if desired) provide ones own boolean operations
traits class.<P>

Note: the current version of boolean operations is robust only when a
representation with exact arithmetic, for instance
<I>CGAL_Cartesian&lt;CGAL_Rational&gt;</I>, is used.
In nearly degenerate configurations, correct results are not guaranteed
when floating point numbers are used.<P>

<A NAME="Section_2"></A>
<H2>Boolean Operations on Polygons</H2>

<H3>Definition</H3>Boolean operations are provided for two simple polygons (for the
definition of simple polygons, see Chapter <A HREF="../Polygon/Chapter_Polygon.html#Polygon"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>).
A triangle and an iso-oriented rectangle clearly are special cases of
simple polygons.<P>

A polygon on which the boolean operations can be performed
can be stored in one of the following CGAL-objects:
<UL>
<LI><I>CGAL_Triangle_2</I>, a 2-dimensional triangle.
<LI><I>CGAL_Iso_rectangle_2</I>, a 2-dimensional iso-oriented rectangle.
<LI><I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>, a 2-dimensional polygon.
It must be simple, but not necessarily convex.
So, non-adjacent edges do not intersect and there are no holes in the polygon.
The vertices of such a polygon must be ordered in counterclockwise order.
</UL><P>

We consider polygons as being closed and filled objects, i.e. we consider
both its boundary and its interior.
The edge cycle of the polygon will be referred to explicitly as the polygon
boundary.
For boolean operations, the distinction between the interior and
the exterior of a polygon is determined by the order of its vertices.<P>

The result of an intersection test is one of the boolean values true or false.
The result of an intersection, union, or difference can be empty, a single
object, or several objects.
An object can be a point, a segment, a triangle, an iso-oriented rectangle,
a polygon, or a polygon with one or several holes.<P>

There, where the result cannot be more than one object (in the case of the
intersection of two triangles, and the intersection of two iso-rectangles),
the corresponding function returns an iterator of a possibly empty container.
In all other cases the functions return an iterator referring to a
sequence of objects.
Note that whenever we refer to a `sequence' of objects we actually mean a
collection of objects independent of the way in which they are stored.
The user can define the type of sequence in which the output will be stored
through the template parameter <I>OutputIterator</I>, see below for further
details.<P>

Vertices of input polygons must be ordered counterclockwise.
Vertices of output polygons are ordered counterclockwise.
However, vertices of polygons representing holes (as part of
the output) are ordered clockwise.
For instance, if the result of a boolean operation is a polygon with some
holes, then this result will be represented as a sequence of polygons,
where the first one
representing the outer boundary of the contour is ordered counterclockwise
and the following ones representing the inner contours (holes) are ordered
clockwise.<P>

For two simple polygons <MATH>A</MATH> and <MATH>B</MATH>, the following operations are defined:
<DL><P>

<LI>[Intersection test] of two polygons (<I>CGAL_do_intersect(A,B)</I>).
This checks if the two polygons <MATH>A</MATH> and <MATH>B</MATH> do intersect, without computing
the intersection area.
It returns <I>true</I> if the polygons <MATH>A</MATH> and <MATH>B</MATH> do intersect,
otherwise <I>false</I> will be returned.<P>

<LI>[Intersection] of two polygons (<I>CGAL_intersection(A,B)</I>).
It performs the operation <MATH>C:=A \cap B</MATH> and returns the result <MATH>C</MATH>
as a maybe empty sequence of objects (<I>CGAL_Object</I>),
i.e. a sequence containing objects of type <I>CGAL_Point_2</I>,
<I>CGAL_Segment_2</I>, and <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
When <MATH>A</MATH> and <MATH>B</MATH> are both triangles (<I>CGAL_Triangle_2</I>)
or when <MATH>A</MATH> and <MATH>B</MATH> are both iso-oriented rectangles
(<I>CGAL_Iso_rectangle</I>) the result can only be empty or a
single object <I>CGAL_Object</I> rather than a sequence of objects.<P>

<LI>[Union] of two polygons ( <I>CGAL_union(A,B)</I>).
It performs the operation <MATH>C:=A \cup B</MATH> and returns the result <MATH>C</MATH> as
a maybe empty sequence of objects (<I>CGAL_Object</I>), i.e. a
sequence containing objects of type <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>. The
first polygon gives the counterclockwise-ordered outer boundary of
the contour of the union and the following polygons (if existing)
define the inner clockwise-ordered contours (the holes). If <MATH>A
    \cap B</MATH> is exactly one point (a vertex of at least one of the two
input polygons), the union returns one non-simple polygon. If <MATH>A
    \cap B</MATH> is empty, then a sequence will be returned consisting of <MATH>A</MATH>
and <MATH>B</MATH> both represented as polygons with counterclockwise ordered
contour.<P>

<LI>[Difference] of two polygons (<I>CGAL_difference(A,B)</I>).
This performs the operation <MATH>C:=A \setminus interior(B)</MATH> and returns the
result <MATH>C</MATH> as a maybe empty sequence of objects (<I>CGAL_Object</I>),
i.e. a sequence containing objects of type <I>CGAL_Point_2</I>,
<I>CGAL_Segment_2</I>, and <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>.
If <MATH>A \cap B</MATH> is empty then <MATH>A</MATH> will be returned.
If <MATH>A \cap B = A</MATH> (i.e. <MATH>A \subseteq B</MATH>),
then the empty sequence will be returned.
If <MATH>A \cap B = B</MATH> (i.e. <MATH>B \subseteq A</MATH>, that means <MATH>B</MATH> is a hole of <MATH>A</MATH>),
then a sequence containing (two) objects <MATH>(A,B)</MATH> of type
<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> will be returned, where the second one
represents a hole and has clockwise order.
</DL><P>

<H3>Parameters</H3>The boolean operations described in the following have one or more
template parameters. The number of template parameters as well as the
type of template parameters differs for the different operations.
Here we give a list of all template parameters which might occur
and some explanation of where they stand for.<P>

A value for the template parameter <I>R</I> instantiates the
representation type in which the input objects are defined and the boolean
operations are computed.<P>

The template parameter <I>Container</I> occurs where polygons
(<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>) are used as input.
The value for template parameter <I>Container</I> instatiates the
type of the container in which the vertices of the polygon are stored.<P>

Some operations have template parameter <I>InputIterator</I>.
A value for the template parameter <I>InputIterator</I> is an
iterator to the container in which the input polygon is stored.
A value could be an <EM>STL list</EM> or <I>LEDA list</I> iterator, for
example.<P>

Also the output sometimes is stored in a sequence.
A value for the template parameter <I>OutputIterator</I> instantiates an
iterator to a container in which the output will be returned and defines the
type of such container.
A value could again be an <EM>STL list</EM> or <I>LEDA list</I> iterator,
for example.<P>

A value for the template parameter <I><A HREF="#B_ops_Predef">Traits</A></I> is a boolean operations
traits class.
We provide the user a default boolean operations traits class for convenience,
but the user can define own traits classes as well.
For more details about boolean operations traits classes look at the table
below, and in the section on the default traits class (<A HREF="Chapter_Bops.html#B_ops_Predef"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>).<P>

<H3>Types</H3>A <I>list&lt;element_type&gt;</I> denotes the <EM>STL list container</EM>,
which implements a double connected list (include file: <I>list.h</I>).<P>

The number type <I>R</I> must be instantiated by the user,
for instance as <I>CGAL_Cartesian&lt;CGAL_Rational&gt;</I>.<P>

The container type <I>Container</I> for a polygon.
The user must pre-instantiate this, for instance by
<I>list&lt;CGAL_Point_2&lt;CGAL_Cartesian&lt;CGAL_Rational&gt; &gt; &gt;</I>.<P>

The type of the iterator pointing to the container in which the
input is stored: <I>InputIterator</I>. The user must
pre-instantiate this for instance by
<I>list&lt;CGAL_Point_2&lt;CGAL_Cartesian&lt;CGAL_Rational&gt; &gt; &gt;::Iterator</I>.<P>

The type of the iterator pointing to the container in which the output
is stored: <I>OutputIterator</I>. The user must
pre-instantiate this for instance by
<I>list&lt;CGAL_Point_2&lt;CGAL_Cartesian&lt;CGAL_Rational&gt; &gt; &gt;::Iterator</I>.<P>

In the table below we describe the types which are defined in a
boolean operations traits class. Such a traits class contains the most
important type definitions used in the algorithms. These types can be
changed by the user, if needed. In the first column of the table the
types present in a boolean operations traits class are listed. In the
second column a brief description of the respective types is given,
and in the third column the default value for each of the types in
given as they are defined in the standard boolean operations traits class.
For more details on the standard boolean operations traits class we
refer to Section <A HREF="Chapter_Bops.html#B_ops_Predef"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.
\begincenter
<TABLE><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP> \hline
type </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> description </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> standard </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline \hline
<I><A HREF="#B_ops_Predef">Traits</A>::R</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> Representation class </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>CGAL_Cartesian&lt;CGAL_Rational&gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="#B_ops_Predef">Traits</A>::Point</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D point </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> <I>CGAL_Point_2&lt;<A HREF="#B_ops_Predef">Traits</A>::R&gt; &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="#B_ops_Predef">Traits</A>::Segment</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D segment </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>CGAL_Segment_2&lt;<A HREF="#B_ops_Predef">Traits</A>::R&gt; &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="#B_ops_Predef">Traits</A>::Triangle</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D triangle </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>CGAL_Triangle_2&lt;<A HREF="#B_ops_Predef">Traits</A>::R &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="#B_ops_Predef">Traits</A>::Iso_rectangle</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D iso-oriented rectangle </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>CGAL_Iso_rectangle_2&lt;<A HREF="#B_ops_Predef">Traits</A>::R &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="#B_ops_Predef">Traits</A>::Container</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> polygon container type </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I>list&lt;CGAL_Point_2&lt;<A HREF="#B_ops_Predef">Traits</A>::R&gt; &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline
<I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP> 2D polygon </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;<A HREF="#B_ops_Predef">Traits</A>::R, <A HREF="#B_ops_Predef">Traits</A>::Container &gt;</I> </TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>\hline \hline
</TD></TR></TABLE>
\endcenter<P>

<H3>Operations</H3><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_bool_CGAL_do_intersect6const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B9;"></A>
bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the triangles <MATH>A</MATH> and
    <MATH>B</MATH> do intersect.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_bool_CGAL_do_intersect6const_CGAL_Iso_rectangle_26R9__A+_const_CGAL_Iso_rectangle_26R9__B9;"></A>
bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the iso-oriented rectangles <MATH>A</MATH>
    and <MATH>B</MATH> do intersect.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, Container&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_bool_CGAL_do_intersect6const__CGAL_Polygon_26R+Container9__A+_const__CGAL_Polygon_26R+Container9__B9;"></A>
bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; B)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I> if the polygons <MATH>A</MATH> and
    <MATH>B</MATH> do intersect.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;InputIterator, <A HREF="#B_ops_Predef">Traits</A>&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_bool_CGAL_do_intersect6_InputIterator_Afirst+_InputIterator_Alast+__InputIterator_Bfirst+_InputIterator_Blast+__Traits__9;"></A>
bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_do_intersect ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator Afirst, <BR>
     InputIterator Alast, <BR>
     InputIterator Bfirst, <BR>
     InputIterator Blast, <BR>
     <A HREF="#B_ops_Predef">Traits</A> &amp;)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    with polygon <I>A</I> of type <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the
    vertices of type <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range
    <MATH>[Afirst,Alast)</MATH> and for polygon <I>B</I> of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the vertices of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>. It
    returns <I>true</I> if the polygons <MATH>A</MATH> and
    <MATH>B</MATH> do intersect.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_intersection6const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B+__OutputIterator_object_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B, <BR>
     OutputIterator object_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the intersection of two triangles and places the resulting
    object of type <I>CGAL_Object</I> in a container of the type
    corresponding to the output iterator (<I>OutputIterator</I>)
    <I>object_it</I> which points to the resulting object. The function
    returns an output iterator (of type <I>OutputIterator</I>) pointing
    to the position beyond the end of the container. The resulting
    object is either a point (<I>CGAL_Point_2</I>), or a segment (
    <I>CGAL_Segment_2</I>), or a triangle (<I>CGAL_Triangle_2</I>), or
    a convex polygon (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> with
    <I>is_convex() == true</I>). In case of an empty intersection, no
    object is put into the container.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_intersection6const__CGAL_Iso_rectangle_26R9__A+_const_CGAL_Iso_rectangle_26R9__B+__OutputIterator_object_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B, <BR>
     OutputIterator object_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the intersection of two iso-oriented rectangles and places
    the resulting object of type <I>CGAL_Object</I> in a container of
    the type corresponding to the output iterator (
    <I>OutputIterator</I>) <I>object_it</I> which points to the
    resulting object. The function returns an output iterator (of type
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the container. The resulting object is either a point (
    <I>CGAL_Point_2</I>), or a segment (<I>CGAL_Segment_2</I>), or a
    triangle (<I>CGAL_Triangle_2</I>), or a convex polygon (
    <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I> with <I>is_convex() == true</I>). In case of
    an empty intersection, no object is put into the container.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, Container, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_intersection6const__CGAL_Polygon_26R+Container9__A+_const__CGAL_Polygon_26R+Container9__B+__OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the intersection of two simple polygons and places all
    resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of the type corresponding to the
    type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>) which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. In case of an empty intersection, no objects are put
    into the sequence.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;InputIterator, OutputIterator, <A HREF="#B_ops_Predef">Traits</A>&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_intersection6_InputIterator_Afirst+_InputIterator_Alast+__InputIterator_Bfirst+_InputIterator_Blast+__Traits__+___OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_intersection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator Afirst, <BR>
     InputIterator Alast, <BR>
     InputIterator Bfirst, <BR>
     InputIterator Blast, <BR>
     <A HREF="#B_ops_Predef">Traits</A> &amp;, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    with polygon <I>A</I> of type <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the
    vertices of type <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range
    <MATH>[Afirst,Alast)</MATH> and with polygon <I>B</I> of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the vertices of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>.
    Computes the intersection of two simple polygons and places all
    resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of the type corresponding to the
    type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. In case of an empty intersection, no objects are put
    into the sequence. If an object in the sequence to which the output
    iterator refers is a polygon, then this polygon is of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> with vertices of type <I><A HREF="#B_ops_Predef">Traits</A>::Point</I>
    and container <I><A HREF="#B_ops_Predef">Traits</A>::Container</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_union6const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B+_OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the union of two triangles and places all resulting
    objects as a sequence of objects of type <I>CGAL_Object</I> in a
    container of the type corresponding to the type of output iterator
    <I>list_of_objects_it</I> (<I>OutputIterator</I>), which points to
    the first object in the sequence. The function returns an output
    iterator (<I>OutputIterator</I>) pointing to the position beyond
    the end of the sequence. The sequence may contain a triangle (
    <I>CGAL_Triangle_2</I>), a simple polygon (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>),
    or two triangles (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>, when <MATH>A \cap B</MATH>
    is empty).
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_union6const_CGAL_Iso_rectangle_26R9___A+_const_CGAL_Iso_rectangle_26R9__B+_OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the union of two iso-oriented rectangles and places all
    resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of the type corresponding to the
    type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. The sequence may contain an iso-oriented rectangle (
    <I>CGAL_Iso_rectangle_2</I>), a simple polygon (
    <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>), or two iso-oriented rectangles (
    <I>CGAL_Iso_rectangle_2</I>, when <MATH>A \cap B</MATH> is empty).
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, Container, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_union6const_CGAL_Polygon_26R+Container9__A+_const_CGAL_Polygon_26R+Container9__B+_OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the union of two simple polygons and places all resulting
    objects as a sequence of objects of type <I>CGAL_Object</I> in a
    container of the type corresponding to the type of output iterator
    <I>list_of_objects_it</I> (<I>OutputIterator</I>), which points to
    the first object in the sequence. The function returns an output
    iterator (<I>OutputIterator</I>) pointing to the position beyond
    the end of the sequence.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;InputIterator, OutputIterator, <A HREF="#B_ops_Predef">Traits</A>&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_union6InputIterator_Afirst+_InputIterator_Alast+__InputIterator_Bfirst+_InputIterator_Blast+___Traits__+___OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_union ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator Afirst, <BR>
     InputIterator Alast, <BR>
     InputIterator Bfirst, <BR>
     InputIterator Blast, <BR>
     <A HREF="#B_ops_Predef">Traits</A> &amp;, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    with polygon <I>A</I> of type <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the
    vertices of type <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range
    <MATH>[Afirst,Alast)</MATH> and with polygon <I>B</I> of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the vertices of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>.
    Computes the union of two simple polygons (<MATH>A \cup B</MATH>)
    and places all resulting objects as a sequence of objects of type
    <I>CGAL_Object</I> in a container of the type corresponding to the
    type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. It returns an output iterator (<I>OutputIterator</I>)
    pointing to position beyond the end of the sequence. If an object
    in the sequence to which the output iterator refers is a polygon,
    then this polygon is of type <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> with vertices
    of type <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> and container of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Container</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_difference6const_CGAL_Triangle_26R9__A+_const_CGAL_Triangle_26R9__B+__OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Triangle_2&lt;R&gt; A, <BR>
     CGAL_Triangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Computes the difference (<MATH>A \setminus B</MATH>) of two
    triangles and places all resulting objects as a sequence of objects
    of type <I>CGAL_Object</I> in a container of the type corresponding
    to the type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. It returns an output iterator (<I>OutputIterator</I>)
    pointing to the position beyond the end of the sequence. Each
    object in the sequence is either a triangle (<I>CGAL_Triangle_2</I>
    ), or a simple polygon (<I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A></I>). If
    <MATH>B \subseteq A</MATH>, no object will be put into the
    container.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_difference6const_CGAL_Iso_rectangle_26R9__A+_const_CGAL_Iso_rectangle_26R9__B+__OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     CGAL_Iso_rectangle_2&lt;R&gt; A, <BR>
     CGAL_Iso_rectangle_2&lt;R&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the difference (<MATH>A \setminus B</MATH>) of two
    iso-oriented rectangles, and places the resulting objects of type
    <I>CGAL_Object</I> in a container of the type corresponding to the
    type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. Each object is either a simple polygon (
    <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>)</I> or an iso-oriented rectangle (
    <I>CGAL_Iso_rectangle_2</I>). If <MATH>B \subseteq A</MATH>, no
    object will be put into the output container.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;R, Container, OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_difference6const_CGAL_Polygon_26R+Container9__A+_const__CGAL_Polygon_26R+Container9__B+__OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; A, <BR>
     <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R,Container&gt; B, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    computes the difference of two simple polygons
    (<MATH>A \setminus B</MATH>) and places the resulting object of
    type <I>CGAL_Object</I> in a container of type corresponding to the
    type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. The difference can be empty, in which case no object
    will be put in the container.
    <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;InputIterator, OutputIterator, <A HREF="#B_ops_Predef">Traits</A>&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_difference6InputIterator_Afirst+_InputIterator_Alast+__InputIterator_Bfirst+_InputIterator_Blast+___Traits__+___OutputIterator_list_of_objects_it9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_difference ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator Afirst, <BR>
     InputIterator Alast, <BR>
     InputIterator Bfirst, <BR>
     InputIterator Blast, <BR>
     <A HREF="#B_ops_Predef">Traits</A> &amp;, <BR>
     OutputIterator list_of_objects_it)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    with polygon <I>A</I> of type <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the
    vertices of type <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range
    <MATH>[Afirst,Alast)</MATH> and with polygon <I>B</I> of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> defined by the vertices of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> in the range <MATH>[Bfirst,Blast)</MATH>.
    Computes the difference of two simple polygons
    (<MATH>A \setminus B</MATH>) and places all resulting objects of
    type <I>CGAL_Object</I> in a container of the type corresponding to
    the type of output iterator <I>list_of_objects_it</I> (
    <I>OutputIterator</I>), which points to the first object in the
    sequence. The function returns an output iterator (
    <I>OutputIterator</I>) pointing to the position beyond the end of
    the sequence. The difference can be empty in which case no object
    will be put in the container. If an object in the sequence to which
    the output iterator refers is a polygon, then this polygon is of
    type <I><A HREF="#B_ops_Predef">Traits</A>::Polygon</I> with vertices of type
    <I><A HREF="#B_ops_Predef">Traits</A>::Point</I> and container of type <I><A HREF="#B_ops_Predef">Traits</A>::Container</I>
    . <BR><STRONG>Precondition: </STRONG><MATH>A</MATH> and
    <MATH>B</MATH> are simple polygons, their vertices are in
    counterclockwise order.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Example</H3>Principally, Boolean operations work as follows, illustrated by the example
of intersecting two polygons:
<OL><P>

<LI>To use the predefined boolean operations traits class <I><A HREF="#B_ops_Predef">Traits</A></I>,
include the file <I>bops_standard_traits.h</I>.
For details see Section <A HREF="Chapter_Bops.html#B_ops_Predef"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.<P>

<LI>Instantiation of Polygons (triangles, iso oriented rectangles,
simple polygons). Do not forget to include <I>list.h</I> of the
<EM>STL library</EM>.<P>

<LI>Performing the boolean operation:<P>

<PRE>
  CGAL_intersection(A.begin(), A.end(), B.begin(), B.end(), trcls, bopsOutIt);
</PRE><P>

<LI>Taking the result of the operation:<P>

The result consists of a sequence of points, segments, and simple
polygons. Hence,
the user has to check what type of element has to be performed for further
computations.<P>

</OL><P>

A full example (note: here the non-exact number type
<I>CGAL_Quotient&lt;int&gt;</I> is used):<P>

<PRE>
#ifdef __GNUC__
#include &lt;typeinfo&gt;
#endif
#include &lt;iostream.h&gt;

#include &lt;CGAL/Homogeneous.h&gt;
#include &lt;CGAL/Cartesian.h&gt;
#include &lt;CGAL/basic.h&gt;

#include &lt;list.h&gt;
#include &lt;CGAL/boolean_operations_2.h&gt;


typedef CGAL_Quotient&lt;int&gt; TestNum;
//typedef CGAL_Cartesian&lt;TestNum&gt;              R_type;
typedef CGAL_Homogeneous&lt;TestNum&gt;              R_type;
typedef CGAL_Point_2&lt;R_type&gt;                     Point_2;
typedef CGAL_Segment_2&lt;R_type&gt;                  Segment_2;
typedef list&lt; Point_2 &gt;                            Container;
typedef <A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt; R_type, Container &gt;  Polygon_2;


typedef vector&lt;Point_2&gt;                           Input_container;

int example_intersection(
  const Input_container&amp; container_A,
  const Input_container&amp; container_B
) {
  /* possible results */
  Point_2   point;
  Segment_2 segment;
  Polygon_2 polygon;

  /* instantiate Polygon A and B with containers */
  Polygon_2 A(container_A.begin(), container_A.end());
  Polygon_2 B(container_B.begin(), container_B.end());

  /* declaration of the result container */
  list&lt;CGAL_Object&gt; result;

  /* performing intersection of A and B */
  CGAL_intersection(A, B, back_inserter(result));
  
  /* print out the result */
  cout &lt;&lt; &quot;size=&quot; &lt;&lt; result.size() &lt;&lt; endl;

  /* declaration of an iterator on the result container */
  list&lt;CGAL_Object&gt;::const_iterator it;
  for( it= result.begin(); it != result.end(); it++) {
    if( CGAL_assign( polygon, *it) ) {
      cout &lt;&lt; polygon &lt;&lt; endl;               /* polygon detected */
    }
    else if( CGAL_assign( segment, *it) ) {
      cout &lt;&lt; segment &lt;&lt; endl;               /* segment detected */
    }
    else if( CGAL_assign( point, *it) )  {  
      cout &lt;&lt; point &lt;&lt; endl;                     /* point detected */
    }
    else {
      cout &lt;&lt; &quot;undefined object &quot; &lt;&lt; endl;   /* nothing detected */
    }
  }
  
  /* return size of result */
  return result.size();
}



int main(void)
{
  Input_container container_A(6), container_B(4);

  container_A[0]= Point_2(2,4);
  container_A[1]= Point_2(0,3);
  container_A[2]= Point_2(1,1);
  container_A[3]= Point_2(2,3);
  container_A[4]= Point_2(3,1);
  container_A[5]= Point_2(4,3);
  container_B[0]= Point_2(0,2);
  container_B[1]= Point_2(0,0);
  container_B[2]= Point_2(5,0);
  container_B[3]= Point_2(5,2);

  example_intersection( container_A, container_B);
  return 0;
}

</PRE><P>

A full example for more advanced use:<P>

<PRE>

#include &lt;CGAL/bops_standard_traits_2.h&gt;

typedef CGAL_Rational aNT;
typedef CGAL_Cartesian&lt;aNT&gt; anR;
typedef bops_standard_traits_2&lt;anR&gt; TraitsCls;

TraitsCls::Point point;
TraitsCls::Segment segment;
TraitsCls::Polygon polygon;
CGAL_Object obj;
TraitsCls trcls;

Polygon A, B;
// instantiate A and B:
// ..

// apply a boolean operation:
list&lt;CGAL_Object&gt; B_ops_result; 
insert_iterator&lt; list&lt;CGAL_Object&gt; &gt; 
                               bopsOutIt(B_ops_result,B_ops_result.begin());

CGAL_intersection(A.begin(), A.end(), B.begin(), B.end(), trcls, bopsOutIt);

// do something with the result:
// ..

</PRE><P>

From this example can be seen how a boolean operation could be applied in
a safe and practical way.<P>

<H3>Implementation</H3>The algorithms for boolean operations for two polygons are (efficient)
specialized methods for specific objects.
Depending on the polygon type we switch internally to the best suited
routines. For instance, for two triangles we switch to a more
efficient algorithm than the general one on polygons.<P>

The memory consumption is <MATH>O(n)</MATH>
(where <MATH>n</MATH> is the whole number of vertices of the input polygons).
The time complexity is <MATH>O(n<SUP>2</SUP>)</MATH> for simple polygons,
and <MATH>O(1)</MATH> for triangles and iso-oriented rectangles.<P>

Note: As mentioned above,
the result is sometimes returned as iterators pointing to
a <I>list&lt;CGAL_Object&gt;</I>, where <I>list</I> is
a <EM>STL list container</EM>, which implements a double
connected list (include file: <I>list.h</I>).<P>

<A NAME="Section_3"></A>
<H2>Predefined Boolean Operations Traits Class <A NAME="B_ops_Predef"></A></H2>
<P>

Since all geometric objects on which boolean operations act are
parameterized with a template for the number type, also the
predefined boolean operations traits class is a template class with
a parameter for the number type <I>_R</I>. The predefined boolean
operations traits class is called
<I>bops_standard_traits_2&lt;_R&gt;</I>.<P>

<H3>Types</H3><P>

typedef <I>_R R</I>;<BR>The number type over which the computations are performed.<P>

typedef <I>CGAL_Point_2&lt;R&gt; Point</I>;<BR>The type of points representing the vertices of triangles, iso-oriented
rectangles, polygons, and of the types point and segment which occur as
possible types of the result of boolean operations.<P>

typedef <I>list&lt;Point&gt; Container</I>;<BR>The container in which points of type <I>Point</I> are stored for further
use in the polygons on which boolean operations are to be performed.<P>

typedef <I>CGAL_Segment_2&lt;R&gt; Segment</I>;<BR>The type of return values representing a line segment.<P>

typedef <I>CGAL_Triangle_2&lt;R&gt; Triangle</I>;<BR>The type of triangles on which boolean operations can be performed.<P>

typedef <I>CGAL_Iso_rectangle_2&lt;R&gt; Iso_rectangle</I>;<BR>The type of iso-oriented rectangles on which boolean operations can be
performed.<P>

typedef <I><A HREF="../Polygon/CGAL_Polygon_2.html#Cross_link_anchor_0">CGAL_Polygon_2</A>&lt;R, Container &gt; Polygon</I>;<BR>The type of polygons on which boolean operations can be performed.<P>

typedef <I>CGAL_Direction_2&lt;R&gt; Direction</I>;<BR>A type used internally in the computation of boolean operations.<P>

<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Bops.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
