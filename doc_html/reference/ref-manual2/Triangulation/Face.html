<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Triangulation.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: Face</TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Triangulation.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_8"></A>

<A NAME="Cross_link_anchor_8"></A>

<P>

<H3>Definition</H3>A class must fulfill the following requirements in
order that it can be used as a face of a triangulation.
<P>

A face contains pointers to three vertices whose order defines the
counterclockwise order. It further contains three pointers to neighbor
faces.
<P>

The vertices and neighbors are indexed 0,1, and 2. Neighbor
<MATH>i</MATH> lies opposite to vertex i.
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex"></A>
<A HREF="Face.html#Cross_link_anchor_8">Face</A>::<A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> type.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3> Creation</H3>
<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>For
user defined triangulation algorithms, faces need to be explicitly
constructed and linked to their neighbors.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A> f;
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a variable <I>f</I> and initializes all vertices and
    neighbors with <I>NULL</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A> f ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v0,  <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v1,  <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v2);
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a variable <I>f</I>, and initializes the vertices. The
    neighbors are initialized with <I>NULL</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A> f ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v0,  <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v1,  <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v2,  * n0,  * n1,  * n2);
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a variable <I>f</I>, and initializes the vertices and
    the neighbors.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<H3> Setting</H3>
<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    f.set_vertex ( int i,  <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Set vertex <I>i</I> to be <I>v</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    f.set_neighbor ( int i,  * n)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Set neighbor <I>i</I> to be <I>n</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<H3> <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> Access Functions</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.vertex ( int i)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the vertex <I>i</I> of <I>f</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.index ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the index of vertex <I>v</I> in <I>f</I>.
    <BR><STRONG>Precondition: </STRONG><I>v</I> is a vertex of <I>f</I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.has_vertex ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true if <I>v</I> is a vertex of <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    f.has_vertex ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v,  int&amp; i)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true if <I>v</I> is a vertex of <I>f</I>, and computes the
    index <I>i</I> of the vertex.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Neighbor Access Functions</H3>
<P>

The neighbor with index <I>i</I> is the neighbor which is opposite to
the vertex with index <I>i</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.neighbor ( int i)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the neighbor <I>i</I> of <I>f</I>. The result can be
    <I>NULL</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.index (  * n)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the index of face <I>n</I>.
    <BR><STRONG>Precondition: </STRONG><I>n</I> is a neighbor of
    <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.has_neighbor (  * n)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true if <I>n</I> is a neighbor of <I>f</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    f.has_neighbor (  * n,  int&amp; i)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true if <I>n</I> is a neighbor of <I>f</I>, and compute the
    index <I>i</I> of the neighbor.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Operations on Indices</H3>
<P>

The three vertices of a face are indexed with 0, 1 and 2. This order
defines a counterclockwise order. Given an index of a vertex the
following functions allow to compute the index of the (counter-)
clockwise neighbor vertex.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.ccw ( int i)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <MATH>i+1</MATH> modulo 3.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.cw ( int i)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns <MATH>i+2</MATH> modulo 3.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>

Note that the functions are member functions although they do not
depend on the actual face.
<P>

Note further that <I>\ccVar.neighbor(\ccVar.ccw(i))</I> is the neighbor
of <I>f</I>, turning counterclockwise around vertex <I>i</I> of
<I>f</I> and that <I>\ccVar.vertex(\ccVar.ccw(i))</I> is the vertex of
<I>f</I>, turning counterclockwise inside <I>f</I> from vertex <I>i</I>
.
<P>


<img border=0 src=./Gif/Neighbor_number.gif align=center alt="Neighbors">

<P>

<H3> Miscellaneous</H3>
<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>It
is in your responsibility to keep a triangulation valid, if you use the
advanced operations. Obviously you have to make a triangulation invalid
at times in order to implement higher level algorithms. To help you in
the development of new triangulation classes, CGAL provides a predicate
to verify the validity of the constructed structure. This function
serves mainly for debugging.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.is_valid ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true if the triangle shares two vertices with its
    neighbors, and these neighbors have a correct reciprocal
    neighboring link and coherent orientations. It further checks if
    <I>f</I> is in the adjacency list of each of its three vertices,
    and if the vertices point to the right face if they are on the
    boundary.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<H3> Update Operations</H3>
<P>

The following operations allow to modify the abstract triangulation
while keeping a valid triangulation, that is the neighbor pointers and
the face pointer of the vertices are updated as well. Of course these
modifications do not necessarily preserve geometric properties of the
triangulation.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.flip ( int i)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Flips <I>f</I> with <I>f</I>.<I>n = neighbor(i)</I>. Let <I>j</I>
    be <I>n-&gt;index(f)</I> before the flip. The vertices <I>i</I> and
    <I>ccw(i)</I> of face <I>f</I> do not change. The same holds for
    the vertices <I>j</I> and <I>ccw(j)</I> of <I>n</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>, and
    <I>f</I>.<I>neighbor(i)</I> exists.
        </TD></TR>
        </TABLE><!3>

<P>


<img border=0 src=./Gif/Flip.gif align=center alt="Flip">

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.insert ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Splits <I>f</I> in three faces, by modifying <I>f</I> and by
    creating two new faces. <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> <I>v</I> becomes vertex 0 of
    <I>f</I>.
        </TD></TR>
        </TABLE><!3>

<P>


<img border=0 src=./Gif/Three.gif align=center alt="Insertion">

<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    f.insert ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v,  int i)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Adds a triangulation face to the triangulation, that becomes
    neighbor <MATH>i</MATH> of <I>f</I>.
    <BR><STRONG>Precondition: </STRONG><I>f</I> has no neighbor
    <MATH>i</MATH>.
        </TD></TR>
        </TABLE><!3>

<P>


<img border=0 src=./Gif/Two.gif align=center alt="Insertion">

<P>

The following vertex removal function is the inverse operation of both
insertion functions.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    f.remove ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> &amp;*v)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Removes <I>v</I> from the triangulation, if one of the two
    conditions is fulfilled. <BR><STRONG>Precondition: </STRONG>Node
    <I>v</I> is not on the boundary and has degree 3 or node <I>v</I>
    is on the boundary and has degree 2 and <I>f</I> has a neighbor
    face.<BR>In the first case three triangles are merged to one
    triangle. The two triangles that are adjacent to <I>f</I> and
    <I>v</I> are deleted.<BR>In the second case vertex <I>v</I> and
    face <I>f</I> are deleted. The function returns <I>true</I> and
    sets <I>v</I> to <I>NULL</I>, if the removal was successful.
        </TD></TR>
        </TABLE><!3>
<HR> <B>Next:</B>  Class declaration of <A HREF="CGAL_Triangulation_vertex.html"><I>CGAL_Triangulation_vertex&lt;P&gt;</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Triangulation.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
