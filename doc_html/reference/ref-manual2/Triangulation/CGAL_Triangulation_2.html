<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Triangulation.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: CGAL_Triangulation_2<Traits></TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Triangulation.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_0"></A>

<A NAME="Cross_link_anchor_0"></A>

<P>

The usual definition of the triangulation of a set of points specifies
that the interior of the convex hull of the points is divided into non
overlapping triangles having the given points as vertices. Thus the
faces of the planar subdivision are triangles except the unbounded face
which has as many vertices as there are points on the convex hull.
However, for many applications, such as Kirkpatrick's hierarchy or
incremental Delaunay construction, it is convenient that the unbounded
face is also triangulated. In that way, special cases at the boundary
of the convex hull are simpler to deal with.
<P>

The classes described in the following sections have one auxiliary
vertex ``at infinity''. All vertices on the boundary of the convex hull
are incident to this vertex.
<P>


<img border=0 src=./Gif/infinite_vertex.gif align=center alt="Vertices at
infinity">

<P>

Thus the triangulation of the set of points consists of finite and
infinite faces. Although it is convenient to draw a triangulation as in
the above figure you should not take the coordinates of the vertex at
infinity, nor should you apply a geometric predicate on an infinite
face.
<P>

<H3>Definition</H3>The class <I><A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A></I>
maintains a triangulation of the convex hull of points in a plane.
<P>

A triangulation is a collection of vertices and faces that are linked
together. Each face has pointers to three vertices and to three
neighbor faces. Each vertex has a pointer to an adjacent face. The
orientation of a face is defined by the order of its vertices, which is
referred to as the <EM>counterclockwise order</EM>.
<P>

We call a triangulation <EM>valid</EM> if the following is true.
<P>

<B>(a)</B> Two faces that are neighbors have pointers to each other and
they have two vertices in common. The faces have a coherent
orientation, that is, the common vertices have opposite order in the
two faces.
<P>

<B>(b)</B> All faces that are incident to a vertex <I>v</I> must be
linked with neighbor pointers. <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> <I>v</I> points to an arbitrary
incident face.
<P>


<img border=0 src=./Gif/valid1.gif align=center alt="Insertion">

<P>

The template parameter <I><A HREF="Traits.html#Cross_link_anchor_5">Traits</A></I> is the triangulation traits class.
It defines the types of the primitives the triangulation uses. For
example <I><A HREF="Traits.html#Cross_link_anchor_5">Traits</A>::Point</I> is a mapping on a point class. Think of it
as 2D points in the Euclidean plane.
<P>

CGAL provides some traits class implementations for the CGAL kernel
which are described in  Section <A HREF="Chapter_Triangulation.html#I1_SectPredefined"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. Customizing own
triangulation traits classes can be done according to the requirements
given in  Section <A HREF="Chapter_Triangulation.html#I1_SectReq"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.
<P>

<I>#include &lt;<A HREF="../../../include/CGAL/Triangulation_2.h">
CGAL/Triangulation_2.h</A>&gt;</I>
<P>

<H3>Types</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Traits"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::<A HREF="Traits.html#Cross_link_anchor_5">Traits</A>
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    the triangulation traits type.
    <P>
        </TD></TR>
        </TABLE><!2>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Point"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>::Point
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Point;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Segment"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>::Segment
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Segment;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Triangle"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>::Triangle
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Triangle;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        </TABLE><!3>

<P>

The following types denote the vertex and face type of the
triangulation. They have the functionality as specified in Sections
<A HREF="Chapter_Triangulation.html#I1_SectVertexReq"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A> and <A HREF="Chapter_Triangulation.html#I1_SectFaceReq"><IMG SRC="../cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Vertex"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>::<A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> type.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Face"></A>
typedef <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>::<A HREF="Face.html#Cross_link_anchor_8">Face</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A>;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A> type.
        </TD></TR>
        </TABLE><!3>

<P>

The following types denote circulators that allow to traverse the
vertices and edges adjacent to a given vertex. The circulators are
bidirectional and non-mutable. Their value-type is <I><A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*</I> and
<I><A HREF="Face.html#Cross_link_anchor_8">Face</A>*</I>, respectively.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex_circulator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Vertex_circulator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Face_circulator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Face_circulator
        </I>
        </TD></TR>
    
    <P>
        </TABLE><!2>

<P>

The following types denote iterators that allow to visit all finite
faces, edges and vertices of the triangulation. The iterators are
bidirectional and non-mutable. Their value type is <I><A HREF="Face.html#Cross_link_anchor_8">Face</A>*</I>,
<I>pair&lt;<A HREF="Face.html#Cross_link_anchor_8">Face</A>*, int&gt;</I>, and <I><A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*</I>, respectively.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Face_iterator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Face_iterator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Edge_iterator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Edge_iterator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Vertex_iterator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Vertex_iterator
        </I>
        </TD></TR>
    
    <P>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Line_face_circulator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Line_face_circulator
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    A circulator that allows to visit all faces that are intersected by
    a line. The circulator is bidirectional and non-mutable. Its
    value-type is <I><A HREF="Face.html#Cross_link_anchor_8">Face</A>*</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Nested_type_Convex_hull_vertex_circulator"></A>
<A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A>::Convex_hull_vertex_circulator
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    A circulator that allows to walk on the convex hull of the point
    set. The circulator is bidirectional and non-mutable. Its
    value-type is <I><A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*</I>.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

The iterators that allow to visit all vertices, edges and faces are
invalidated by any modification of the triangulation. The circulator
that allows to visit all faces that are intersected by a line is
invalidated if the face the circulator points to is changed. The convex
hull circulator is invalidated if an infinite face incident to the
vertex the circulator points to is modified.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A NAME="Enum_Locate_type"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
    enum Locate_type { </TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP>
    VERTEX=0, <BR>
    EDGE, <BR>
    FACE, <BR>
    OUTSIDE, <BR>
    COLLINEAR_OUTSIDE};</TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Specifies the result of a point location operation. <I>OUTSIDE</I>
    means outside the convex hull. <I>COLLINEAR_OUTSIDE</I> means
    outside the convex hull but collinear to all points of the
    triangulation, that is, the convex hull is 1-dimensional.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A> T (  <A HREF="Traits.html#Cross_link_anchor_5">Traits</A> t = <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>());
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces an empty triangulation <I>T</I>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A> T ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>* v; <A HREF="Traits.html#Cross_link_anchor_5">Traits</A> t = <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>());</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    Introduces a triangulation <I>T</I> that is initialized with the
    vertices and faces that are linked to vertex <I>v</I>. If <I>v</I>
    has no incident face the triangulation consists only of <I>v</I>.
    Otherwise <I>v</I> must be the vertex at infinity.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Operations</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.clear ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Removes all vertices and faces.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    T.locate (  Point query,  <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f = NULL)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    If the point lies inside the convex hull of the points, the face
    that contains the query in its interior or on its boundary is
    returned.<BR>If the point lies outside the convex hull, an infinite
    face with vertices <MATH>(\infty, p, q)</MATH> is returned such
    that the following holds: If the dimension of the convex hull is 2,
    the point <I>query</I> lies to the left of the oriented line
    passing through <I>p</I> and <I>q</I>. If the dimension of the
    convex hull is 1, <I>q</I> lies between <I>p</I> and <I>query</I>,
    and there is no other vertex on the convex hull that lies between
    them.<BR>The last argument <I>f</I> is an indication to the locate
    algorithm where to start.
    <BR><STRONG>Precondition: </STRONG><I>T</I> has <MATH>&gt;=2</MATH>
    vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    T.locate ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point query, <BR>
     Locate_type&amp; lt, <BR>
     int&amp; li, <BR>
     <A HREF="Face.html#Cross_link_anchor_8">Face</A>* h = NULL)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as above. Additionally, the parameters <I>lt</I> and <I>li</I>
    describe where the query point is located. The variable <I>li</I>
    is the index of the vertex or the index of the vertex opposite to
    the edge, if the point lies on a vertex or on an edge. Otherwise
    <I>li</I> has no meaning.
    <BR><STRONG>Precondition: </STRONG><I>T</I> has <MATH>&gt;=2</MATH>
    vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    T.insert (  Point p,  <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f = NULL)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts point <I>p</I> in the triangulation and returns the
    corresponding vertex.<BR>If point <I>p</I> coincides with an
    already existing vertex, this vertex is returned and the
    triangulation remains unchanged.<BR>If point <I>p</I> is on an
    edge, the two adjacent faces are split in two.<BR>If point <I>p</I>
    is strictly inside a face of the triangulation, the face is split
    in three.<BR>If point <I>p</I> is strictly outside the convex hull,
    <MATH>p</MATH> is linked to all visible points on the convex hull
    to form the new triangulation.<BR>The last argument <I>f</I> is an
    indication to the underlying locate algorithm of where to start.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    T.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p, <BR>
     Locate_type&amp; lt, <BR>
     <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f = NULL)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Same as above. Additionally, parameter <I>lt</I> describes where
    point <I>p</I> was located before updating the triangulation (see
    <I>locate</I>).
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt; class InputIterator &gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    T.insert ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     InputIterator last)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the points in the range <MATH>[.</MATH><I>first</I>,
    <I>last</I><MATH>.)</MATH>. Returns the number of inserted points.
    <BR><STRONG>Precondition: </STRONG>The <I>value_type</I> of
    <I>first</I> and <I>last</I> is <I>Point</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.remove ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A> *v)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Removes the vertex from the triangulation. The created hole is
    retriangulated.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Traversal of the Triangulation</H3>
<P>

A triangulation can be seen as a container of faces and vertices. We
provide several iterators and circulators that allow to traverse all
faces, all vertices, the convex hull of the point set as well as all
faces that are intersected by a given line.
<P>

The triangulation class defines an iterator that allows to visit all
finite faces. This iterator is non-mutable and bidirectional. Its value
type is <I><A HREF="Face.html#Cross_link_anchor_8">Face</A>*</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Face_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.faces_begin ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns an iterator that allows to traverse all finite faces of
    <I>T</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Face_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.faces_end ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        </TABLE><!3>

<P>

The triangulation class defines an iterator that allows to visit all
edges with finite vertices. This iterator is non-mutable and
bidirectional. Its value type is <I>pair&lt;<A HREF="Face.html#Cross_link_anchor_8">Face</A>*,int&gt;</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Edge_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.edges_begin ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns an iterator that allows to traverse all finite edges of
    <I>T</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Edge_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.edges_end ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        </TABLE><!3>

<P>

The triangulation class further defines an iterator that allows to
visit all finite vertices. This iterator is non-mutable and
bidirectional. Its value type is <I><A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.vertices_begin ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns an iterator that allows to traverse all finite vertices of
    <I>T</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Vertex_iterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.vertices_end ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the corresponding past-the-end iterator.
        </TD></TR>
        </TABLE><!3>

<P>

The triangulation class defines a circulator that allows to visit all
vertices on the convex hull of the point set in clockwise
order.[<A HREF="#Footnote_1">^1</A>] This circulator is non-mutable and
bidirectional. Its value type is <I><A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    Convex_hull_vertex_circulator
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.convex_hull ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a circulator that allows to traverse the convex hull.
        </TD></TR>
        </TABLE><!3>

<P>

Finally, the triangulation class defines a circulator that allows to
visit all faces that are intersected by a line. This circulator is
non-mutable and bidirectional. Its value type is <I><A HREF="Face.html#Cross_link_anchor_8">Face</A>*</I>.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Line_face_circulator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    T.line_walk ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     Point p, <BR>
     Point q, <BR>
     <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f = NULL)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Let <I>l</I> be the line defined by <I>p</I> and <I>q</I>. This
    function returns a circulator that allows to traverse the finite
    faces whose interior intersects with <I>l</I>, or that have an edge
    that is collinear with <I>l</I> and whose interior lies completely
    to the left of <I>l</I>.<BR>The starting point of the circulator is
    the face <I>f</I>, if <I>f != NULL</I>, or the first such face
    along <I>l</I>. If there is no such face the circulator has a
    singular value.<BR>The circulator performs a wraparound and points
    to the infinite faces adjacent to the first and last finite face
    that is traversed. <BR><STRONG>Precondition: </STRONG>If
    <I>f != NULL</I>, the point <I>p</I> must be inside or on the
    boundary of <I>f</I>.
        </TD></TR>
        </TABLE><!3>

<P>

The following figure illustrates which faces are enumerated. Lines
<MATH>l<SUB>1</SUB></MATH> and <MATH>l<SUB>2</SUB></MATH> have no face
to their left. Lines <MATH>l<SUB>3</SUB></MATH> and
<MATH>l<SUB>4</SUB></MATH> have faces to their left. Note that the
faces that are only vertex incident to lines <MATH>l<SUB>3</SUB></MATH>
and <MATH>l<SUB>4</SUB></MATH> are not enumerated.
<P>


<img border=0 src=./Gif/walk.gif align=center alt="The Infinite Vertex">

<P>

<H3> Infinite Vertices and Faces</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.is_infinite ( <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*v)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true, iff the vertex is infinite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.is_infinite ( <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns true, iff one of the vertices of <I>f</I> is infinite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Face.html#Cross_link_anchor_8">Face</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.infinite_face ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a face that has an infinite vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.infinite_vertex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the infinite vertex.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Predicates</H3>
<P>

As the faces are oriented counterclockwise, we can identify the
``interior'' of a finite face with the positive side.
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    CGAL_Oriented_side
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    T.oriented_side ( <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f,  Point p)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns on which side of the oriented boundary of <I>f</I> lies the
    point <I>p</I>. <BR><STRONG>Precondition: </STRONG><I>f</I> is
    finite.
        </TD></TR>
        </TABLE><!3>

<P>

<H3> Miscellaneous</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="Vertex.html#Cross_link_anchor_7">Vertex</A>*
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.finite_vertex ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns an arbitrary finite vertex.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
     <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.traits ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns a const reference to the triangulation traits object.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.dimension ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the dimension of the convex hull.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.number_of_vertices ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the number of finite vertices.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    int
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.number_of_faces ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the number of finite and infinite faces.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Triangle
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    T.triangle ( <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the triangle formed by the three vertices of <I>f</I>.
    <BR><STRONG>Precondition: </STRONG>The face is finite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Segment
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    T.segment ( <A HREF="Face.html#Cross_link_anchor_8">Face</A>* f,  int i)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the line segment formed by the vertices <I>f-&gt;ccw(i)</I>
    and <I>f-&gt;cw(i)</I> of face <I>f</I>.
    <BR><STRONG>Precondition: </STRONG><MATH>0&lt;=i &lt;=2</MATH>.
    <I>f-&gt;ccw(i)</I> and <I>f-&gt;cw(i)</I>are finite.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Segment
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    T.segment (  Edge_iterator it)
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Returns the line segment the iterator points to.
    <BR><STRONG>Precondition: </STRONG><I>it</I> has a non-singular
    value.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_begin.gif" ALT="begin of advanced section"><BR>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    T.is_valid ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    bool verbose = false, <BR>
     int level = 0)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Tests the validity of all faces, if the orientation of the faces is
    consistent. This method serves mainly for debugging user-defined
    triangulation.
        </TD></TR>
        </TABLE><!3>

<P>

<BR><IMG BORDER=0 SRC="../cc_advanced_end.gif" ALT="end of advanced section"><BR>
<H3> I/O</H3>
<P>

The I/O operators are defined for <I>iostream</I>, and for the window
stream provided by CGAL. The format for the iostream is an internal
format.
<P>

<I>#include &lt;<A HREF="../../../include/CGAL/IO/ostream_2.h">
CGAL/IO/ostream_2.h</A>&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_ostream__operator666ostream__os+__const_CGAL_Triangulation_26Traits9__T9;"></A>
ostream&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
     ostream&amp; os &lt;&lt;  T
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the triangulation <I>T</I> into the stream <I>os</I>.
    <BR><STRONG>Precondition: </STRONG>The insert operator must be
    defined for <I>Point</I>.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_istream__operator996istream__is+__const_CGAL_Triangulation_26Traits9__T9;"></A>
istream&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
     istream&amp; is &gt;&gt;  T
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Reads a triangulation from stream <I>is</I> and assigns it to
    <I>T</I>. <BR><STRONG>Precondition: </STRONG>The extract operator
    must be defined for <I>Point</I>
        </TD></TR>
        </TABLE><!3>

<P>

<I>#include &lt;<A HREF="../../../include/CGAL/IO/Window_stream.h">
CGAL/IO/Window_stream.h</A>&gt;</I>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_CGAL_Window_stream__operator666CGAL_Window_stream__W+__const_CGAL_Triangulation_26Traits9__T9;"></A>
CGAL_Window_stream&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
     CGAL_Window_stream&amp; W &lt;&lt;  T
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    Inserts the triangulation <I>T</I> into the window stream <I>W</I>.
    The insert operator must be defined for <I>Point</I> and
    <I>Segment</I>.
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Example</H3>The following code fragment creates a triangulation of
2D points for the usual Euclidean metric. We read points from <TT>cin
</TT> and writes the points on the convex hull to <TT>cout</TT>. The
<TT>while</TT> loop can be replaced by the code in the comment, as the
triangulation class has an <I>insert</I> member function that takes an
STL range of points as argument.
<P>

<PRE>

typedef CGAL_Cartesian&lt;CGAL_Rational&gt; Rep;
typedef CGAL_Point_2&lt;Rep&gt; Point;
typedef <A HREF="CGAL_Triangulation_euclidean_traits_2.html#Cross_link_anchor_2">CGAL_Triangulation_euclidean_traits_2&lt;Rep&gt;</A> <A HREF="Traits.html#Cross_link_anchor_5">Traits</A>;

typedef <A HREF="CGAL_Triangulation_2.html#Cross_link_anchor_0">CGAL_Triangulation_2&lt;Traits&gt;</A> Triangulation;

{
    Triangulation T();

    while(cin){
        Point p;
        cin &gt;&gt; p;
        T.insert(p);
    }

    /*
    T.insert(istream_iterator&lt;Point, ptrdiff_t&gt;(cin),
             istream_iterator&lt;Point, ptrdiff_t&gt;());
    */

    Triangulation::Convex_hull_vertex_circulator hvc = T.convex_hull(),
                                                       done(hvc);
    if(hvc != NULL) {
        do{
            cout &lt;&lt; (*hvc)-&gt;point();
        }while(++hvc != done);
    }
}
  

</PRE>
<P>


<P><HR><H3>Footnotes</H3><P>

<OL>
<LI><A NAME="Footnote_1">Note that this is equivalent to the counterclockwise traversal of the vertices adjacent to the infinite vertex.
</OL>
<HR> <B>Next:</B>  Class declaration of <A HREF="CGAL_Delaunay_triangulation_2.html"><I>CGAL_Delaunay_triangulation_2&lt;Traits&gt;</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Triangulation.html">Up</A>,
  <A HREF="../contents.html">Table of Contents</A>,
  <A HREF="../biblio.html">Bibliography</A>,
  <A HREF="../manual_index.html">Index</A>,
  <A HREF="../../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
