<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_generators.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_generators.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<H1>Random Sources and Geometric Object Generators</H1>

<A NAME="chapterGenerators"></A><P>

A variety of generators for random numbers and geometric objects is
provided in CGAL. They are useful as synthetic test data sets,
e.g. for testing algorithms on degenerate object sets and for
performance analysis.<P>

The first section describes the random number source used for random
generators. The second section documents generators for point sets,
the third section for segments. Note that the STL algorithm
<I>random_shuffle</I> is useful in this context to achieve random
permutations (e.g. for points on a grid).<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Random.html"><I>CGAL_Random</I></A>.</UL>

<P>

<A NAME="Section_15"></A>
<H2>Support Functions for Generators</H2>
<P>

Two support functions are provided. <I>CGAL_copy_n()</I> copies <MATH>n</MATH>
items from an input iterator to an output iterator which is useful for
possibly infinite sequences of random geometric objects[<A HREF="#Footnote_1">^1</A>].
<I>CGAL_random_selection</I> chooses <MATH>n</MATH> items at random from a random
access iterator range which is useful to produce degenerate input data
sets with multiple entries of identical items.<P>

<H3><I>CGAL_copy_n()</I></H3>

<A NAME="sectionCopyN"></A><P>

<I>#include &lt;<A HREF="../../../include/CGAL/copy_n.h">CGAL/copy_n.h</A>&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;class InputIterator, class Size, class OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_copy_n6_InputIterator_first+_Size_n+___OutputIterator_result9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_copy_n ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    InputIterator first, <BR>
     Size n, <BR>
     OutputIterator result)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    copies the first <MATH>n</MATH> items from <I>first</I> to
    <I>result</I>. Returns the value of <I>result</I> after inserting
    the <MATH>n</MATH> items.
        </TD></TR>
        </TABLE><!3>
<P>

<H3><I>CGAL_random_selection()</I></H3>

<A NAME="sectionRandomSelection"></A><P>

<I>#include &lt;<A HREF="../../../include/CGAL/random_selection.h">CGAL/random_selection.h</A>&gt;</I><P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;class RandomAccessIterator, class Size,   class OutputIterator, class Random&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_random_selection6_RandomAccessIterator_first+__RandomAccessIterator_last+___Size_n+_OutputIterator_result+_Random__rnd_=_CGAL_random9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_random_selection ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    RandomAccessIterator first, <BR>
     RandomAccessIterator last, <BR>
     Size n, <BR>
     OutputIterator result, <BR>
     Random&amp; rnd = CGAL_random)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    choose a random item from the range
    <MATH>[</MATH><I>first</I><MATH>,</MATH><I>last</I><MATH>)</MATH>
    and write it to <I>result</I>, each item from the range with equal
    probability. Repeat this <MATH>n</MATH> times, thus writing
    <MATH>n</MATH> items to <I>result</I>. A single random number is
    needed from <I>rnd</I> for each item. Returns the value of
    <I>result</I> after inserting the <MATH>n</MATH> items.
    <BR><STRONG>Precondition: </STRONG><I>Random</I> is a random number
    generator type as provided by the STL or by <I><A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A></I>.
        </TD></TR>
        </TABLE><!3>
<P>

<P><A NAME="Section_16"></A>
<H2>2D Point Generators</H2>
<P>

<H3>Definition</H3>Point generators are provided for random points uniformly distributed
over a two-dimensional domain (square or disc) or a one-dimensional
domain (boundary of a square, circle, or segment). Other point
generators create two-dimensional grids or equally spaced points on a
segment. A perturbation function adds random noise to a given set of
points. Several functions add degeneracies: the duplication of randomly
chosen points and the construction of a collinear point between two randomly
chosen points from a set of points.<P>

<I>#include &lt;<A HREF="../../../include/CGAL/point_generators_2.h">CGAL/point_generators_2.h</A>&gt;</I><P>

<H3>Creation</H3>The random point generators build two-dimensional points from a pair
of <I>double</I>'s. Depending on the point representation and
arithmetic, a different building process is necessary. It is
encapsulated in the global function <I>CGAL_build_point()</I>.
Implementations exist for <I>CGAL_Cartesian&lt;double&gt;</I> and
<I>CGAL_Cartesian&lt;float&gt;</I>. They are automatically included if the
representation type <I>CGAL_Cartesian</I> has been included beforehand.
For other representations and arithmetic types the function can be
overloaded.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_void_CGAL_build_point6_double_x+_double_y+_Point___p9;"></A>
void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_build_point ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    double x, <BR>
     double y, <BR>
     Point&amp; p)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    builds a point <MATH>(x,y)</MATH> in <MATH>p</MATH>. <I>Point</I>
    is the point type in question.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Random Points</H3><P>

The random point generators are implemented as classes that satisfies
the requirements for input iterators. They represent the possibly
infinite sequence of randomly generated points. Each call to the
<I>operator*</I> returns a new point. To create a finite sequence in a
container, the function <I>CGAL_copy_n()</I> could be used, see
Section <A HREF="Chapter_generators.html#sectionCopyN"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>.<P>


<A NAME="Index_anchor_29"></A>

<A NAME="Cross_link_anchor_29"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Chapter_generators.html#Cross_link_anchor_29">CGAL_Random_points_in_disc_2&lt;P&gt;</A> g ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    double r, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <MATH>g</MATH> is an input iterator creating points of type
    <I>P</I> uniformly distributed in the open disc with radius
    <MATH>r</MATH>, i.e. <MATH>|</MATH><I>*g</I><MATH>| &lt; r</MATH> .
    Two random numbers are needed from <I>rnd</I> for each point.
    <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the point type <I>P</I> exists.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_30"></A>

<A NAME="Cross_link_anchor_30"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Chapter_generators.html#Cross_link_anchor_30">CGAL_Random_points_on_circle_2&lt;P&gt;</A> g ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    double r, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <MATH>g</MATH> is an input iterator creating points of type
    <I>P</I> uniformly distributed on the circle with radius
    <MATH>r</MATH>, i.e. <MATH>|</MATH><I>*g</I><MATH>| == r</MATH> . A
    single random number is needed from <I>rnd</I> for each point.
    <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the point type <I>P</I> exists.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_31"></A>

<A NAME="Cross_link_anchor_31"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Chapter_generators.html#Cross_link_anchor_31">CGAL_Random_points_in_square_2&lt;P&gt;</A> g ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    double a, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <MATH>g</MATH> is an input iterator creating points of type
    <I>P</I> uniformly distributed in the half-open square with side
    length <MATH>a</MATH>, centered at the origin, i.e.
    <MATH>\forall p = </MATH><I>*g</I><MATH>:  -\fraca2 &lt;=p.x() &lt; \fraca2</MATH>
    and <MATH>-\fraca2 &lt;=p.y() &lt; \fraca2</MATH> . Two random
    numbers are needed from <I>rnd</I> for each point.
    <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the point type <I>P</I> exists.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_32"></A>

<A NAME="Cross_link_anchor_32"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Chapter_generators.html#Cross_link_anchor_32">CGAL_Random_points_on_square_2&lt;P&gt;</A> g ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    double a, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <MATH>g</MATH> is an input iterator creating points of type
    <I>P</I> uniformly distributed on the boundary of the square with
    side length <MATH>a</MATH>, centered at the origin, i.e.
    <MATH>\forall p = </MATH><I>*g</I><MATH>:</MATH> one coordinate is
    either <MATH>\fraca2</MATH> or <MATH>-\fraca2</MATH> and for the
    other coordinate <MATH>c</MATH> holds
    <MATH>-\fraca2 &lt;=c &lt; \fraca2</MATH> . A single random number
    is needed from <I>rnd</I> for each point.
    <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the point type <I>P</I> exists.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_33"></A>

<A NAME="Cross_link_anchor_33"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="Chapter_generators.html#Cross_link_anchor_33">CGAL_Random_points_on_segment_2&lt;P&gt;</A> g ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     P p, <BR>
     P q, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    <MATH>g</MATH> is an input iterator creating points of type
    <I>P</I> uniformly distributed on the segment from <MATH>p</MATH>
    to <MATH>q</MATH> except <MATH>q</MATH>, i.e.
    <MATH></MATH><I>*g</I><MATH> == (1-lambda) p + lambda q</MATH>
    where <MATH>0 &lt;=lambda &lt; 1</MATH> . A single random number is
    needed from <I>rnd</I> for each point.
    <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the point type <I>P</I> exists. The
    expressions <I>CGAL_to_double(p.x())</I> and
    <I>CGAL_to_double(p.y())</I> must result in the respective
    <I>double</I> representation of the coordinates and similar for
    <MATH>q</MATH>.
    <P>
        </TD></TR>
        </TABLE><!2>
<P>

<H3>Grid Points</H3><P>

Grid points are produced by generating functions writing to an output
iterator.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;class OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator__CGAL_points_on_square_grid_26_double_a+_size_t_n+_OutputIterator_o+__const_P*9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_points_on_square_grid_2 ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    double a, <BR>
     size_t n, <BR>
     OutputIterator o, <BR>
     const P*)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    creates the <MATH>n</MATH> first points on the regular
    <MATH>\lceil\sqrtn\rceil
    &times; \lceil  \sqrtn\rceil</MATH>
    grid within the square
    <MATH>[-\fraca2,\fraca2]&times; [-\fraca2,\fraca2]</MATH>. Returns
    the value of <MATH>o</MATH> after inserting the <MATH>n</MATH>
    points. <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the point type <MATH>P</MATH> and
    <MATH>P</MATH> must be assignable to the value type of
    <I>OutputIterator</I>.
        </TD></TR>
        </TABLE><!3>
<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;class P, class OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_points_on_segment_26_const_P__p+_const_P__q+_size_t_n+__OutputIterator_o9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_points_on_segment_2 ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     P p, <BR>
     P q, <BR>
     size_t n, <BR>
     OutputIterator o)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    creates <MATH>n</MATH> points regular spaced on the segment from
    <MATH>p</MATH> to <MATH>q</MATH>, i.e.
    <MATH>\forall i: 0 &lt;=i &lt; n: o[i] := \fracn-i-1n-1 p +
    \fracin-1 q</MATH>.
    Returns the value of <MATH>o</MATH> after inserting the
    <MATH>n</MATH> points.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Random Perturbations</H3><P>

Degenerate input sets like grid points can be randomly perturbed by a
small amount to produce <EM>quasi</EM>-degenerate test sets. This
challenges numerical stability of algorithms using inexact arithmetic and
exact predicates to compute the sign of expressions slightly off from zero.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;class ForwardIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_void_CGAL_perturb_points_26_ForwardIterator_first+_ForwardIterator_last+___double_xeps+_double_yeps_=_xeps+_CGAL_Random__rnd_=_CGAL_random9;"></A>
void
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_perturb_points_2 ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    ForwardIterator first, <BR>
     ForwardIterator last, <BR>
     double xeps, <BR>
     double yeps = xeps, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    perturbs the points in the range
    <MATH>[</MATH><I>first</I><MATH>,</MATH><I>last</I><MATH>)</MATH>
    by replacing each point with a random point from the rectangle
    <I>xeps</I> <MATH>&times;</MATH> <I>yeps</I> centered at the
    original point. Two random numbers are needed from <I>rnd</I> for
    each point. <BR><STRONG>Precondition: </STRONG>a function
    <I>CGAL_build_point()</I> for the value type of the
    <I>ForwardIterator</I> exists. The expressions
    <I>CGAL_to_double((*first).x())</I> and
    <I>CGAL_to_double((*first).y())</I> must result in the respective
    coordinate values.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Adding Degeneracies</H3><P>

For a given point set certain kinds of degeneracies can be produced
adding new points. The <I>CGAL_random_selection()</I> function is
useful to generate multiple entries of identical points, see
Section <A HREF="Chapter_generators.html#sectionRandomSelection"><IMG SRC="cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10" HEIGHT="10"></A>. The
<I>CGAL_random_collinear_points_2()</I> function adds collinearities to
a point set.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    template &lt;class RandomAccessIterator, class OutputIterator&gt;
        </I>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Function_OutputIterator_CGAL_random_collinear_points_26_RandomAccessIterator_first+__RandomAccessIterator_last+___size_t_n+_OutputIterator_first2+_CGAL_Random__rnd_=_CGAL_random9;"></A>
OutputIterator
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_random_collinear_points_2 ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    RandomAccessIterator first, <BR>
     RandomAccessIterator last, <BR>
     size_t n, <BR>
     OutputIterator first2, <BR>
     <A HREF="CGAL_Random.html#Cross_link_anchor_28">CGAL_Random</A>&amp; rnd = CGAL_random)</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    randomly chooses two points from the range
    <MATH>[</MATH><I>first</I><MATH>,</MATH><I>last</I><MATH>)</MATH>,
    creates a random third point on the segment connecting this two
    points, and writes it to <I>first2</I>. Repeats this <MATH>n</MATH>
    times, thus writing <MATH>n</MATH> points to <I>first2</I> that are
    collinear with points in the range
    <MATH>[</MATH><I>first</I><MATH>,</MATH><I>last</I><MATH>)</MATH>.
    Three random numbers are needed from <I>rnd</I> for each point.
    Returns the value of <I>first2</I> after inserting the
    <MATH>n</MATH> points. <BR><STRONG>Precondition: </STRONG>a
    function <I>CGAL_build_point()</I> for the value type of the
    <I>ForwardIterator</I> exists. The expressions
    <I>CGAL_to_double((*first).x())</I> and
    <I>CGAL_to_double((*first).y())</I> must result in the respective
    coordinate values.
        </TD></TR>
        </TABLE><!3>
<P>

<H3>Example</H3>We want to generate a test set of 1000 points, where 60% are chosen
randomly in a small disc, 20% are from a larger grid, 10% duplicates
are added, and 10% collinearities added. A random shuffle removes the
construction order from the test set. See Figure <A HREF="#PointGenerators">
  <IMG SRC="cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10"
  HEIGHT="10"></A> for the example output.<P>

<PRE>/*  generators_prog1.C     */
/*  ------------------------------ */
/*  CGAL example program for point generators. */

#include &lt;CGAL/basic.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector.h&gt;
#include &lt;algo.h&gt;
#include &lt;CGAL/Cartesian.h&gt;
#include &lt;CGAL/Point_2.h&gt;
#include &lt;CGAL/point_generators_2.h&gt;
#include &lt;CGAL/copy_n.h&gt;
#include &lt;CGAL/random_selection.h&gt;
#include &lt;CGAL/IO/Window_stream.h&gt;  /* only for visualization used */

typedef CGAL_Cartesian&lt;double&gt;  R;
typedef CGAL_Point_2&lt;R&gt;         Point;

int main()
{
    /* Create test point set. Prepare a vector for 1000 points. */
    vector&lt;Point&gt; points;
    points.reserve(1000);

    /* Create 600 points within a disc of radius 150. */
    <A HREF="Chapter_generators.html#Cross_link_anchor_29">CGAL_Random_points_in_disc_2&lt;Point&gt;</A> g( 150.0);
    CGAL_copy_n( g, 600, back_inserter( points));

    /* Create 200 points from a 15 x 15 grid. */
    CGAL_points_on_square_grid_2( 500.0, 200, back_inserter(points),(Point*)0);

    /* Select 100 points randomly and append them at the end of */
    /* the current vector of points. */
    CGAL_random_selection( points.begin(), points.end(), 100, 
			   back_inserter( points));

    /* Create 100 points that are collinear to two randomly chosen */
    /* points and append them to the current vector of points. */
    CGAL_random_collinear_points_2( points.begin(), points.end(), 100,
				    back_inserter( points));

    /* Check that we have really created 1000 points. */
    assert( points.size() == 1000);

    /* Use a random permutation to hide the creation history */
    /* of the point set. */
    random_shuffle( points.begin(), points.end(), CGAL_random);

    /* Visualize point set. Can be omitted, see example programs */
    /* in the CGAL source code distribution. */
    <A HREF="CGAL_Window_stream.html#Cross_link_anchor_38">CGAL_Window_stream</A> W(512, 512);
    W.init(-256.0, 255.0, -256.0);
    W &lt;&lt; CGAL_BLACK;
    for( vector&lt;Point&gt;::iterator i = points.begin(); i != points.end(); i++)
	W &lt;&lt; *i;

    /*  Wait for program termination. */
    char c;
    cout &lt;&lt; &quot; Type any character to continue: &quot; &lt;&lt; endl;
    cin &gt;&gt; c;
    cout &lt;&lt; &quot; done&quot; &lt;&lt; endl;

    return 0;
}
</PRE><P>


  <A NAME="PointGenerators">
  <TABLE><TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=60%>
    <A HREF="./generators_prog1.gif">Figure:</A>
    Output of example program for point generators.
  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=5% NOWRAP>
  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=35% NOWRAP>
    <A HREF="./generators_prog1.gif">
        <img src="./generators_prog1_small.gif" 
             alt="Point Generator Example Output"></A>
  </TD></TR></TABLE>
<P>

The second example demonstrates the point generators with integer
points. Arithmetic with <I>double</I>'s is sufficient to produce
regular integer grids. See Figure 
  <A HREF="#IntegerPointGenerators">
  <IMG SRC="cc_ref_up_arrow.gif" ALT="reference arrow" WIDTH="10"
  HEIGHT="10"></A>
for the example output.<P>

<PRE>/*  generators_prog2.C     */
/*  ------------------------------ */
/*  CGAL example program for point generators creating integer points. */

#include &lt;CGAL/basic.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector.h&gt;
#include &lt;algo.h&gt;
#include &lt;CGAL/Cartesian.h&gt;
#include &lt;CGAL/Point_2.h&gt;

typedef CGAL_Cartesian&lt;int&gt;  R;
typedef CGAL_Point_2&lt;R&gt;      Point;

/* Provide your own CGAL_build_point function. */
inline
Point&amp; CGAL_build_point( double x, double y, Point&amp; p) {
    p = Point( int(x), int(y));
    return p;
}

#include &lt;CGAL/point_generators_2.h&gt;
#include &lt;CGAL/copy_n.h&gt;
#include &lt;CGAL/IO/Window_stream.h&gt;  /* only for visualization used */


int main()
{
    /* Create test point set. Prepare a vector for 400 points. */
    vector&lt;Point&gt; points;
    points.reserve(400);

    /* Create 250 points from a 16 x 16 grid. Note that the double */
    /* arithmetic _is_ sufficient to produce exact integer grid points. */
    /* The distance between neighbors is 34 pixel = 510 / 15. */
    CGAL_points_on_square_grid_2( 510.0, 250, back_inserter(points),(Point*)0);

    /* Lower, left corner. */
    assert( points[0].x() == -255);
    assert( points[0].y() == -255);

    /* Upper, right corner. Note that 6 points are missing to fill the grid. */
    assert( points[249].x() == 255 - 6 * 34);
    assert( points[249].y() == 255);

    /* Create 250 points within a disc of radius 150. */
    <A HREF="Chapter_generators.html#Cross_link_anchor_29">CGAL_Random_points_in_disc_2&lt;Point&gt;</A> g( 150.0);
    CGAL_copy_n( g, 250, back_inserter( points));

    /* Check that we have really created 500 points. */
    assert( points.size() == 500);

    /* Visualize point set. Can be omitted, see example programs */
    /* in the CGAL source code distribution. */
    <A HREF="CGAL_Window_stream.html#Cross_link_anchor_38">CGAL_Window_stream</A> W(524, 524);
    W.init(-262.0, 261.0, -262.0);
    W &lt;&lt; CGAL_BLACK;
    for( vector&lt;Point&gt;::iterator i = points.begin(); i != points.end(); i++)
	W &lt;&lt; *i;

    /*  Wait for program termination. */
    char c;
    cout &lt;&lt; &quot; Type any character to continue: &quot; &lt;&lt; endl;
    cin &gt;&gt; c;
    cout &lt;&lt; &quot; done&quot; &lt;&lt; endl;

    return 0;
}
</PRE><P>


  <A NAME="IntegerPointGenerators">
  <TABLE><TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=60%>
    <A HREF="./generators_prog2.gif">Figure:</A>
        Output of example program for point generators working
        on integer points.
  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=5% NOWRAP>
  </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=35% NOWRAP>
    <A HREF="./generators_prog2.gif">
        <img src="./generators_prog2_small.gif" 
             alt="Integer Point Generator Example Output"></A>
  </TD></TR></TABLE>
<P>

<P><A NAME="Section_17"></A>
<H2>2D Segment Generators</H2>
<P>

The following generic segment generator uses two point generators to
create a segment from two endpoints. This is a design example how
further generators could look like - for segments and for other
higher level objects.<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Segment_generator.html"><I>CGAL_Segment_generator&lt;S,P1,P2&gt;</I></A>.</UL>

<P>

<P>

<P><HR><H3>Footnotes</H3><P>

<OL>
<LI><A NAME="Footnote_1">The STL release June 13, 1997, from SGI has a new function <I>copy_n</I> which is equivalent with <I>CGAL_copy_n</I>.
</OL>
<HR> Next chapter: <A HREF="Chapter_IOStream.html">Operators for IO Streams</A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_generators.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
