<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_Circulators.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Circulators.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->


<A NAME="Index_anchor_26"></A>

<A NAME="Cross_link_anchor_26"></A>

<P>

<H3>Definition</H3>Given a data structure <I>A</I> that provides random
access with an index of type <I>U</I> to its sequence of stored
elements of type <I>T</I> with a member function <I>access</I> the
adaptor
<I><A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_26">CGAL_Circulator_over_array</A>&lt; A, T, U, I, T&amp; (A::* access)(U i)  = &amp;A::operator[]&gt;</I>
provides a random access circulator for <I>A</I>. The corresponding
const circulator is
<I><A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_27">CGAL_Const_circulator_over_array</A>&lt; A, T, U, I, const T&amp; (A::*  access)(U i) const = &amp;A::operator[]&gt;</I>
. All circulators for an array <I>a</I> become invalid whenever
<I>a</I> changes its size (due to deletions or insertions).
<P>

As long as default template parameters are not supported the adaptors
will not provide the member pointer template parameter. The adaptors
will use the default value. All adaptors have a counterpart with the
suffix <I>_mptr</I> supporting all template parameters, but no default
settings. As soon as member pointers are supported by our reference
compilers[<A HREF="#Footnote_1">^1</A>], these counterparts can be
used.
<P>

<I>A</I> is a random access data structure and <I>T</I> its value type.
<I>U</I> is the unsigned integral type carrying the size of the array
and the actual index within the container. <I>I</I> is the signed
integral type used as distance type and as index type in the random
access circulator. The member function <I>access</I> is given as a
member pointer <I>T&amp; (A::*  access)(U i)</I> or
<I>const T&amp; (A::* access)(U i) const</I> for the const circulator.
It has a default value <I>&amp;A::operator[]</I> .
<P>

<I>#include &lt;<A HREF="../../../include/CGAL/circulator_impl.h">
CGAL/circulator_impl.h</A>&gt;</I>
<P>

<H3>Types</H3>
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_Array"></A>
typedef A
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    Array;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_value_type"></A>
typedef T
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    value_type;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_reference"></A>
typedef T&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    reference;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_const_reference"></A>
typedef const T&amp;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    const_reference;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_size_type"></A>
typedef U
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    size_type;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A NAME="Typedef_difference_type"></A>
typedef I
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    difference_type;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        </TABLE><!3>

<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_26">CGAL_Circulator_over_array</A>&lt; A, T, U, I, T&amp; (A::* access)(U i)&gt; c;
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    a circulator <I>c</I> with singular value.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_26">CGAL_Circulator_over_array</A>&lt; A, T, U, I, T&amp; (A::* access)(U i)&gt; c ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    A&amp; array, <BR>
     U size, <BR>
     U start = 0);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    a circulator <I>c</I> initialized to refer to the element
    <I>(array.*access)(start)</I>. The circulator <I>c</I> contains a
    singular value if <I>start &gt;= size</I>.
    <BR><STRONG>Precondition: </STRONG>The expressions
    <I>(array.*access)(i)</I> are valid in the range
    <MATH>0 &lt;=i &lt; </MATH><I>size</I> .
    <P>
        </TD></TR>
        </TABLE><!2>
<P>


<A NAME="Index_anchor_27"></A>

<A NAME="Cross_link_anchor_27"></A>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_27">CGAL_Const_circulator_over_array</A>&lt; A, T, U, I, const T&amp; (A::* access)(I i) const&gt; c;
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    a const circulator <I>c</I> with singular value.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_27">CGAL_Const_circulator_over_array</A>&lt; A, T, U, I, const T&amp; (A::* access)(I i) const&gt; c ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     A array, <BR>
     U size, <BR>
     U start = 0);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    a const circulator <I>c</I> initialized to refer to the element
    <I>(array.*access)(start)</I>. The circulator <I>c</I> contains a
    singular value if <I>start &gt;= size</I>.
    <BR><STRONG>Precondition: </STRONG>The expressions
    <I>(array.*access)(i)</I> are valid in the range
    <MATH>0 &lt;=i &lt; </MATH><I>size</I> .
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Operations</H3>The operations conform to the requirements for
random access circulators.
<P>

<H3>Example</H3>Considering an STL <TT>vector&lt;int&gt;</TT> with the
member function <TT>vector&lt;int&gt;::reference operator[]
(vector&lt;int&gt;::difference_type i)</TT> the following declaration
provides a random access circulator for it.
<P>

<PRE>
typedef vector&lt;int&gt; V;
typedef <A HREF="CGAL_Circulator_over_array.html#Cross_link_anchor_26">CGAL_Circulator_over_array</A>&lt; 
    V, 
    V::value_type, 
    V::size_type, 
    V::difference_type, 
    &amp; V::operator[]
&gt; <A HREF="Circulator.html#Cross_link_anchor_2">Circulator</A>;

V v1;
V v2;
v1.push_back( 2);
v1.push_back( 3);
<A HREF="Circulator.html#Cross_link_anchor_2">Circulator</A> c( v1, v1.size());
<A HREF="Circulator.html#Cross_link_anchor_2">Circulator</A> d( v1, v1.size(), 1);
<A HREF="Circulator.html#Cross_link_anchor_2">Circulator</A> e( v2, v2.size());
</PRE>
<P>

The random access circulator <TT>c</TT> circulates over the sequence
<TT>(2,3)</TT> starting with <TT>2</TT>. The circulator <TT>d</TT>
starts with <TT>3</TT> circulating over the same sequence. The
circulator <TT>e</TT> has a singular value.
<P>
<P>



<P><HR><H3>Footnotes</H3><P>

<OL>
<LI><A NAME="Footnote_1">The SGI CC and the Gnu g++ do support  member pointers in template arguments, the Sun CC does not. In this  case, the Gnu g++ fails also. The older C++ standard drafts rule  out this application of template arguments, the new drafts include  it.
</OL>
<HR><B> Return to chapter:</B> <A HREF="Chapter_Circulators.html">Circulators</A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_Circulators.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
