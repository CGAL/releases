<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_AffTransformation.html -->
  <!-- by cc_extract_html, $Revision: 2.8 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>The CGAL Kernel Manual: CGAL_Aff_transformation_2<R></TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_AffTransformation.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="../index.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->

<A NAME="Index_anchor_21"></A>

<A NAME="Cross_link_anchor_21"></A>

<P>

<H1> 2D Affine Transformation (<I><A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2</A></I>)</H1>
<P>

<H3>Definition</H3>Since two-dimensional points have three homogeneous
coordinates we have a <MATH>3&times; 3</MATH> matrix
(<MATH>m<SUB>ij</SUB></MATH>).
<P>

If the homogeneous representations are normalized such that the
homogenizing coordinate is 1, then the upper left
<MATH>2&times; 2</MATH> matrix realizes linear transformations and in
the matrix form of a translation, the translation vector
<MATH>(v<SUB>0</SUB>,</MATH> <MATH>v<SUB>1</SUB>,</MATH>
<MATH>1)</MATH> appears in the last column of the matrix. In this case
entry <MATH>hw</MATH> is always 1. Entries <MATH>m<SUB>31</SUB></MATH>
and <MATH>m<SUB>32</SUB></MATH> are always zero and therefore do not
appear in the constructors.
<P>

<I>#include &lt;<A HREF="../../../include/CGAL/Aff_transformation_2.h">
CGAL/Aff_transformation_2.h</A>&gt;</I>
<P>

<H3>Creation</H3>
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    const CGAL_Translation, <BR>
     <A HREF="CGAL_Vector_2.html#Cross_link_anchor_1">CGAL_Vector_2&lt;R&gt;</A> v);</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    introduces a translation by a vector <MATH>v</MATH>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    const CGAL_Rotation, <BR>
     <A HREF="CGAL_Direction_2.html#Cross_link_anchor_2">CGAL_Direction_2&lt;R&gt;</A> d, <BR>
     R::RT num, <BR>
     R::RT den = RT(1));</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    approximates the rotation over the angle indicated by direction
    <MATH>d</MATH>, such that the differences between the sines and
    cosines of the rotation given by d and the approximating rotation
    are at most <MATH>num/den</MATH> each.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    const CGAL_Rotation, <BR>
     R::RT sine_rho, <BR>
     R::RT cosine_rho, <BR>
     R::RT hw = RT(1));</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    introduces a rotation by the angle <I>rho</I>.
    <BR><STRONG>Precondition: </STRONG>
    <MATH>sine_rho<SUP>2</SUP> + cosine_rho<SUP>2</SUP> == hw<SUP>2</SUP></MATH>
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

.
<P>

        <!2><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    const CGAL_Scaling, <BR>
     R::RT s, <BR>
     R::RT hw = RT(1));</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    introduces a scaling by a scale factor <MATH>s/hw</MATH>.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     R::RT m11, <BR>
     R::RT m12, <BR>
     R::RT m13, <BR>
     R::RT m21, <BR>
     R::RT m22, <BR>
     R::RT m23, <BR>
     R::RT hw = RT(1));</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    introduces a general affine transformation in the 3x3 matrix form .
    The sub-matrix
    <MATH>((m<SUB>11</SUB>, m<SUB>21</SUB>)<SUP>t</SUP>, (m<SUB>12</SUB>, m<SUB>22</SUB>)<SUP>t</SUP>) </MATH>
    contains the scaling and rotation information, the vector
    <MATH>(m<SUB>13</SUB>, m<SUB>23</SUB>)<SUP>t</SUP> </MATH> contains
    the translational part of the transformation.
    <P>
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=30% NOWRAP COLSPAN=2>
        <I>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     R::RT m11, <BR>
     R::RT m12, <BR>
     R::RT m21, <BR>
     R::RT m22, <BR>
     R::RT hw = RT(1));</I></TD></TR></TABLE>
    
        </I>
        </TD></TR><TR><TD WIDTH=30%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=70%>
    introduces a general linear transformation , i.e. there is no
    translational part.
    <P>
        </TD></TR>
        </TABLE><!2>

<P>

<H3>Operations</H3>
<P>

The main thing to do with transformations is to apply them on geometric
objects. Each class <I>CGAL_Class_2&lt;R&gt;</I> representing a
geometric object has a member function:
<P>

<I>CGAL_Class_2&lt;R&gt; transform(<A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A> t)</I>
.
<P>

The transformation classes provide a member function <I>transform()</I>
for points, vectors, directions, and lines:
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="CGAL_Point_2.html#Cross_link_anchor_0">CGAL_Point_2&lt;R&gt;</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    t.transform (  <A HREF="CGAL_Point_2.html#Cross_link_anchor_0">CGAL_Point_2&lt;R&gt;</A> p)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="CGAL_Vector_2.html#Cross_link_anchor_1">CGAL_Vector_2&lt;R&gt;</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    t.transform (  <A HREF="CGAL_Vector_2.html#Cross_link_anchor_1">CGAL_Vector_2&lt;R&gt;</A> p)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="CGAL_Direction_2.html#Cross_link_anchor_2">CGAL_Direction_2&lt;R&gt;</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    t.transform (  <A HREF="CGAL_Direction_2.html#Cross_link_anchor_2">CGAL_Direction_2&lt;R&gt;</A> p)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    <A HREF="CGAL_Line_2.html#Cross_link_anchor_3">CGAL_Line_2&lt;R&gt;</A>
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=2>
        <I>
    t.transform (  <A HREF="CGAL_Line_2.html#Cross_link_anchor_3">CGAL_Line_2&lt;R&gt;</A> p)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TR>
        </TABLE><!3>

<P>

CGAL provides function operators for these member functions, that is:
<P>

        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=550>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    CGAL_PVDL_2&lt;R&gt;
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
     t (  CGAL_PVDL_2&lt;R&gt; p)
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A>
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
     t *  s
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    composes two affine transformations.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP COLSPAN=3>
        <I>
    <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;R&gt;</A>
        </I>
        </TD></TR><TR><TD WIDTH=25%></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    t.inverse ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    gives the inverse transformation.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    t.is_even ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, if the transformation is not reflecting, i.e.
    the determinant of the involved linear transformation is
    non-negative.
        </TD></TR>
        
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    bool
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=25% NOWRAP>
        <I>
    t.is_odd ()
        </I>
        </TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    returns <I>true</I>, if the transformation is reflecting.
        </TD></TR>
        </TABLE><!3>

<P>

For affine transformations no I/O operators are defined.
<P>

<H3>Implementation</H3>Depending on the constructor we have different
internal representations. This approach uses less memory and the
transformation can be applied faster.
<P>

Affine transformations offer no <I>transform()</I> member function for
complex objects because they are defined in terms of points vectors and
directions. As the internal representation of a complex object is
private the transformation code should go there.
<P>

<H3>Example</H3>
<PRE>
  typedef CGAL_Cartesian&lt;double&gt; RepClass;
  typedef <A HREF="CGAL_Aff_transformation_2.html#Cross_link_anchor_21">CGAL_Aff_transformation_2&lt;RepClass&gt;</A> Transformation;
  typedef <A HREF="CGAL_Point_2.html#Cross_link_anchor_0">CGAL_Point_2&lt;RepClass&gt;</A> Point;
  typedef <A HREF="CGAL_Vector_2.html#Cross_link_anchor_1">CGAL_Vector_2&lt;RepClass&gt;</A> Vector;
  typedef <A HREF="CGAL_Direction_2.html#Cross_link_anchor_2">CGAL_Direction_2&lt;RepClass&gt;</A> Direction;

  Transformation rotate(<A HREF="Chapter_AffTransformation.html#Var_CGAL_ROTATION">CGAL_ROTATION</A>, sin(pi), cos(pi));
  Transformation rational_rotate(<A HREF="Chapter_AffTransformation.html#Var_CGAL_ROTATION">CGAL_ROTATION</A>,Direction(1,1), 1, 100);
  Transformation translate(<A HREF="Chapter_AffTransformation.html#Var_CGAL_TRANSLATION">CGAL_TRANSLATION</A>, Vector(-2, 0));
  Transformation scale(<A HREF="Chapter_AffTransformation.html#Var_CGAL_SCALING">CGAL_SCALING</A>, 3);

  Point q(0, 1);
  q = rational_rotate(q); 

  Point p(1, 1);

  p = rotate(p); 

  p = translate(p); 

  p = scale(p);
</PRE>
<P>

The same would have been achieved with
<P>

<PRE>

  Transformation transform = scale * (translate * rotate);
  p = transform(Point(1.0, 1.0));
</PRE>
<P>
<HR> <B>Next:</B>  Class declaration of <A HREF="CGAL_Aff_transformation_3.html"><I>CGAL_Aff_transformation_3&lt;R&gt;</I></A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_AffTransformation.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="../index.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.ruu.nl/CGAL/><TT>CGAL</TT> Project</A>.    Mon, June 30, 1997. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
