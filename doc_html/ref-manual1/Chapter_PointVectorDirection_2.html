<!-- Begin of cc_manual_header -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

  <!-- CC manual page automatically extracted from a TeX specification -->
  <!-- in file Chapter_PointVectorDirection_2.html -->
  <!-- by cc_extract_html, $Revision: 2.18 $. -->

<!--  Title -->
  <HEAD>
  <TITLE>Reference Manual: </TITLE>
  </HEAD>

<!-- Background layout-->
  <BODY BGCOLOR="FAF8E8" TEXT="#000000">

<!-- Navigation -->
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_PointVectorDirection_2.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="title.html">Title Page</A>
<HR>

<!-- End of cc_manual_header -->
<H1>2D Point, Vector and Direction <A NAME="PointVectorDirection"></A></H1>
<P>

We strictly distinguish between points, vectors and directions.
A <EM>point</EM> is a point in the two-dimensional Euclidean plane
<MATH><B>E</B><SUB>2</SUB></MATH>, a <EM>vector</EM> is the difference of two points <MATH>p<SUB>2</SUB></MATH>, <MATH>p<SUB>1</SUB></MATH>
and denotes the direction and the distance from <MATH>p<SUB>1</SUB></MATH> to <MATH>p<SUB>2</SUB></MATH> in the
vector space <MATH><B>R</B><SUP>2</SUP></MATH>, and a <EM>direction</EM> is a vector where we forget
about its length.
They are different mathematical concepts. For example, they behave
different under affine transformations and an addition of two
points is meaningless in affine geometry. By putting them in different
classes we not only get cleaner code, but also type checking by the
compiler which avoids ambiguous expressions. Hence, it pays twice to
make this distinction.<P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Point_2.html"><I>CGAL_Point_2&lt;R&gt;</I></A>.</UL>

<P>

<A NAME="Section_10"></A>
<H2>Point Conversion</H2>
<P>

For convenience, CGAL provides functions for conversion of points between
homogeneous and Cartesian representation.<P>

<I>#include &lt;CGAL/cartesian_homogeneous_conversion.h&gt;</I><P>

Conversion from Cartesian representation to homogeneous representation with the
same number type is straightforward.
The homogenizing coordinate is set to 1, all other homogeneous
coordinates are copied from the corresponding Cartesian coordinate.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Point_26_CGAL_Homogeneous6RT9_9_CGAL_cartesian_to_homogeneous6const_CGAL_Point_26_CGAL_Cartesian6RT9_9__cp9;"></A>
<A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Homogeneous.html#Cross_link_anchor_1">CGAL_Homogeneous&lt;RT&gt;</A> &gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_cartesian_to_homogeneous ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Cartesian.html#Cross_link_anchor_0">CGAL_Cartesian&lt;RT&gt;</A> &gt; cp)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    converts 2d point <I>cp</I> with Cartesian representation into a 2d
    point with homogeneous representation with the same number type.
        </TD></TR>
        </TABLE><!3>
<P>

Conversion from homogeneous representation to Cartesian representation with
the same number type involves division by the homogenizing coordinate.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Point_26_CGAL_Cartesian6FT9_9_CGAL_homogeneous_to_cartesian6const_CGAL_Point_26_CGAL_Homogeneous6FT9_9__hp9;"></A>
<A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Cartesian.html#Cross_link_anchor_0">CGAL_Cartesian&lt;FT&gt;</A> &gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_homogeneous_to_cartesian ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Homogeneous.html#Cross_link_anchor_1">CGAL_Homogeneous&lt;FT&gt;</A> &gt; hp)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    converts 2d point <I>hp</I> with homogeneous representation into a
    2d point with Cartesian representation with the same number type.
        </TD></TR>
        </TABLE><!3>
<P>

Since conversion involves division, concerning exactness, the correspondence is
rather between homogeneous representation with number type <I>RT</I> and
Cartesian representation with number type <I>CGAL_Quotient&lt;RT&gt;</I> than
between representation with the same number type.<P>


        <!3><TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0 WIDTH=650>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Point_26_CGAL_Cartesian6CGAL_Quotient6RT9_9_9_CGAL_homogeneous_to_quotient_cartesian6__const_CGAL_Point_26CGAL_Homogeneous6RT9_9__hp9;"></A>
<A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Cartesian.html#Cross_link_anchor_0">CGAL_Cartesian</A>&lt;CGAL_Quotient&lt;RT&gt; &gt; &gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_homogeneous_to_quotient_cartesian ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt;<A HREF="CGAL_Homogeneous.html#Cross_link_anchor_1">CGAL_Homogeneous&lt;RT&gt;</A> &gt; hp)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    converts 2d point <I>hp</I> with homogeneous representation with
    number type <I>RT</I> into a 2d point with Cartesian representation
    with number type <I>CGAL_Quotient&lt;RT&gt;</I>.
        </TD></TR>
        <TR><TD><BR></TD></TR>
        <TR><TD ALIGN=LEFT VALIGN=TOP WIDTH=100% COLSPAN=3>
        <I><NOBR>
    <A NAME="Function_CGAL_Point_26_CGAL_Homogeneous6RT9_9_CGAL_quotient_cartesian_to_homogeneous6__const_CGAL_Point_26_CGAL_Cartesian6_CGAL_Quotient6RT9_9_9__cp9;"></A>
<A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Homogeneous.html#Cross_link_anchor_1">CGAL_Homogeneous&lt;RT&gt;</A> &gt;
        </I></NOBR>
        </TD></TR><TR><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=75% NOWRAP COLSPAN=2>
        <I><NOBR>
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
    CGAL_quotient_cartesian_to_homogeneous ( </I></TD><TD ALIGN=LEFT VALIGN=TOP NOWRAP><I>
     <A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Cartesian.html#Cross_link_anchor_0">CGAL_Cartesian</A>&lt; CGAL_Quotient&lt;RT&gt; &gt; &gt; cp)</I></TD></TR></TABLE>
    
        </I></NOBR>
        </TR><TR><TD WIDTH=25% NOWRAP></TD><TD WIDTH=25% NOWRAP></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=50%>
    converts 2d point <I>cp</I> with Cartesian representation with
    number type <I>CGAL_Quotient&lt;RT&gt;</I> into a 2d point with
    homogeneous representation with number type <I>RT</I>.
        </TD></TR>
        </TABLE><!3>
<P>

Of the last two functions,
the conversion from homogeneous representation to Cartesian representation
with quotients is always exact.
The Conversion from Cartesian representation
with quotients to homogeneous representation, however, might be inexact
with some number types due to overflow or rounding in multiplications.<P>

<P><P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Vector_2.html"><I>CGAL_Vector_2&lt;R&gt;</I></A>.</UL>

<P>

<P><P>

<UL><LI>
 Class declaration of <A HREF="CGAL_Direction_2.html"><I>CGAL_Direction_2&lt;R&gt;</I></A>.</UL>

<P>

<A NAME="Section_11"></A>
<H2>Conversion between Points and Vectors<A NAME="conversion"></A></H2>
<P>

We stated earlier that it does not make sense to add two points, but it does
make sense to subtract them and the result should be a vector.
CGAL defines a symbolic constant <I>CGAL_ORIGIN</I> which denotes
the point at the origin. Subtracting it from a
point <MATH>p</MATH> results in the locus vector of <MATH>p</MATH>.<P>

<PRE>

  <A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2</A>&lt; <A HREF="CGAL_Cartesian.html#Cross_link_anchor_0">CGAL_Cartesian&lt;double&gt;</A> &gt;  p(1.0, 1.0), q;

  CGAL_Vector2&lt; <A HREF="CGAL_Cartesian.html#Cross_link_anchor_0">CGAL_Cartesian&lt;double&gt;</A> &gt;  v;

  v = p - CGAL_ORIGIN;

  q = CGAL_ORIGIN + v;  
</PRE><P>

In order to obtain the point corresponding to a vector <MATH>v</MATH> you simply
have to add <MATH>v</MATH> to <I>CGAL_ORIGIN</I>. If you want to determine
the point <MATH>q</MATH> in the middle between two points <MATH>p<SUB>1</SUB></MATH> and <MATH>p<SUB>2</SUB></MATH>, you can write<P>

<PRE>

  q = p_1 + (p_2 - p_1) / 2.0;
</PRE><P>

Note that these constructions do not involve any performance overhead for
the conversion with the currently available representation classes,
if compiler optimisation is used, see also below.<P>

<A NAME="Section_12"></A>
<H2>Implementation</H2>
<P>

Points, vectors and directions use a handle/representative mechanism.
A handle is an intelligent pointer, a representative is an object with a
reference counter. The three classes have the same internal
representation, namely a tuple of coordinates (plus a homogenizing
coordinate in the case of homogeneous coordinates), which makes
assignment, copy constructors and type conversion cheap.<P>

An assignment makes the handle of the left hand side point to the
representative the handle on the right hand sidepoints to. The copy
constructor creates a new handle which points to the same
representative. This especially pays if your coordinates are of
non-constant size.<P>

What about conversion? We explained that you convert by subtracting
the origin from a point to obtain its locus vector, or by adding a
vector to the origin to obtain the corresponding point. Although the
origin behaves like a point, <I>CGAL_ORIGIN</I> is not an object of
the class <I><A HREF="CGAL_Point_2.html#Cross_link_anchor_4">CGAL_Point_2&lt;R&gt;</A></I> but of the class
<I>CGAL_Origin</I>. All constructors and operators taking a point
as argument are overloaded with the origin class in order to avoid
memory allocation (for a point with coordinates zero), and arithmetic
operations (where numbers would be added to zero). To give an example:
when you ``add'' a vector <MATH>v</MATH> to the origin, only a new handle is created
which points to the representation of <MATH>v</MATH>.<P>

<P>

<P><HR> Next chapter: <A HREF="Chapter_LineRaySegment_2.html">2D Line, Ray and Segment</A>
<!-- Begin of cc_manual_footer -->
<!-- ------------------------- -->
<!-- $Revision: 1.1 $ -->
<!-- $Date: 1997/05/09 12:27:08 $ -->

<!-- Navigation -->
<HR>
  <STRONG>Navigation:</STRONG>
  <A HREF="Chapter_PointVectorDirection_2.html">Up</A>,
  <A HREF="contents.html">Table of Contents</A>,
  <A HREF="biblio.html">Bibliography</A>,
  <A HREF="manual_index.html">Index</A>,
  <A HREF="title.html">Title Page</A>
<HR>

<address> 
  The <A HREF=http://www.cs.uu.nl/CGAL/>CGAL Project</A>.    Tue, April 21, 1998. 
</address>
</BODY>
</HTML>

<!-- End of cc_manual_footer -->
